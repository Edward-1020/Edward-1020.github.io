<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经典数据结构--堆的应用（二）]]></title>
    <url>%2F2018%2F01%2F30%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[贪心问题题目：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板？ 例如，给定数组[10, 20, 30]，代表一共三个人，整块金条长度为10 + 20 + 30 = 60.金条要分成10, 20, 30三个部分。如果，先把长度60的金条分成10和50，花费60。再把长度50的金条分成20和30，花费50。一共花费110铜板。 但是，如果先把长度60的金条分成30和30，花费60。再把长度30的金条分成10和20，花费30。一共花费90铜板。 输入一个数组，返回分割的最小代价。 实质 怎样生成一棵树，堆顶的值最小？ 一棵树堆顶的代价，是左孩子 + 右孩子。 例如：60的金条要分成10, 20, 30三个部分。用树表示开销最小的方式是： 那么整个的代价就是非叶节点的代价，60 + 30 = 90。 即：把所有的数组成一个小根堆，每次弹两个。这弹出的两个生成一个新的节点加回去。再弹出两个，再生成一个新的节点加回去。 即这个小根堆，最小的两个节点先合，再合大的。 这就是哈弗曼树生成。 生成哈弗曼树举例 堆：1，3，6，9，15。 弹出1，3；生成节点4。 将4放回堆中。 4，6，9，15。 弹出4，6；生成节点10。 将10放回堆中。 9，10，15。 19，15 34 最终得到的代价一定是最低的。 特点合并的时候不分顺序，使用哈夫曼编码。 关键代码12345678910// pQ树的size大于1，小于等于1无法抛出两个节点合并while (pQ.size() &gt; 1) &#123; // pQ树抛出两次 cur = pQ.poll() + pQ.poll() // 代价是非叶节点的值，所以加上 sum += cur // 新的值扔回pQ pQ.add(cur)&#125;return sum]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--堆的应用(一)]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[随时找到数据流的中位数题目：有一个源源不断吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。 要求：1、如果MedianHolder已经保存了吐出的N个数，那么任意时刻将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。2、取得已经吐出的N个数整体的中位数的过程，时间复杂度为O（1）。 较差方法 准备一个数组，向数组内push数。数组满了以后，需要扩容。每次扩容后，继续push数。 取中位数的时候，排序，再取出中位数。 当已经加入n个数时，最起码经过n * logN的排序过程。 所以每次取中位数时，时间复杂度是n * logN。 数组扩容：ArrayList底层是动态数组，找index位置元素快，扩容容易。但是remove元素慢，因为每删除一个元素都需要对整个数组进行重新调整。linkedList底层是双向链表结构，找Index位置的元素慢，但是remove快。 使用堆 建立一个大根堆和一个小根堆。 整个数组从小到大排序之后，前 N /2 放在大根堆里，后 N / 2放在小根堆里，这样大根堆的堆顶和小根堆的堆顶正好压中中位数。 如何建立堆 第一个数放在大根堆 再放入数时，比大根堆堆顶大的放在小根堆里，比大根堆堆顶小的放在大根堆中。 当大根堆的size和小根堆的size相差1，大根堆中堆顶弹出一个，进入到小根堆。或者小根堆中堆顶弹出一个，进入到大根堆。 如何操作堆 向堆中加入元素：heapInsert。 弹出堆顶：size–，最后一个元素放在头部，堆顶的元素弹出，heapify。 关键代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void addNumber (int num) &#123; // 大根堆是空直接添加num if (this.maxHeap.isEmpty()) &#123; this.maxHeap.add(num) return &#125; // 如果大根堆顶大于num，进大根堆 if (this.maxHeap.peek() &gt;= num) &#123; this.maxHeap.add(num) &#125; else &#123; if (this.minHeap.isEmpty()) &#123; this.minHeap.add(num) return &#125; if (this.minHeap.peek() &gt; num) &#123; this.maxHeap.add(num) &#125; else &#123; this.minHeap.add(num) &#125; &#125; modifyTwoHeapSize()&#125;// 堆调平private void modifyTwoHeapsSize () &#123; if (this.maxHeap.size() == this.minHeap.size() + 2) &#123; // 小根堆弹一个进大根堆 this.minHeap.add(this.maxHeap.poll()) &#125; if (this.minHeap.size() == this.maxHeap.size() + 2) &#123; this.maxHeap.add(this.minHeap.poll()) &#125;&#125;// 取中位数public Integer getMedian () &#123; int maxHeapSize = this.maxHeap.size() int minHeapSize = this.minHeap.size() if (maxHeapSize + minHeapSize === 0) &#123; return null &#125; Integer maxHeapHead = this.maxHeap.peek() Integer minHeapHead = this.minHeap.peek() if ((maxHeapSize + minHeapSize) &amp; 1) == 0) &#123; // 偶数，返回两个堆顶除以2的值 return (maxHeapHead + minHeapHead) / 2 &#125; // 奇数返回Size较大的那个头 return maxHeapSize &gt; minHeapSize ? maxHeapHead : minHeapHead&#125; 这里用到了Java优先级队列库 优先级队列就是尾部加一个数，经过一个HeapInsert poll（）操作，堆顶弹出，当前堆末尾元素放在堆顶，经过一个heapify。 复杂度 一个数插入的复杂度是O(logN)。 poll操作复杂度是O(logN)。 得到中位数的操作是O(1)。 总结当你需要关注一系列数的最大值和最小值，取出最大值或最小值以后还能再取得最大值和最小值，这就需要堆结构。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（六）]]></title>
    <url>%2F2018%2F01%2F27%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[反转链表题目：分别实现反转单向链表和反转双向链表的函数要求：如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1) 反转单向链表–关键代码12345678910111213141516171819public static class Node &#123; public int value; public Node next; public Node (int data) &#123; this.value = data; &#125;&#125;public static Node reverseList (Node head) &#123; Node pre = null; Node next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125;&#125; 反转双向链表关键代码12345678910111213141516171819202122public static class DoubleNode &#123; public int value; public DoubleNode last; public DoubleNode next; public DoubleNode (int data) &#123; this.value = data; &#125;&#125;public static DoubleNode reverseList (DoubleNode head) &#123; DoubleNode pre = null DoubleNode next = null while (head != null) &#123; next = head.next; head.next = pre; head.last = next; pre = head; head = next; &#125; return pre;&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（五）]]></title>
    <url>%2F2018%2F01%2F25%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链表生存题目-链表相交题目：在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N + M)，额外空间复杂度请达到O(1)。 思路 到底有环还是无环，需要一个函数求第一个入环节点。如果链表无环返回null，有环返回第一个入环函数。 map比较的是内存地址，不比值。 求解入环函数（map版本） 如何求入环节点？遍历一个链表，在链表上的node点放入map中，由于链表形成环，会有一个节点再次进入哈希map表中。例如 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，而5指向之前的2，那么这个2就是第一个入环节点，会再次进入哈希map表中。 求解入环函数（非map版本） 遍历链表，慢指针一次走一步，快指针一次走两步，如果无环链表，快指针一定会指向null。 遍历链表，慢指针一次走一步，快指针一次走两步，如果有环链表，快指针和慢指针一定会在环上相遇。相遇后，有一个结论：相遇后，快指针回到开头，接下来，快指针变为一次走一步，慢指针留在原地仍一次走一步，那么，快指针和慢指针一定会在第一个入环节点处相遇。 求解相交 已知链表1的头head1，第一个入环节点loop1；链表2的头head2，第二个入环节点loop2。 如果loop1为null，loop2为null，问题为两个无环节点的相交问题。 两个无环链表相交 使用map。首先遍历head1的链表放入map。然后再遍历head2的链表，对于head2中的节点，第一次发现head2的节点已经在map中了，那么这就是第一次相交的节点。 不使用map。找head1的最后一个节点last1，可能在链表1的第100个节点上。找head2的最后一个节点last2，可能在链表2的第80个节点上。那么如果两个无环链表相交，那么他们的最后一个节点一定相同；不相同，则不相交。 如何不用map找第一个相交节点呢？长度为100的链表先走20步，然后和长度80的一起走，他们一定会共同走进相交的部分。 一个链表有环和一个链表无环这种情况两个链表不可能相交。 两个链表都有环 三种结构：1.两个链表都有环，不想交。2.两个链表很早相交了，有一个共有的环。3.两个链表共享一个环。 结构一 这里loop1和loop2（第一个入环节点），都不为空，且相等，那么就是上结构。如何求此结构的相交节点？这两个链表以loop1为结尾，不看成环部分，那么问题就变为两个无环链表的相交问题了，考察它的第一个入环节点即可。 结构二 如果loop1通过next指针一直向下走，在走的过程中碰到loop2便是上结构。loop1和loop2都是第一个相交节点。 结构三- 如果loop1通过next指针一直向下走，走到回来了，还没碰到loo2便是上结构。无相交节点。 代码12345678910111213141516171819public static Node getIntersectNode (Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null &#125; // 得到链表1和2第一个入环节点 Node loop1 = getLoopNode(head1) Node loop2 = getLoopNode(head2) // 无环链表相交问题 // 要返回无环链表的第一个相交节点 if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1, head2) &#125; // 两个有环链表相交问题 if (loop1 != null &amp;&amp; loop2 != null) &#123; return bothLoop(head1, loop1, head2, loop2) &#125; // 说明一个链表有环，一个无环，不可能相交 return null&#125; 123456789101112131415161718192021222324252627282930// 得到第一个入环节点函数public static Node getLoopNode (Node head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return null &#125; // n1是慢指针，一次走一步 // n2是快指针，一次走两步 Node n1 = head.next Node n2 = head.next.next while (n1 != n2) &#123; // 有一个为null，说明没有入环节点，返回null if (n2.next == null || n2.next.next == null) &#123; return null &#125; // n1是慢指针，一次走一步 // n2是快指针，一次走两步 n2 = n2.next.next n1 = n1.next &#125; // 跳出while，说明n1 = n2，n1和n2相遇 // 快指针回到开头，n1和n2都各每次走一步 n2 = head while (n1 != n2) &#123; n1 = n1.next n2 = n2.next &#125; // 再次相遇,n1 = n2 ，这个就是入环节点 return n1&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 无环链表相交问题 public static Node noLoop(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node cur1 = head1; Node cur2 = head2; int n = 0; while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; if (cur1 != cur2) &#123; return null; &#125; //n是否大于0，代表head1和head2谁更长 // cur1 代表长的 // cur2 代表返回了短的 // 此时cur1代表 cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; // n的绝对值代表两个链表差值的步数 n = Math.abs(n); // 长的先走差值步 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; // 然后两条链一起走 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; // 相遇时，返回第一个相交节点 return cur1; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 有环链表相交问题 public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; Node cur1 = null; Node cur2 = null; // loop1和loop2相等，那截掉环 // 问题就变成了无环链表的相交问题 if (loop1 == loop2) &#123; cur1 = head1; cur2 = head2; int n = 0; // 终止条件变为cur1到达第一个入环节点就不再遍历 while (cur1 != loop1) &#123; n++; cur1 = cur1.next; &#125; // 终止条件变为cur2到达第一个入环节点就不再遍历 while (cur2 != loop2) &#123; n--; cur2 = cur2.next; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; // 一样走差值步 n = Math.abs(n); while (n != 0) &#123; n--; cur1 = cur1.next; &#125; // 一样返回相交的位置 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; else &#123; // 共享环结构 cur1 = loop1.next; // 中途cur1遇到了loop2，随便返回一个 while (cur1 != loop1) &#123; if (cur1 == loop2) &#123; return loop1; &#125; cur1 = cur1.next; &#125; // 中途没有遇到loop2，说明两个有环的链表，是66结构 return null; &#125; &#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（四）]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复制含有随机指针节点的链表题目：一种特殊的链表节点类描述如下：12345678910public class Node &#123; public int value; public Node next; public Node rand; public Node (int data) &#123; this.value = data &#125; &#125;&#125; 即本来 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null，但是多了个随机指针，1的random指针可能指向3，2的random指针可能指向4等等。需要：拷贝一个这样的链表的结构，并且链表上的node的random指针也要拷贝下来，并返回新的头部。 思路 思路一（使用map）： 使用哈希map，将节点克隆下来：（1，1‘）、（2，2’）、（3，3‘），并在克隆的同时，让1’的next指针指向2‘，2’的next指针指向3‘。 现在我们看各节点random指针指向谁？遍历哈希表：假设拿到（2，2’），看2的random指针指向谁，就让2’的random指针指向谁的克隆节点。 这样遍历下来，就可以设置好所有的random节点，最后返回一个1‘。 思路二（调整链表替代map，不使用额外空间）： 克隆节点，并放在老节点后面，如做成这样的结构：1 -&gt; 1’ -&gt;2 -&gt; 2’ -&gt; 3 -&gt; 3’ -&gt; null。此时1，2，3的random指向没有变化。 此时1’，2‘，3’的random指向为null。 遍历大链表 1 -&gt; 1’ -&gt;2 -&gt; 2’ -&gt; 3 -&gt; 3’ -&gt; null。拿到（1，1‘），1的random我们是知道的，假设为3。此时3的next指向3‘，我们就很容易的将1’的random指针也指向了3‘。 然后将1’，2‘，3’分离出来。利用奇数头和偶数头，遍历时奇数是老链表，偶数是新链表。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（三）]]></title>
    <url>%2F2018%2F01%2F22%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[将单向链表按某值划分成左边小、中间相等、右边大的形式题目：给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。除这个要求外，对调整后的节点顺序没有更多的要求。例如：链表 9 -&gt; 0 -&gt; 4 -&gt; 5 -&gt; 1，pivot = 3。调整后链表可以是 1 -&gt; 0 -&gt; 4 -&gt; 9 -&gt; 5，也可以是 0 -&gt; 1 -&gt; 9 -&gt; 5 -&gt; 4。总之，满足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不作要求。 思路 思路一： 3个队列。 小于放小于队列，等于放在等于队列，大于放在大于队列。 队列都倒出来连在一起。 思路二： 第一次遍历链表，找到第一个小于划分值的节点，作为一个头部。 第一次遍历链表，找到第一个等于划分值的节点，作为一个头部。 第一次遍历链表，找到第一个大于划分值的节点，作为一个头部。 第二次遍历链表，将遍历的点挂载到相应的头部后。 将这三个链表首尾相连。 链表题目oj使用容器，快；面试，工程使用内存少，空间少。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（二）]]></title>
    <url>%2F2018%2F01%2F22%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[判断一个链表是否为回文结构给定一个链表的头节点head，请判断该链表是否为回文结构题目：给定一个链表的头节点head，请判断该链表是否为回文结构，即从node级别看是不是回文。例如：1 -&gt; 2 -&gt; 1，返回true。1 -&gt; 2 -&gt; 2 -&gt; 1，返回true。15 -&gt; 6 -&gt; 15，返回true。1 -&gt; 2 -&gt; 3，返回false进阶：如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。 思路 思路一： 遍历链表，然后将链表放入栈中，栈中是链表的逆序。 再从头开始遍历，栈也依次弹出一个。比较，原列表遍历到结尾，栈也弹完。 每次遍历的值与栈弹出的值相同。 思路二： 慢指针一次走一步，快指针一次走两步，当快指针走完时，慢指针来到了中间位置。 将慢指针所在位置的后面的，剩余的链表压栈。 你只遍历慢指针所在位置的，前面的链表。看看这部分与压在栈中的部分是否相同。 相当于以链表中心为对折点，将链表对折，看看是否相等。 如此这般，栈就节省了一半的空间。 思路三(不使用栈结构)： 例如 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1，慢指针一次走一步，快指针一次走两步找到中点3. 处理链表为 1 -&gt; 2 -&gt; 3 &lt;- 2 &lt;- 1，分别从两头开始遍历比较，如果都一样，那就是回文。 在比较的过程中，reverse的部分再reverse回来。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（一）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打印链表公共部分给定两个有序链表的头指针head1和head2，打印两个链表的公共部分 流程 从头开始看两个链表上的值，谁小就往下走一位。 相等就共同向下走一位，并打印想等值 即谁小谁动，相等就一起走。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（三）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[“之”字型打印给定一个矩阵matrix，按照“之”字形的方式打印这个矩阵，例如：1 2 3 45 6 7 89 10 11 12“之”字型打印的结果为：1，2，5，9，6，3，4，7，10，11，8，12要求：额外空间复杂度为O(1)。 方案 宏观去想 从1开始建立坐标轴（x, y）。a朝x正坐标方向走，b朝y负坐标方向走。 第一次a到2，b到5，画出对角线：2，5 第二次，a到3，b向下走到9，画出对角线：3，6，9 如此这般，能得到各个对角线。 打印对角线，第一次打印从左下向右上，第二次从右上向左下，第三次从左下向右上。我们提供一个打印函数，给一个布尔值确定打印方向。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（二）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在行列都排好序的矩阵中找数给定一个N * M的整型矩阵matrix和一个整数K，matrix的每一行和每一个列都是排好序的。实现一个函数，判断K是否在matrix中。例如：0 1 2 72 5 6 74 6 7 85 7 8 9如何k为7，返回true；如果k为6，返回false。 要求：时间复杂度为O(N + M)，额外空间复杂度为O(1)。 流程 假设我们寻找5 从右上角开始，从第4列着手。7是该列最小的，比5大，所以5不在该列。 向左移动一列，从第三列着手。2是该行除7外最大的，比5小，所以该行也比11小。 向下移动一行，因为6是比5大的，所以6所在列是不可能的。 所以向左移动，找到了5 显然，从右上角开始，大就向左移动，小就向下移动。 原因是：若该数比k大，则该列无可能。该数比5小，则该行无可能。所以大向左移动，小向下移动。 若是越界了，说明矩阵中没有要找的k值。 我一共最多走 M（行） + N (列)步就能找到k值，所以时间复杂度是O(N + M)。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（一）]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转圈打印矩阵给定一个整型矩阵matrix，请按照转圈的方式打印它1 2 3 45 6 7 89 10 11 1213 14 15 16打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11。要求：额外空间复杂度为O(1)。 不要把视线局限在局部区域变化 1点（0，0），16点（3，3）。 列数++，到3 行数++，到3 列数–，到0 行数–，到0 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243// tR，tC，左上角的行数和列数// dR，dC，右下角的行数和列数public static void printEdge (init[][] m, int tR, int tC, int dR, int dC) &#123; // 只有一行，顺序打印 if (tR == dR) &#123; for (int i = tC; i &lt;= dC; i++) &#123; System.out.print(m[tR][i] + &quot; &quot;) &#125; &#125; else if (tC == dC) &#123; // 只有一列，按顺序打印列 for (int i = tR; i &lt;= dR; i++) &#123; System.out.print(m[i][tC] + &quot; &quot;) &#125; &#125; else &#123; int curC = tC int curR = tR // 列数不等，列数++ while (curC != dC) &#123; System.out.print(m[tR][curC] + &quot;&quot;) curC++ &#125; // 行数不等，行数++ while (curR != dR) &#123; System.out.print(m[curR][dc] + &quot;&quot;) curR++ &#125; // 列数不等，列数-- while (curC != tC) &#123; System.out.print(m[dR][curC] + &quot;&quot;) curC-- &#125; // 行数不等，行数-- while (curR != tR) &#123; System.out.print(m[curR][tC] + &quot;&quot;) curR-- &#125; &#125;&#125;// 打印完最外层后，左上角向右下方移动，右下角向左上方移动// 如此，就可以分圈结构的宏观调用// 一圈，一圈的分圈执行函数// 左上角的行大于右下角的行，或者左上角的列大于右下角的列，停止 将原矩阵顺时针转90°利用分圈结构写。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--哈希相关题目]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[RandomPool结构设计一种结构，在该结构中有如下三个功能：insert(key)：将某个key加入到该结构，做到不重复加入。delete(key)：将原本在结构中的某个key移除。getRandom()：等概率随机返回结构中的任何一个key。要求：Insert，delete，getRandom方法的时间复杂度是O(1)。 思考 哈希表不负责等概率的随机返回一个key，只保证每个数据域后挂载的数据链是均匀增长的。不能单纯使用哈希表。 结构设计 有两个哈希表：map1和map2。 map1负责记录数据进来的次序index。例如向map1中加入一条数据”A”，则map中存有这么一条数据：(key：A，value：0)，表示数据“A”是进入的第0个数据。 map2负责记录的数据正好与map1相反。map2的key就是0，value就是A。 即map1和map2表示从key查或者从value查都能查到这个数据。 无删除行为（只有加，没有减）等概率随机返回Index对应的数据：假设整个哈希表的大小是26，那么size对应的值就是26。random函数，传进去26，等概率的返回[0，25]中的某个随机数。用这个随机数作为index，从map2中查出返回值。 含删除行为例如[0，1000]，共1001个数。[0，999]个给删除掉了。那么按照我们上述方法去随机取值，很大概率会random到空值。所以我们能够向上述这么做的前提是，所有Index都连在一起，没有空值。 例如 map1：（a, 0），（b, 1），（c, 2），（d, 3）。map2：（0, a），（1, b），（2, c），（3, d）。 删除 “b”，怎么删？将“d”，放在原来的(b, 1)的位置上，然后删掉最后一行。 这样，我们的index区域始终连续。 关键代码12345678910111213141516171819202122232425262728293031323334// 插入public void insert (K key) &#123; // 从keyIndexMap中先查是否存在这个数 if (!this.keyIndexMap.containsKey(key)) &#123; // 不存在，就将这个数加进去 this.keyIndexMap.put(key, this.size) this.indexKeyMap.put(this.size++, key) &#125;&#125;// 随机取public K getRandom () &#123; if (this.size === 0) &#123; return null &#125; // 从indexKeyMap中随机取 randomIndex = (int)(Math.random() * this.size) return this.indexKeyMap.get(randomIndex)&#125;// 删除行为// 通过size找最后一个元素// 将要删的放最后，最后的放要删的位置，删除最后一个public void delete (K key) &#123; if (this.keyIndexMap.containsKey(key)) &#123; int deleteIndex = this.keyIndexMap.get(key) int lastIndex = --this.size K lastKey = this.indexKeyMap.get(lastIndex) this.keyIndexMap.put(lastKey, deleteIndex) this.indexKeyMap.put(deleteIndex, lastKey) this.keyIndexMap.remove(key) this.indexKeyMap.remove(lastIndex) &#125;&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--一致性哈希]]></title>
    <url>%2F2018%2F01%2F11%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[函数是哈希函数的要求 要求一：1. 你的输入域是无穷大的。例如：f(String str)，可以认为该函数的输入域是无穷大的。2. 你的输出域是有限的。大多哈希函数可以做到2^64 - 2^ 128。 为什么有这两个要求。因为现实生活中，我们想让目标数经过哈希后落到一个有限的范围内。 要求二：当输入参数一旦确定，返回值一定也确定了。即哈希函数没有随机成分，是用某种规则处理出来的信息。 输入域无限，输出域有限，输入参数确定则输出值也确定，这3点会导致，不同的输入会有相同的输出。 要求三：输入域无穷大，映射到一个较小的范围S（2^64 - 2^ 128）。我们要求：所有的输入值，映射后会均匀的摊在整个S上。例如：输出域S是0，1，2，不管你的输入值如何。如果输入是0，1，2 … 98，我们传进来99个值。则输出值是0的差不多33个，1差不多33个，2差不多33个。 我们称“要求三”是指：哈希函数的离散性，一个哈希函数设计的好不好就是看它的离散性好不好。 哈希值取模（%） 一个参数经过哈希函数F后得到一个哈希值去模（%）m。大量的参数经过哈希函数F后得到一个哈希值去%m。最终，得到的返回值会均匀分布在m - 1 上。 即哈希值在我们的S域上指均摊的，我们将S域给模上M，返回值就均摊在m - 1上。 经典缓存结构 三台服务器构成的一个服务器集群。上面存key-value形式的信息，我希望这三台服务器负载均衡。 机器分别为0，1，2。来了个信息A[key, value]。信息A经过哈希，得到的哈希值再经过一个模3。得到的模值，出来0，到机器0上；出来1，到机器1上；出来2，到机器2上。 插入的逻辑同上，查询的逻辑同理。 因为哈希函数的特性，我们的信息插入时是均匀分摊在这3台机器上的，我们的查询也是均匀分摊在这三台机器上的。所以，负载均衡。 经典缓存结构副作用 一旦加减机器，我们原来分摊在机器上的数据都需要变化。数据迁移的代价十分高。 解决方式-一致性哈希 假设哈希函数f，以下所有的操作使用的哈希函数均一致。 假设输出域0 ~ 2^128，作为一个环。0~2^128均匀分布在环上，即2^128的下一个位置是0，0的下一个位置是1。 假设有三台机器:M1，M2，M3，上面有自己的mac地址或其它专有信息。将这个信息生成一个hash值，认为该hash值代表这三台机器。 此时，这个环上有了3台机器。 在环上插值时，假设值为A。将A经过哈希得到的哈希值打在环上，哈希值在环上顺时针遇到的第一个机器便是它应该存放的地方。 此时，每个机器负责环上的某段数据。 加机器。原来是m1，m2，m3。在环上加入m4（m1，m2，m4，m3），此时不需要将所有的数据都迁移。我们将原本属于m3的部分数据，让它属于m4就可以了。 m4机器删除，此时将m4上的数据顺时针给到下一个机器m3上，就可以了。如何顺时针找机器 机器是环装结构，假设机器的哈希值分别是1，5，10。在前端，插入一个值，它的哈希值是6。那么它就可以在1-5-10中找到它的位置。 上面做法的问题 利用哈希函数的离散性，哈希在分割环时，在数据量很大的情况下，才会出现均摊。数据量小的时候，均分并不明显。 比如：有一间屋子，打翻一瓶香水，可以充满屋子。但是几个颗粒，就不能。哈希是一个类似的过程。 即便3台机器负载均衡了，在加入第四台机器时，一定会出现负载不均。 虚拟节点技术 真是机器是m1，m2，m3。但是，不使用m1，m2，m3去计算哈希值。分配虚拟路由节点，m1被分配：v1-1，v1-2，一直到v1-1000。 环上不再放3台机器计算的哈希值，而是放虚拟节点的哈希值。此时m1，m2，m3就可以通过虚拟节点均分整个环了。 加机器m4，将m4的虚拟节点的哈希值放在环上，虚拟节点会向m1，m2，m3要数据。这样数据就均摊在m1，m2，m3，m4上了。 即通过虚拟节点，尽可能的将数据均摊。 哈希表 哈希表：有一个数组[0，1，3，4，5]，数组中的5个数代表5个数据域。每个数据域连着一个链表，链表上有数据。 将一个(key，value)加入一个hashmap。value不用管，key经过hash以后会打到对应数据域上。例如（a, 31），a 经过哈希以后，再模上6。打到了数据域4上，4后面的链表就加一个节点（a, 31）。 这么一个结构。当我有大量数据打到这个[1，2，3，4，5]上。其每个数据域后面的链表因为哈希一致性的性质，链表长度能够均匀增长（数据均摊）。 hash表要扩容，增长到12，每个链表数据减半。 新结构：每个数据域后面不跟链表，而跟一个红黑树，相同哈希值根据红黑树区分不同。扩容行为更新频率低，因红黑树的有序结构。 使用哈希表的增删改查的时间复杂度都是O(1)。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--栈与队列]]></title>
    <url>%2F2018%2F01%2F09%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[问题1实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈最小元素的操作。要求：1.pop、push、getMin操作的时间复杂度都是O(1)。2.设计的栈类型可以使用现成的栈结构。 设计1 准备两个栈，data栈和help栈。 data栈，压入3。help栈同步压入3。 data栈，压入4。help栈同步压入3。 data栈，压入5。help栈同步压入3。 data栈，压入2。help栈同步压入2。 data栈取2，help栈弹出2。 data栈取5，help栈弹出3。 即help栈在data栈每次压入新值时，help栈同步压入当前最小值。data栈每次弹出值时，help栈同步弹出栈顶。help栈的栈顶保持是data栈中的最小值。 设计2 准备两个栈，data栈和help栈。 data栈，压入3。help栈同步压入3。 data栈，压入3。help栈同步压入3。 data栈，压入4。help栈不压。 即data栈当前压入的数，小于等于help栈栈顶时，才压入help栈。 弹出时，data栈当前弹出的数小于等于help栈栈顶时，才弹出。 问题 2怎么用数组结构实现固定大小的栈？ 设计 数组固定长度为5。size一开始是0。 在数组的size位置加一个数后，size + 1。 在数组的size位置取一个数后，size - 1。 size爆了，报错。 问题 3怎么用数组实现固定大小的队列？ 设计 有一个start变量，end变量。 一开始start和end指向同一个位置。 增加时，加一个，end指向加进来的数。后续增加的也是如此。 弹出时，减少一个，start向下移动一个。 start是去追赶end的。 start和end谁触底，回到最初位置。 size用于约束start和end，超了或者减少到底了都报错。 用size去约束start和end的行为。 问题4如何用栈结构实现队列结构？ 设计 设计一个data栈，help栈。 data栈是1，2，3，4，5。 help栈是data栈的倒置，5，4，3，2，1。 data栈进，help栈出。便构成了队列。弹出规则 如果help栈中不为空，data栈一定不要向help栈中放置数据。 data栈向help栈放元素，一定要将data栈自己所有的元素倒完。 问题5 如何用两个队列实现栈？ （一个图的深度遍历，怎么用队列实现？其实用队列做成栈，然后用栈做深度遍历即可）。 设计 例如有队列A中有 1，2，3，4，5 弹出时，让2，3，4，5进入另一个队列B，队列A仅剩数字1，弹出1。 现在队列B有 2，3，4，5，队列A空。 队列B 3，4，5进入队列A。队列B中剩下2，弹出。 这就是栈。 这里有个小技巧是swap了A和B引用指向的对象。 问题6实现一种狗猫队列的结构，要求如下:用户可以调用add方法将cat类或dog类的实例放入队列中;用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出;用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出;用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出;用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例;用户可以调用isDogEmpty方法，检查队列中是否有dog类的实例;用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。 简单设计 狗进狗队列，猫进猫队列 狗的定义改一下，加一个index属性，标注它是第几个进的。猫同理。 整体弹最早的狗或者猫，就比较他们的position。 关键在于，我们不能修改上级的数据结构。 所以，我们定义自己进队列的类。PetEnterQueue，这个类将宠物类封装进去，并增加一个计数项 count。不管进狗还是进猫，count都 ++ 。 因此，我们的猫狗队列不再封装简单的猫狗对象，而且宠物队列对象。 这样我们就可以判断猫或者狗在一起弹的时候谁更早一点。 不正确的设计 用hashmap记录猫狗进队列，用key,value来做。 但是同一只宠物，进队列怎么办？ 比如先给第一只猫喂水，再给第二只喂水。然后再给第一只喂水。用map，下一次第一只猫进来的时候，原来的key就丢掉了。 而上面的方法封装的是自己实现的一个新对象，可以区分同一个宠物多次进队列的情况。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--基数排序（待续）]]></title>
    <url>%2F2018%2F01%2F04%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序 假设有 5，23，31， 15， 100。 按照最高位补0，005，023，031，015，100。 准备9个桶。0，1，2，3，4，5，6，7，8，9。 按照个位，放入桶。 0桶：100。 1桶：031。 3桶：023。 5桶：015，005。（先进先出） 从0号桶依次倒出：100，031，023，005，015。 按十位进桶，再倒出。 按百位进桶，再倒出。 排序完成。 先排低位再排高位，入桶出桶就排完了。 流程改进例如：以374十位上的7为参照，小于等于它的有17个。那么它在十位上的排序为第17位。 关键代码]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--BFPRT]]></title>
    <url>%2F2018%2F01%2F02%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-BFPRT%2F</url>
    <content type="text"><![CDATA[BFPRT在数组中，求第k小的数？或者求第k大的数。 各个方法优劣分析 如果对数组中的数排序求解，时间复杂度是O(N * logN)。而我们希望的时间复杂度是O(N)。 原始流程：利用快排partition的过程，比p小的放左边，和p相等的放中间，比p大的放右边。如果相等的部分命中k，那么得出答案。如果未命中，那么看k是在P的部分。这个过程平均下来的时间复杂度是O(N)。 BFPRT：快排的划分值P是随机选的，而BFPRT的算法划分值的选择并不是随机的。 BFPRT如何选择划分值的 相邻的5个数是一组，后面不足5个数的单独一组。 O(1)。 在一个组的内部，把数排序，排好。组内排序，组与组之间不排序。因为一个组5个数排序，时间复杂度O(1)。有 N / 5 组，所以这个过程 O(1) * N / 5。即时间复杂度是O(N)。 因为一个组中，数是有序的。我们可以很方便的得到组内的上中位数。（奇数：无上中位数。偶数：例如1234，上中位数是2，下中位数是3）。所以，组内的中位数是第3个数。将每个组的上中位数拿出来组成一个数组newArr，这个数组的大小是N / 5，它的上中位数是第 N / 10 小的数。我们的题要求，求第k小的数，用函数表达为f(arr, k)。自己调用自己求newArr的上中位数，即f(newArr, N / 10)，可以求出newArr的第 N / 10小的数。 总结一下，分组后拿出组内的上中位数组成一个新的数组，再求新数组的上中位数。 将新数组中的上中位数拿去做划分值，做partion过程，看=P的范围是否命中K。没命中，继续递归。 为什么时间复杂度是O(N) 随机划分值，做partion的过程，我们不能确定P部分递归的大小。这个规模你是无法保证。 在新数组中，第 N / 10 位置的数，假设为M。组内中位数组成的新数组的中位数是第 N / 10 位置的数，即至少有 N / 10 个数比M小。 而在原来的每5个位一组的小数组中。某个小数组的中位数比第 N / 10位置上的数小，这个小数组的中位数下，还有2个数也比第 N / 10 位置上的数小。即最少有 3N / 10 个数比M要小。即最多有 7N/10 个数比M大。 对于M来说，最多有 7N/10 个数比它大。 M又是作为partion过程的划分值的，即我们&gt;P过程的递归规模是可以确定的。 即我们可以确定的淘汰掉一定规模的数，因此我们的递归规模收敛到O(N)。 第一步：分组，每5个位一组，O(1)。第二步：组内排序，O（N）。第三步：自己调用自己。原过程递归是T(N)规模，自己调用自己是T（N / 5）的规模，因为新数组的规模是原来数组的1 / 5。第四步：partion，O（N）。第五步：只走一侧递归，最大递归规模是T（7N / 10）。所以整个复杂度是：O(1) + O（N）+ T（N / 5）+ O（N）+ T（7N / 10），这个式子可以收敛到O(N)。 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142function getMinKthByBFPRT (arr, K) &#123; let copyArr = copyArray(arr) // 主流程 return select(copyArr, 0, copyArr.length - 1, K - 1)&#125;// 给定一个数组，给定一个范围[begin, end]，求第i小的数function select (arr, begin, end, i) &#123; if (begin === end) &#123; return arr[begin] &#125; // 求划分值M int pivot = medianOfMedians(arr, begin, end) // 利用求出的划分值去Partition，返回 =M 的区域。 let pivotRange = partition(arr, begin, end, pivot) // 看我们第i小的数是否命中了pivotRange这个区域 if (i &gt;= pivotRange[0] &amp;&amp; i&lt;= pivotRange[1]) &#123; return arr[i] // 如果没命中 = M 区域，那么或者走左边，或者走右边 &#125; else if (i &lt; pivotRange[0]) &#123; return select(arr, beigin, pivotRange[0] - 1, i) &#125; else &#123; return select(arr, pivotRange[1] + 1, end, i) &#125;&#125;// 在一个数组中求划分值Mfunction medianOfMedians (arr, begin, end) &#123; // 在[begin, end]的范围内，有多少个数 let num = end - begin + 1 // 是否有剩余数构成一组 let offset = num % 5 === 0 ? 0 : 1 // 数组mArr是各个组的中位数组成的新数组 let mArr = new Array(num/5 + offset) // for循环每5个数为一组，并排序。从每组中取中位数放入新数组中。 for (int i = 0; i &lt; mArr.length; i++) &#123; let beginI = begin + i * 5 let endI = beginI + 4 mArr[i] = getMedian(arr, beginI, Math.min(end, endI)) &#125; // 新数组递归的调用select求数组自己的上中位数 return select(mArr, 0, mArr.length - 1, mArr.length / 2)&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--Manacher]]></title>
    <url>%2F2017%2F12%2F27%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-Manacher%2F</url>
    <content type="text"><![CDATA[Manacher在一个字符串里，怎么找到最长的回文子串，求它的长度？ 易混淆概念 回文：字符串的正序和逆序是一样的。 子串和子数组是连续的，子序列可不连续。例如abc的子串是ab，ac。子序列是ac。 最长的回文子串，例如abc12321de的最长回文子串是12321。 笨办法简述 从某一个位置，依次向两边扩。这样只能找到奇回文。即长度为奇数的回文。例如：abc12321de，你从3开始向两边扩，可以找到12321这样的奇回文。但是abc1221de，你是找不到1221这样的偶回文的。 笨办法（特殊字符处理） a12321b，处理为-a-1-2-3-2-1-b-。 a1221b，处理为-a-1-2-2-1-b-。 这样，我们以某一位置向两边扩，都可以找到回文。且不影响结果。 相当于对于偶回文，我们为它加了一个轴，让它有一个向两边扩的出发点。 我们增加的特殊字符，永远是和特殊字符比，不会和原字符串中的有效字符去比较。 笨办法时间复杂度 时间复杂度是O(n^2) 例如某个处理过的字符串长n，第一个位置扩0次，第二个扩2次。。。 扩的总次数 1 + 2 + 3 + … + n/2 + (n/2 - 1) + … + 1 。 所以总的时间复杂度是O(n^2) 回文半径从某个位置出发，它能够扩多远。 最右回文边界R “)”假设为最右回文边界， )-1-2-1-。一开始没扩，停留在最右边。 在0位置向两边扩，扩不动了。因为左边没东西。那么最右回文半径就来到了0位置。 在1位置向两边扩，扩了一个位置。即-1-。此时，最右回文边界来到了位置2。 在3位置向两边扩，即-1-2-1-。此时，最右回文边界来到了位置5，即字符串的最右边。 即最右回文边界表示，当前我扩到了哪个位置，忽略是哪个位置扩的，只管扩到的最右的位置。 C当我取得最右回文边界时，中心在哪，就是C。只有当R变化时，C才会变化。C和R一样，只记录最早的。当R更新时，即向右前进了，我们的C才会相应的更新。 arr字符串从首位置，从左往右依次扩。每个位置的回文半径我们都记在数组arr里。 ###做法 指针在字符串的某个字符上时，回文右边界未包括该字符，继续扩。例如：在一次扩的过程中，）8，回文右边界在8的左边，不包括8。 指针在字符串上的 I 位置，回文右边界 R 在 I 的右边，即包括 I 。那么 C 在 I 的左边是一定的。此时，我们也可以求得，以 C 为中心，R为右边界的对称的左边界L。I 作以C为参照物的对称点I’。 此时我们的拓扑结构是L I’ C I R。L和R之间是回文，且此时我们的I’点的回文半径，我们之前是求出来过的。 情况一：i’的回文半径在[L, R]内，此时I的回文半径与i’的回文半径相同。 情况二：i’的回文半径有部分在[L,R]之外，此时I的回文半径是I到R这一部分[I, R]，长度等于[L, I’]。 情况三：i’的回文半径正好在L上，此时无法确定I的回文半径是否能超过R。只能去扩，去试。 情况总结 情况一：I在R的右边（[L,R]范围外），无法加速，扩。 情况二：I在R的内部，I’的回文半径在L内，不需要扩，I的回文半径与I‘的回文半径相等。 情况三：I在R的内部，I’的回文半径有一部分在[L，R]内，不需要扩，I的回文半径是I到R。 情况四：I在R的内部，I’的回文半径在L上（压线），扩，但是I到R的部分一定是回文，这一部分就不需要扩了。从R位置扩就好。 时间复杂度估计 情况二和情况三，因为I的回文半径是确定的，所以时间复杂度是O(1)。 情况一和情况四，如果能扩，R一定会向右走。R只增大不减小，R最多向右边移动多少呢？N。所以时间复杂度是O(N) 所以整个算法的时间复杂度是O(N)。 代码1234567891011121314151617181920212223242526272829303132333435363738function maxLcpsLength (str) &#123; if (!str || str.length === 0) &#123; return 0 &#125; // 处理成manacher字符串 let charArr = manacherString(str) let C = -1 // 最右回文边界 let R = -1 let max = Number.MIN_SAFE_INTEGER for (let i = 0; i != charArr.length ; i++) &#123; // 情况二和情况三 I 的回文半径已知，实际上是不需要扩的，但是code中，我们给出 I 的回文半径，让I在这个基础上扩一扩试试。 // 即我们求出 I 位置的回文半径起码是多远.然后用while循环在这个基础上扩 // pArr[2 * C - i]，对称点的回文半径 // Math.min(pArr[2 * C - i], R - i)，整合了i&apos;在R内的情况，谁短谁是最起码的回文半径 pArr[i] = R &gt; i ? Math.min(pArr[2 * C - i], R - i) ： 1 // 条件 ：i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1 判断在 I 位置扩的时候，新的回文左边界和右边界是否数组越界 while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; // while循环，针对情况二和情况三是不需要扩的。在第一次循环就会不满足条件，以至于break // 针对情况一，情况四，都在最起码的回文范围上，继续暴力扩 // 因此，针对情况一二三四统一写成一下代码 // 条件：charArr[i + pArr[i]] === charArr[i - pArr[i]，左边界等于右边界，回文半径增加。不等 break if (charArr[i + pArr[i]] === charArr[i - pArr[i]]) &#123; pArr[i]++ &#125; else &#123; break &#125; &#125; // 如果最右回文边界被我推得更远了，记录一个新的R和C if (i + pArr[i] &gt; R) &#123; R = i + pArr[i] C = i &#125; // 每次记录最大回文半径 max = Math.max(max, pArr[i]) &#125; return max - 1&#125; 扩展一个字符串，只能在后面增加字符，让它变成回文串。还要让增加的字符最少。如何做？ 这道题变为，必须包含最后一个字符的情况下，最长回文子串的长度是多少？ 举个例子：原字符串abc12321，必须包含最后一个字符的情况下，最长回文子串是12321，前面不是的部分，逆序添加到末尾。即abc12321cba。添加的cba是最短的。 manacher算法逐渐向右扩展的时候，第一次R到达结尾的时候，停止。我们知道R在哪，C在哪，因此我们就知道L在哪。我们把L之前的子串，逆序放到末尾。得出结果。即改写了manacher算法。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（二）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（二）如何判断一棵树，它子树的某一个结构，是另外一个树的结构。例如。树1：1234567 与树2：367。树1的子树367与树2一样。 常规做法暴力尝试每一个开头，并以第二棵树的方式去遍历。如果一个开头能以第二棵树的方式遍历出来，即每个支点的值一样。 二叉树序列化（作为字符串）每个值后跟-，空值视作#并也跟-。例如123，序列化后就是1-2-#-#-3-#-#-。 二叉树反序列化 1-2-#-#-3-#-#-。很容易可以看出来树是123。 内存中的树，序列化后持久化存在硬盘中。再从硬盘中反序列化到内存中。 不用特殊符号表示空和一个数的结尾，反序列化就会乱。比如111，你根本不知道是啥结构。 序列化的信息既代表了这个树的值信息，也代表了这个树种的结构信息。 本题解法将A树序列化为strA，B树序列化为strB。用KMP，strA中包含strB，那么A这棵树一定包含B这棵树。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（一）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（一）有一个字符串，经过处理，包含两个自己，且开始的位置不一样。怎么添加字符最短？例如：原字符串是aaa，处理过后是aaaa，包含两个aaa。 实质元字符串处理完成后，最大前缀和最大后缀是贴在一起的，例如aaaaa的最大前缀是aaaa不包含最后一个a，最大后缀是aaaa不包含首位置的a。即：这个题目就变成了，原字符串的最大前缀和最大后缀重合多少，不重合的部分添在原字符串的后面即可。例如：abcabc-，-位置的最大前缀和最大后缀的部分匹配值是3。只需要在原字符串后添加2位置后的字符串即可。即在abcabc后再添加一个abc，]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--KMP]]></title>
    <url>%2F2017%2F12%2F13%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%2F</url>
    <content type="text"><![CDATA[KMP 复杂度是O(N) 有str1，str2两个字符串，求st1里面是否包含str2?且返回str2的位置。例如：str1是abc123def，str2是123，如果包含 f1(str1, str2 ) = 3。如果str1 不包含 str2，那么 f1(str1, str2) = -1 笨办法 str1 长度为N，str2 长度为M 从 str1 的0位置开头，配str2 从 str2 的1位置开头，配str2 最差的情况尝试str1每一个位置为开头，且每一轮都配M次，这个时间复杂度为O(N * M) 前缀与后缀 我要建立基于 str2 字符串的一组信息。叫做：最大前缀和最大后缀的部分匹配值。 前缀不能到最后一个字符，后缀也不能到第一个字符。 例如：str2是abcabcd。我们生产一个next数组，数组长度和str2的长度一样。next数组的值是什么？ 对于str2的 a，a的前面没有字符串，那么对应的next数组上的值是 - 1。 对于str2的 b，b的前缀不能到第一个字符，那么对应的next数组上的值是 0。 即对于str2 的 0位置，1位置。next数组上的值时-1 和 0。 以上是 0，1位置在next数组中的对应值，对于普遍位置来说，引入最大前缀和最大后缀的部分匹配值。 “最大前缀与最大后缀部分匹配值”的概念str2 是 abcabc | d 对于d，以1为单位。前缀是a，后缀是c。不匹配。 对于d，以2为单位。前缀是ab，后缀是bc。不匹配。 对于d，以3为单位。前缀是abc，后缀是abc。匹配。 对于d，以4为单位。前缀是abca，后缀是cabc。不匹配。 对于d，以5为单位。前缀是abcab，后缀是bcabc。不匹配。那么最大前缀和最大后缀是5时，部分匹配值是3，d对应的next数组中的值为 3。这是next数组中数的意义，是最大前缀与最大后缀部分匹配值。 next数组匹配方法 对于str2上的每一个字符，我们根据next数组，有了其最大前缀和最大后缀部分匹配值。 即最大前缀和最大后缀中存在长度为k的相同前缀和后缀,这个值就存在next数组中，表示Str2每个位置的k值。 对于字符串转化的数组P的q位置的匹配值：next[q] = k 。表示P[q]之前的子串中，存在长度为k的相同前缀和后缀 举例：对于str1：1234abc1234k 与 str2：1234abc1234a。根据next数组，其最大前缀与最大后缀匹配。第一次配型时，从1开始配，str1与str2比较到a这个位置时，配型失败。那么第二次配型就没必要从2开始配了。从第二个1234开始配，看k和a是否相等即可。 这样就加速了 笨方法配型。 next数组加速配型的实质对于str1：1234abc1234k 与 str2：1234abc1234a。我们抛弃了k之前的字符串，将str2往后推，让1234k与1234a比较。因为1234相等，所以看k和a即可。 next数组加速配型的原因反证法：对于str1：1234abc1234k 与 str2：1234abc1234a。如果k之前的字符串中，一个随机的位置开始，能和str2匹配上。那么，我们之前求得的next数组的最大前缀和最大后缀匹配就不成立了。因为会有一个更大的最大前缀和最大后缀匹配。 next数组加速配型的时间复杂度对于str1：…M 与 str2：…。有两个相斥的行为，以str1是否移动为分界。一是：str1是一个一个往后滑，最多滑str1的长度，是O(N)。二是：str2在str1不滑动时，滑到最大前缀和最大后缀匹配位置，最多滑str1的长度，是O(N)。整体2O(N)，即O(N)。 next数组加速配型代码过程12345678910111213141516171819202122232425262728293031function getIndexOf (s, m) &#123; if (s === null || m === null || m.length &lt; 1 || s.length &lt; m.length) &#123; return -1 &#125; // 构造字符串数组 let str1 = s.split(&apos;&apos;) let str2 = m.split(&apos;&apos;) // 两个指针分别用于str1和str2的字符串比较 let i1 = 0 let i2 = 0 // 得到str2的next数组 let next = getNextArray(str2) // 利用next数组加速比较过程 while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123; // 比较 if (str1[i1] === str2[i2]) &#123; // 该位置上字符相等，两个指针均向后移动 i1++ i2++ &#125; else if (next[i2] === -1) &#123; // next数组中 -1 表示 i2指针指向了字符串的首位，且此时i1指向的字符和i2指向的字符不等，i1指针向后推 i1++ &#125; else &#123; //此时i1指向的字符和i2指向的字符不等。再次比较时，i2指到next数组中的最大前缀与最大后缀匹配的位置，再与i1比较。 //即next数组帮助指针忽略了最大前缀个位置，直接比较最大前缀的下一位。这样就不需要再从str2的零位置与str1的i1位置一个一个苦苦比较了。 i2 = next[i2] &#125; &#125; // 当i2指向str2的末尾时，即i2到了边界，我们已经在str1上配出来一个str2了，比较完成。如果循环结束还没指向末尾，则str1里找不到str2的匹配，返回一个-1。 return i2 === str2.length ? i1 - i2 : -1&#125; next数组求解代码过程 我们要知道，next数组上存的值，最大前缀和最大后缀的部分匹配值。 我想求str2上i位置的next数组值，那么我们i - 1位置上的next数组的值一定是已经求出来的。 设 i - 1 为 b ，设 i 为a。 b 的indexPreB（最大前缀部分匹配值的位置） + 1 和 b的 indexSuffixB（最大后缀部分匹配值的位置） + 1 就是 a 的最大前缀部分匹配值的位置和 a 的最大后缀部分匹配值的位置。不过，需要判断一下，也有可能不是。 如果是，那么indexB + 1 位置的值与 b 位置的值相等。 如果不是，则不相等。设 b 的indexPreB（最大前缀位置） + 1位置是 c 。 求 c 的next数组值，即想要知道他的最大前缀和最大后缀匹配值(长度为k的相同前缀与后缀)。看 c 的最大前缀部分匹配值的位置的下一个位置与 c 本身是否相等。相等，则就求出了 a 的next数组值。 不相等，重复上过程。 跳到 - 1了，那么next数组的值便是0了。123456789101112131415161718192021222324252627function getNextArray (str2) &#123; if (str2.length === 1) &#123; return [-1] &#125; let next = [] next[0] = -1 next[1] = 0 let i = 2 // cn是上述过程中用于比较的值的指针，指针指向最大前缀位置的下一个位置。 // 第一次比较时，cn表示next数组中的值是0，即1位置不存在长度为k的前后缀。 let cn = 0 while (i &lt; str2.length) &#123; // 如果我 i - 1 位置的字符，与你跳到的位置相等，那么next数组的值便是 i - 1 位置next数组的值 + 1。（） if (str2[i - 1] === str2[cn]) &#123; next[i++] = ++cn &#125;else if(cn &gt; 0) &#123; //没配上，cn向前跳 cn = next[cn] &#125;else &#123; //cn跳到0位置了，还没配出最大前缀和最大后缀 next[i++] = 0 &#125; &#125; return next&#125; next数组求解过程的时间复杂度 假设str2的长度是m 设一个指针为i，一个是i - cn i 最大范围是m，i - cn 最大值也是m（cn可以跳到0，表示无最大前后缀） next[i++] = ++cn，i会上升，i - cn 不变 cn = next[cn]，i不变, i - cn 上升 next[i++] = 0, i上升， i - cn 上升 while过程中，要么i上升，要么i -cn上升，要么都上升，所以while过程执行的次数不会大于 2*M 所以时间复杂度为O(M) 时间复杂度 主过程： i 动，i 最多到N i不动，str2右移动，也最多str1长度N这个范围 即，我们常数操作绑定在了N这个变量上。 next数组过程：i 和 i - cn 去衡量这个常数操作过程的时间复杂度 所以总的时间复杂度是O(N)]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--桶排序扩展题目]]></title>
    <url>%2F2017%2F12%2F08%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[桶排序扩展题目一个无序数组，如果有序之后，求相邻数组之间的最大差值？要求：不能使用O(n^2)的排序。 方法概述 有 N 个数，就准备 N + 1 个桶。 求出最大值和最小值的差值：max - min 。 将这个差值在N+1个桶上均分，每个桶放自己范围的数。这个范围记为range。例如有1，2，3。差值是 2/3，则第一个桶放 [1, 1+ 2/3] 大小的数。 最小值放在最左边的桶，最大值放在最右边的桶里。因此一定有一个桶是空桶。 空桶的左边找一个最近的非空桶，右边也找一个。 空桶左边的非空桶中最大的数，和空桶右边的非空桶中最小的数，是相邻的。 空桶左边的非空桶中最大的数 - 空桶右边的非空桶中最小的数 一定大于我们上面记下的 range ，因为空桶本身也有一个range。 我们这么做的目的：相邻数可能来自桶内部，也可能来自桶与桶之间。但，因为有这么一个空桶，所以我们可以证明：我们可以忽略一个桶内的相邻数，因为桶内部的相邻数的差是 &lt;= range 的。我只用关心两个桶之间的差值。 因此，我们的桶没必要搜集所有的数。桶只需要搜集，进入这个桶的最大值和最小值。 问题就变成了：这个数组中的数进桶，更新桶的最大值和最小值。桶进过数是true,没进过是false. 我们的答案一定来自于两个桶之间的差值，非空桶只是为了证明，答案一定不来自于桶的内部。相邻的非空，所有的max - min，算一遍。求最大差值。 整个过程严格 O(N)。 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function maxGap (nums) &#123; let len = nums.length let min = Number.MAX_SAFE_INTEGER let max = Number.MIN_SAFE_INTEGER // 找数组中的最大值和最小值 for (let i = 0; i &lt; len; i++) &#123; min = Math.min(min, nums[i]) max = Math.max(max, nums[i]) &#125; // 如果min和max相等，相当于数组中都是一个数 if (min === max) &#123; return 0 &#125; // 做三个数组。一个是统计每个桶是否为空，一个是统计每个桶的最大值，一个是统计每个桶的最小值 // 即三个数组，表示3个维度的事情。 let hasNum = [] let maxx = [] let mins = [] // 几号桶？ let bid = 0 // 这个for循环用于建立所有的桶信息 for (int i = 0; i &lt; len; i++) &#123; // 确定num[i]进的是几号桶 bid = bucket(nums[i], len, min, max); // 确定bid号桶的最小值 mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i]； // 确定bid号桶的最大值 maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i]); // 确定桶是有值的 hasNum[bid] = true; &#125; let res = 0 let lastMax = maxs[0] let i = 1 for (; i &lt;= len; i++) &#123; if (hasNum[i]) &#123; // 每一个桶的最小值都去找上一个桶的最大值 res = Math.max(res, mins[i] - lastMax); lastMax = maxs[i] &#125; &#125; // 这就是相邻最大差值 return res&#125;// 计算数字num进几号桶function bucket (num, len, min, max) &#123; return ( ((num - min) * len / (max - min)) | 0 )&#125; 小贴士基础类型对稳定性不看重，所以用不稳定但是快的。而自己定义的类，是看重稳定的(mergesort)。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--堆排序]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆 时间复杂度是O(N * logN)，额外空间复杂度O(1)，实现不能做到稳定性 关键步骤：heapInsert，heapify，堆的扩大和缩小操作 注意：1. 堆排序中，建立堆的操作O(N)。2. 堆排序的核心数据结构：堆，也可以说是优先级队列。 描述 堆是一棵完全二叉树结构。什么是完全二叉树？即结构是永远是在成为满二叉树的路上或已经成为完全二叉树了。 数组下标与完全二叉树是有逻辑对应的： 在数组上，i 的左孩子的下标：2 * i + 1 i 的右孩子的下标是：2*i + 2 i 的父节点下标是：( i - 1) / 2 即在数组上我们可以找到一个节点的父节点 以及 左右孩子。 大根堆 概念：1. 大根堆一定是完全二叉树结构。2. 在大根堆中，任何一个节点，都是它下面的整棵树中（包括它自己的那颗树，即以它为头的树），最大的节点。 堆排首先要将一个数组变成大根堆做法是：1. 对每一个数，看它是否比它的父节点大。大就与父节点交换位置。2. 交换位置后，再看它是否比它的父节点大，大就再交换位置。3. 直到它不再比它的父节点大。 这样一个大的数再加入二叉树时，会把比它小的父干掉。如此调出来的，一定是一个大根堆。 关键代码 – heapInsert（调大根堆的过程）这里解释我们排序思想的关键部分，详细代码请见我的GitHub12345678910111213// 数组一上来，我们考察它的每一个位置，将这个数组调成一个大根堆，这个方式简称为heapInsert// 数组上的一个元素，往上看，它比它的父大，就换。换完再往上看，重复上过程。// 如此heapInsert，调成大根堆function heapInsert(arr, index) &#123; // 这里 “arr[index] &gt; arr[(index - 1) / 2”考虑到了两个关系 // 1.我是否比我的父要大 // 2.我到了二叉树的定点，即数组的 0 位置。 （负数 / 2 = 0），我也不满足循环，停止。 while ( arr[index] &gt; arr[(index - 1) / 2] ) &#123; swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 &#125;&#125; 关键代码 – heapInsert 的时间复杂度 完全二叉树如果有 i 个节点，它的高度是 log(2， i)。例如 7 个节点， 3层。 1.当1个节点时，heapInsert的代价是log1。2.当2个节点时，heapInsert的代价是log1 + log23.当n个节点时，heapInsert的代价是 log1 + log2 + log3 + … + logN ，收敛在O(N)4.即建大根堆的过程时间复杂度是 O(N) 在已知大根堆的基础上排序 1.在大根堆上，已知堆顶元素是最大值。将这个值放在最后的位置上。2.将最后位置上的值放在头部。3.此时，最后一个位置上的数就排好了。4.拿掉此时，最后一个位置上的数。 如何 拿掉此时，最后一个位置上的数？用size表示堆的边界，左孩子或者右孩子大于size，即它的左孩子和右孩子不在堆上。因为 我们将 size - 1 ，表示拿掉了此时，最后一个位置上的数。但是，此时 size - 1 大小的堆，不能保证它是大根堆了！ 因为我们上述1，2，3过程破坏了大根堆。所以我们的堆顶要下沉！它与它的左孩子和右孩子比较，它与最大的孩子比较，小于最大的孩子，就下沉。然后，它与此时它的左孩子和右孩子比较，重复上过程。成为大根堆。 再次进行1，2，3过程。每一轮成为大根堆后，都将堆顶和堆的最后一个元素交换位置。然后将堆的大小减少 1。调整头部，看它沉在哪。 反复过程，直到整个堆的size 减完，整个数组有序了。 在大根堆的基础上排序–heapify 代码12345678910111213141516171819202122232425// 从index位置开始往下沉，堆的大小是size// heapify可以调节任何位置，从任何位置往下沉function heapify (arr, index, size) &#123; // 先求左孩子下标 let left = index * 2 + 1 // 循环条件：左孩子的下标是否越界(左孩子越界则右孩子一定越界) while (left &lt; size) &#123; // 如果我的左右两个孩子都有，那么我选择两个孩子中，大的一个作为我lagest变量的值。 let lagest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left // 较大的index 孩子的值，是否比我的值要大，大则lagest的值是较大孩子的Index；否则，lagest的值是我自己的Index lagest = arr[lagest] &gt; arr[index] ? lagest : index // 如果这个最大值的 lagest 就是我，又因为我在大根堆中，所以我比以我为头的树中的所有的值都大，所以过程停止，不动。 if (largest === index) &#123; break &#125; // 下沉，与较大的那个孩子交换 swap(arr, largest, index) // 我来到了孩子的位置 index = largest // 此时，我的左孩子又向下的一层 left = index * 2 + 1 &#125;&#125; 往返以上代码描述的过程！ 总的代码流程1234567891011121314// for循环将每个节点去建大根堆for (let i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i)&#125;// 将0位置（堆顶位置）换到我的最后一个位置let size = arr.lengthswap(arr, 0, --size)// 此时不是大根堆了，我们就去heapifywhile(size &gt; 0) &#123; heapify(arr, 0, size) // heapify后又是大根堆了，我们再将堆顶和末位交换位置 swap(arr, o, --size)&#125;// 一直往复直到整个堆减完（size = 0），堆排序结束 关键点 堆排序引入了堆这种结构 堆排序的两个过程：建立堆和任何一个位置下沉调整的过程 size– ，保证不越界 时间复杂度因为heapInsert的时间复杂度是O(N)；而heapify是一个下沉的过程，其下沉的高度最多是logN级别的；所以说时间复杂度是O(N * logN) 额外空间复杂度–O(1) 一个数 i 是用公式找到左孩子和右孩子 快排中，断点的位置每一次都是用一个变量记录的，这样我们才能知道左右递归的范围。这样也导致，快排的额外空间省不掉的。 可以看出来，堆排所有需要排列的位置都是公式告诉我们的。 但是，堆排的常数项大，我们的指标是O(N * logN)，但是实际运行中，快排的常数项十分小。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序的扩展]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E5%B0%8F%E7%9B%92%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[归并排序的扩展（小盒问题）什么是小盒问题？[3, 5, 1, 4, 6]。3的左边比3小的是0；5的左边比5小的是3；1的左边比1小的是0；4的左边比4小的是3；6的左边比6小的是3、5、1、4。那么小盒为0 + 3 + 0 + 3 + （3 + 5 + 1 + 4） = 20。即每个数的左边比它本身小的数的值累加起来。 笨方法看每个数左边有哪些比它小的数，累加起来。是一个时间复杂度为O(n ^ 2) 的问题。 改写归并排序解小盒问题 – 举个例子： 例子1：[3,4,5,2,6,7] =&gt; 3 | 4 | 5 | 2 | 6 | 73 | 4 merge =&gt; 产生小盒 334 | 5 merge =&gt; 产生小盒 4 5 由例子1 引出 例子2：3 4 5 6 | 7 8 9 10 ，两组数 merge 两组数merge，因为3 比 7 小，所以3 一定比4个数小！因此有一个小盒是 4 * 3 此时放入help[]数组中一个3 即整个问题变成了看看在merge的过程中，看左边与右边比较时，右边有多少个比左边的这个数大。就有多少个小盒，就可求值。 上述做法正确的原因？在每一次merge的时候，两个数字比较之后会放在同一区域内，下一次不会再相遇。 关键代码123456789101112131415161718192021222324252627282930function mergeSort (arr, l, r) &#123; if (l === r) &#123; return 0 &#125; let mid = l + (r - l) &gt;&gt; 1 //左边的小盒 + 右边的小盒 + 整个的小盒 return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r)&#125;function merge(arr, l, mid ,r) &#123; let help = [] let i = 0 let p1 = l let p2 = m + 1 let res = 0 while(p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //如果右边的比左边的大，那有右边有多少个比左边的大，就有多少个小盒 res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] &#125; while(p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; while(p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125;&#125; 扩展2：逆序对问题 什么是逆序对问题？在一个数组中，存在多少对，前面的数比后面的数大？例如：[4, 3, 5, 7, 0]，4和3，4和0，3和0，5和0，7和0是一对。 所以逆序对问题是：右边有多少个数比自己小？本质和小盒问题是一样的。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序时间复杂度O(N * logN)，额外空间复杂度O(N)，实现可以做到稳定性。 ###例子简而言之，是将有序小数组，merge成大的有序数组的过程。举个例子，数组[1,3,2,4] 第一步分为[1, 3]和[2, 4] 第二步分为1，3，4，2 第三步有序合并 [1, 3] 和 [2, 4] 第四步再次有序合并[1, 2, 3, 4] 最终数组有序 归并排序过程及代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function mergeSort (arr, l, r) &#123; //递归跳出条件，只剩下一个数，即l = r if (l === r) &#123; return &#125; //找中间位置做划分点 let mid = l + ((r - l ) &gt;&gt; 1) //递归在不满足条件时，会中断跳出 //对左半边部分做递归，即递归的左子过程 mergeSort(arr, l, mid) //对右半边部分做递归，即递归的又子过程 mergeSort(arr, mid + 1, r) //merge过程 //merge过程同上述例子，左半边和右半边进行有序合并 merge(arr, l, mid, r)&#125;function merge(arr, l, m, r) &#123; //辅助数组 let help = [] //辅助指针 let i = 0 //左半部分指针 let p1 = l //右半部分指针 let p2 = m + 1 //当左半部分数组和右半部分数组都有元素时 while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //arr[p1]与arr[p2]哪个小，就先填写在辅助数组上,同时指针向后移一位 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] //当只有左半部分数组有值时 while (p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; //当只有右半部分数组有值时 while (p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; //复制回原数组 for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125; &#125;&#125; 时间复杂度T(n) = 左右两部分递归 2T(n/2) + merge的过程 O(n)，所以时间复杂度为O(n * logn) 系统递归压栈的过程 f1( )调用 f2( ) f2( )调用 f3 () f3( ) 退出 , 接着调用 f4( ) f4( )退出， 调用 f5 ( ) f5( ) 退出，，f3( )退出，f2( ) 退出， f1 ( ) 退出 系统怎么做这个过程呢？ 压栈:指的是系统将函数的所有现场信息，记录在一个栈里. 系统将f1压栈 =&gt; 将f2压栈 =&gt; 将f3压栈 =&gt; f3弹出 =&gt; f4压栈 =&gt; f4弹出 =&gt; f5压栈=&gt;f5弹出 =&gt; f3弹出=&gt; f2弹出 因此递归是可以改成非递归的，你不使用系统帮你压栈即可。 为什么说工程上尽量不使用递归排序呢？1.准备一个函数并运行它是十分消耗资源的2.在递归压栈的过程中，系统会帮你把函数的所有信息都保存。而我们在业务中，不一定需要那么多的信息。3.系统的栈是有限制的。 额外空间复杂度 因为在merge的过程中，需要一个额外的数组，所以额外空间复杂度是O(n) 是否存在额外空间复杂度为O(1)的？网上的为原地归并排序，但时间复杂度从O(N * logN) 变成了 O(N ^ 2)，不对。 内部缓存法可以正确降低额外空间复杂度。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序随机快排的流程 在一个数组中，随机确定一个数num。 &lt; num 的放左边， = num 的放中间，&gt; num的放右边 递归的重复上过程，将左边的部分排好。 递归的重复上过程，将右边的部分排好。 如此这般，重复，直到整个数组排好。 快速排序过程 随机选择一个数 randomNum 将array[array.length - 1] 与 array[randomNum] 交换位置。即，随机选择的数与原数组中最后一个数交换位置 然后 &lt; array[array.length - 1] 的放右边， &gt; 的放左边， = 的放中间，那么这个过程怎么做？ 将随机选择的数设为p，p放到数组末尾。 数组分为3个部分： 1&lt;p 区域+ 原数组 + &gt; p 区域 m作为一个指针，扫描原数组 m = 0，array[0] = p , 此时m继续向下走，m++ m = 1，array[1] &lt; p，那么array[m] 与 &lt; p 区域的下一个数交换位置。然后m++，即 &lt; p 的区域增加了一个位置。 即一个数，它 =p , m++；它 &lt;p，就与&lt;p的区域的下一数交换位置，m++。这样 = p的在一个区域, &lt;p的在一个区域。 m = 2, array[2] &gt; p, 那么array[m] 与 &gt; p 区域的前一个数交换位置, m 原地不动，不加不减， &gt; p 的区域增加了一个位置。 继续看此时，array[m] 是 = p的，还是 &lt; p的，还是 &gt; p 的。重复上述过程。 一旦m与 &gt; p 的区域碰上，整个过程停止。 该过程也叫荷兰国旗问题， partition的过程 我们递归调用partition的过程，多个 = p 区域的部分合起来，就是排好序的数组了 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这里解释partition部分，同时也是荷兰国旗问题// 要partition的数组是arr，左边界是l，右边界是rfunction partition (arr, l, r) &#123; //小于区域为less，大于区域为more let less = l - 1 let more = r //l作为扫描数组的指针，是不能碰到 大于区域 的边界的。当l = more 的时候整个区域都调完了 while (l &lt; more) &#123; //如果arr[l]的值 小于 我们选择的划分值 arr[r] (此时我们选择的值已经放在了数组的最末位了)，less 区域扩大一位，将此时less指向的数值与我们的arr[l]交换。保证less 代表的小于区域是小于我们选择的 划分值 arr[r]的。l要继续向前进一位。 //只有arr[l]和arr[r]相等时，l和less的才会错开，即less区域的下一位上的数值不管怎样，一定是等于arr[r]的。即交换后的arr[l]知道了自己所在的范围。所以l++，指向下一个数去确定它在哪个区域。 if (arr[l] &lt; arr[r]) &#123; swap(arr, ++less, l++) &#125; //如果arr[l]的值 大于 我们选择的划分值arr[r]，more区域就要扩一位，此时more代表的数值要与我们arr[l]交换。因为我们想要中间的区域是等于 划分值arr[r]的，又因为我们根本不确定此时的arr[l]即之前的减过一位的arr[more]是否等于arr[r]，所以我们的 l 不动。 //即我们将more的前一位与已知自己所在范围的arr[l]交换过来了，此时的arr[l]是不知道自己所在范围的，所以我们的l不动。 if (arr[l] &gt; arr[r]) &#123; swap(arr, --more; l) &#125; //相等，没什么好说的，l指向下一位 if (arr[l] = arr[r]) &#123; l++ &#125; //最后还剩下一个等于划分值arr[r]很早被我们安排在了末尾，我们让它和 大于区 的边界上的第一个数交换, 此时原more位置上的数是arr[r]，原r位置上的数是arr[more]。 swap(arr, more, r) //这样做到了 小于划分值的在左边，大于划分值的在右边，等于划分值的在中间。 //返回等于区的左边界和右边界 return [less + 1, more] &#125;&#125;&#125; 时间复杂度 第1步 选一个随机的划分值。 O(1) 第2步 partition的过程有3个分支， p分支。在partition的过程的几个分支中，l要么向右走（l++），要么more向左走(more–)，l和more碰上整个过程就会停止(l &lt; more)。所以partition的规模是数组的长度的。O(n) 第3步 左侧和右侧剩下的 &gt;p 和 p 或者 &lt;p 的部分特别大，那么我们递归的复杂度就很大。 如果划分值每次都在第一个或者最后一个，那么复杂度就会很差。是O(n^2) 我们选择划分值选随机值，可以避免上面说的情况。并且我们希望我们的算法不与输入数的规律有关。 随机选，我们不会轻易给出一个最差情况的例子。我们的时间复杂度是一个概率表达，与数据的规律无关。 随机选，我们运气好，划分值选在中间位置。 p的区域是N/2的数量级。那么我们时间频度的公式 T(N) = O(1) + O(N) + 2T(N/2)（2T(N/2)是左右区域递归），即T(N) = 2T(N/2) + O(N) mater公式 T(n) = aT(N/b) + O(N^d) aT(N/b)是递归子过程的规模，O(N^d)是递归行为之外的复杂度 如果 log(b，a) = d ，那么复杂度O(n^d * logN ) 如果 log(b，a) &gt; d ，那么复杂度O( n^(log(b, a) ) ),即以b为底 如果 log(b，a) &lt; d ，那么复杂度O(n^d ) 由于master公式，我们可以得到最佳情况下时间复杂度是O(n*logn)，因为是随机取划分值，所以不会出现最差情况O(n^2)。 空间复杂度 快速排序中，额外空间复杂度最低为O(logN)。为什么？1.要记录中间断点的位置，做左侧递归，再做右侧递归。2.为什么要记录中间断点的位置？先做完左侧递归，才去做右侧递归，做完左侧递归，一定要知道中间断点的位置，你才能去进行右侧递归。3.你每一次的递归都需要打断点。第一次打一个断点，第二次打2个断点，第三次打4个断点，这样就形成了一个树。4.因为断点使用完是会释放的，所以这棵树有多高，我们就打几个断点。5.这棵树有多高？数组的长度决定了树的高度，即log(2)N就是树的高度。6.所以记录 logN 个的断点位置 的 这些个变量你是省不下来的。 稳定性 快速排序可以做到稳定性，是论文级别的！ 我们在partition的过程中，不能保证相对次序。所以不能保证稳定性。 稳定做法：找一个辅助数组，对数组遍历3遍，p 放好。但是这就不符合快排的优点了：常数项少，空间复杂度小。 扩展要求奇数放在左边，偶数放在右边，要求奇数和偶数在排序的过程中，相对次序保持不变，且不给额外空间，不用额外数组。能做到吗？ 回答：不能1.我们将奇数和偶数作为一个标准，奇数是1，看作大于某一个数 ， &gt;=p；偶数是0，看作小于等于某一个数 &lt;=p。奇数2.如果我们能完成这道题，相当于完成了partition，这是做不到的。如果你做到了，快排就稳定了。 系统中的排序 数据量大时，是一个快排。 当快排的规模慢慢变小时，排序方法自动变为插排了 原因：数据量小的时候，插排的常数项少，常数操作少，排序快。虽然时间复杂度高，但是O(n^2)，n^2的特性表达的不明显。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序的引子]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BC%95%E5%AD%90%2F</url>
    <content type="text"><![CDATA[快速排序的引子A和B两数组，想找在B中存在但是在A中不存在的数？ 二分如果数组的长度为N，每一次分一半，一共能分几次？是 log2(N)简称为logN 思路及时间复杂度分析 A和B两数组，想找在B中存在但是在A中不存的数。A的长度为N，B的长度为M 笨办法从B中拿出一个，在A中遍历。这样时间复杂度O(m * n) 好办法1.将A排序 O(N)2.因为A是有序的，所以B中的每一个数可以通过2分的方式确定在A中有没有。O((logN)M)3.复杂度为 O(N) + O((logN)M)4.看 加号 两边 谁大， 复杂度就是谁（只要高阶项）5.所以看对A排序，怎么做比较好，时间复杂度低 在数组[L, R]中找中位数L + (R - L) &gt;&gt; 1，正确。(L + R) / 2 是可能溢出的 。 代码这里解释我们算法思想的关键部分12345678910111213141516171819202122232425262728293031// 两数组 A 和 B，其中数组A是有序的for (let i = 0; i &lt; B.length; i++) &#123;// l 是数组A的左边界， r 是数组A的右边界 let l = 0 let r = A.length - 1 let contains = false // 循环以下过程确定，B[i]是否在A数组中// A的中位数是A[mid]// 遍历B，B[i]比A[mid]大，则在左边部分 r = mid - 1// B[i]比A[mid]小，则在右边部分 l = mid + 1// b[i] 等于 A[mid]，则正好在中点 while (l &lt;= r) &#123; let mid = l + ((r - l) &gt;&gt; 1) if (A[mid] === B[i]) &#123; contains = true &#125; if (A[mid] &gt; B[i]) &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; if (!contains) &#123; result.push(B[i]) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--选择排序]]></title>
    <url>%2F2017%2F11%2F29%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现不可以做到稳定性 选择排序过程 第一轮排序在 0 到 n - 1 的范围内，找一个最小的放在 0 这个位置。 第二轮排序在 1 到 n - 1 的范围内，找一个最小的放在 1 这个位置。 第三轮排序在 2 到 n - 1 的范围内，找一个最小的放在 2 这个位置。 省略 第 n - 1 排序最后一个不用动了，数组已经排好了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub123456789101112131415// 因为第 i 轮排序，会确定 第 i 个位置为本轮未排序数组范围内的最小值, 从 0 位置开始第一轮// 所以 let i = 0// 因为最后一个数不需要动了，1个数确定是该范围内最小的毫无意义// 所以 i &lt; arr.length - 1for (let i = 0; i&lt; arr.length - 1; i++) &#123;// 从该轮未排序的数组范围内，找最小的数，并放到未排序的数组范围内的第一个位置 let minIndex = i for (let j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex &#125; swap(arr, i, minIndex)&#125; 时间复杂度时间频度公式是一个等差数列，去掉低阶项，却掉常数项，时间复杂度为O(n ^ 2) 空间复杂度只用了常数级别的辅助项，所以空间复杂度为O(1) 稳定性因为每次选择最小的和未排序的部分的第一个位置交换，所以可能存在相对次序的改变，所以是不稳定的 思想总结每一次都选择最小的放在未排序的第一个位置]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--插入排序]]></title>
    <url>%2F2017%2F11%2F28%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现可以做到稳定性 插入排序过程 第一轮比较位置0上的数前无比较数组，不动。 第二轮比较位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]，则交换两者的位置 第三轮比较位置2上的数与位置1上的数比较，如果array[2] &lt; array[1]，则交换两者的位置。此时，位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]。则交换两者的位置。 如果在比较的过程中发现，后一个数 &gt;= 前一个数，停止本轮比较 省略过程 第 n - 1 轮比较所有数都经过上述的插入过程，整个数组就有序了。 和冒泡排序的区别冒泡排序是将数组中的元素向外冒，每一轮都会确定本次比较范围最大的数。而插入排序的每一轮是将数组中的元素向前面有序的数组中插。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526// 0位置上的数是不需要插入的，我们从1位置开始插。// 所以 let i = 1// 因为最后一次的需要向前面有序数组插排的是 n - 1 位置上的数// 所以 i &lt; arr.length// 因为每一轮插排，需要往前插的数的位置，都会往后移一位。 // 所以i++for (let i = 1; i &lt; arr.length; i++) &#123;// i是与其前面的有序数组中的元素进行比较的// 所以 j 从 i - 1开始， j = i - 1// 比较到 有序数组的 0 位置// 所以 j &gt; = 0// 什么时候交换一次位置？// 当前一个比后一个 &gt; 时，交换一次位置// 然后再往前推一位(j--),再次比较交换位置，直到前一个 &lt;= 后一个(不满足 arr[j] &gt; arr[j+1])// 上述是交换位置应该满足的条件 即 arr[j] &gt; arr[j+1] for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j+1]; j--) &#123; swap(arr, j, j+1) &#125;&#125;function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125; 时间复杂度这里，数组中每个元素都要和前面的有序数组一个一个比较，所以其时间频度是个等差数列，时间复杂度是O(n^2) 空间复杂度这里我们用有限的空间去做排序，所以是O(1) 稳定性数组中元素再向前比较时，因为 &lt;= 有序数组中的某一个元素时就停止了，所以相同的元素之间的相对顺序不变，是稳定的。 思想总结类似于插扑克，每一个数和它前面的一组有序的数比较，将其正确的插入有序区。最后，整个数组就有序了。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--冒泡排序]]></title>
    <url>%2F2017%2F11%2F26%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序的过程 第一轮比较：范围是 0 ~ n - 1。过程是：对于给定的一个数组，第一个数和第二个数比较，哪个大就将该数放在后面。紧接着第二个数和第三个数比较，哪个大就将该数放在后面。依次类推，最大的数就会放在数组最后的位置。 第二轮比较：范围是 0 ~ n - 2过程是：同上，第二大的数就放在了数组倒数第二个位置 省略 第 n - 1 轮比较：重复以上的过程，直到最后一次排序时只剩下一个数，我们就可以得到一个有序的数组了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub 1234567891011121314151617181920// 外循环确定我们要排的位置, let e = arr.length - 1// 我们排到只剩下0位置的数时，e &gt; 0 ,结束外循环// 每次排的数组范围都减少1，因为每次排完最后一个位置一定是本次所排序范围的最大值，e--for (let e = arr.length - 1; e &gt; 0; e --) &#123;// 从本次要排的范围的第一个位置开始排 let i = 0// 确定排序范围 i &lt; e// 排序的基本工程，依次向后比 i ++ for (let i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; swap(arr, i, i+1) &#125; &#125;&#125;// 交换function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程是奇淫巧技吗？]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[函数式编程是奇淫巧技吗？JavaScript本身的语法特性以及各种各样函数式库的流行，让函数式编程这个话题越来越热。本文秉承存在即合理的概念，探究函数式编程给我们的代码带来的优点。 一等公民在Javascript的世界里，函数是一等公民。那么，一等公民是什么意思呢？一言蔽之，函数在JavaScript中并不是一个特殊的存在，它可以作为参数传递，也可以作为返回值，它的地位是和一个普通对象一样的。下面做个对比来提现一等公民的优势：12345// 滥用一等公民特性的做法// 不必要的对函数做封装const getServerData = (url) =&gt; &#123; return ajaxCall(url)&#125; 如果哪天我们的回调要增加错误处理，我们便需要修改两个部分：ajaxCall和getServerData。1234// 同时我们的ajaxCall函数本身也有添加errconst getServerData = (url) =&gt; &#123; return ajaxCall(url, err)&#125; 正确的做法应该如此直接：1getServerData(url, ajaxCall) 当我们使用高阶函数特性时，一定要小心命名，小心定义参数，这可以帮助我们少做修改，毕竟修改导致变化，而变化会导致bug。而命名的科学可以帮我们少造轮子。 纯函数什么是纯函数，纯函数的意义在哪？在数学上，我们是这么定义一个函数的：对于每一个输入只返回一个特定的输出值。在我们编写程序时，当我们封装的函数内部状态不纯时，我们的输出就会出乎我们的意料。出乎意料就意味着bug，且是难以排查的bug。 我们举一些可能使函数不纯的操作： http请求 可变的数据 用户输入 Dom查询 例如：当你的函数改变了某个data，而结果不是你想要的。这时你发现另外的一个函数监听这个data做了另一份操作。对，我就是在说Vue的watch，vue的灵活性真是让我又爱又恨。 一等公民和纯函数的意义Javascript中函数的一等公民的特性给与了我们一种思想：将业务分解为一个又一个耦合度小的颗粒，行为，让我们以函数作为载体进行编程。这使得： 函数命名清晰使得语义化 函数颗粒度小使得可复用性高 纯函数行为单一，副作用少 可维护性更好 为了引出柯里化和组合下面让我们来看一个例子：需求是给定一个数，先加2再扩2倍，等到一个新数组。123// 很简单哦!let num = arry.map(x =&gt; x + 2)let newArray = arrayAdd2.map(x =&gt; x * 2) 这个时候，需求变了：先扩2倍再扩加212let arrayDoubles = array.map(x =&gt; x * 2)let newArray = arrayDoubles.map(x =&gt; x + 2) 累吗？当然我们的需求不会这么简单 柯里化（curry）和组合（compose）让我们创造一个curry来享受一下函数式编程给我们带来的愉悦享受：12345const add = (x) =&gt; (y) =&gt; x + yconst add2 = add(2)add2(3) //5const add3 = add(3)add3(3) //6 从上面这个简单的例子我们可以看出，柯里化的概念：只传给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 下面让我们来看看组合（compose）,也是一段贴心小代码12345const compose = (f, g) =&gt; x =&gt; f(g(x))const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = compose(f1, f2)nice(3) // 10 这个简单例子向我们阐述了组合的概念：f和g是两个功能单一的函数，它们彼此结合产生了一个解决你需求的新函数，而这个x便是数据流通的管道。想象一下没有组合的世界，好像少那么一点美感（可读性）：12345const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = (x) =&gt; &#123; return f1(f2(x))&#125; 在这里我们强调一点：我们的数据流动方向是从右至左。记得webpack的loader的处理方向么？从右至左。没错，compose的概念。 使用柯里化和组合优化我们的代码还记得我们的需求么？给定一个数，先加2再扩2倍，等到一个新数组。变为了：先扩2倍再加2123456789const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const perfectFn = (...fns) =&gt; x =&gt; fns.reduceRight((val, fn) =&gt; fn(val))// 先加2再扩2倍const resultFn = perfectFn(f1, f2)resultFn(3) // 10// 先扩2倍再加2const resultFn1 = perfectFn(f2, f1)resultFn1(3) // 8 其实只改动传入函数的位置而已。这里牵扯到了闭包保存了fns所在的环境，这里不再做解释了。有兴趣的同学可以查一下资料。 小结可以看出来函数式编程并不是一个宗教，而是我们应对工程的一种手段。它和面向对象等编程思想并不冲突，都是为了我们能够更好为业务服务。]]></content>
      <categories>
        <category>JavaScript之美</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
</search>
