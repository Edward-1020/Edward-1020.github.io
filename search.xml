<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript经典算法--BFPRT]]></title>
    <url>%2F2018%2F01%2F02%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-BFPRT%2F</url>
    <content type="text"><![CDATA[BFPRT在数组中，求第k小的数？或者求第k大的数。 各个方法优劣分析 如果对数组中的数排序求解，时间复杂度是O(N * logN)。而我们希望的时间复杂度是O(N)。 原始流程：利用快排partition的过程，比p小的放左边，和p相等的放中间，比p大的放右边。如果相等的部分命中k，那么得出答案。如果未命中，那么看k是在P的部分。这个过程平均下来的时间复杂度是O(N)。 BFPRT：快排的划分值P是随机选的，而BFPRT的算法划分值的选择并不是随机的。 BFPRT如何选择划分值的 相邻的5个数是一组，后面不足5个数的单独一组。 O(1)。 在一个组的内部，把数排序，排好。组内排序，组与组之间不排序。因为一个组5个数排序，时间复杂度O(1)。有 N / 5 组，所以这个过程 O(1) * N / 5。即时间复杂度是O(N)。 因为一个组中，数是有序的。我们可以很方便的得到组内的上中位数。（奇数：无上中位数。偶数：例如1234，上中位数是2，下中位数是3）。所以，组内的中位数是第3个数。将每个组的上中位数拿出来组成一个数组newArr，这个数组的大小是N / 5，它的上中位数是第 N / 10 小的数。我们的题要求，求第k小的数，用函数表达为f(arr, k)。自己调用自己求newArr的上中位数，即f(newArr, N / 10)，可以求出newArr的第 N / 10小的数。 总结一下，分组后拿出组内的上中位数组成一个新的数组，再求新数组的上中位数。 将新数组中的上中位数拿去做划分值，做partion过程，看=P的范围是否命中K。没命中，继续递归。 为什么时间复杂度是O(N) 随机划分值，做partion的过程，我们不能确定P部分递归的大小。这个规模你是无法保证。 在新数组中，第 N / 10 位置的数，假设为M。组内中位数组成的新数组的中位数是第 N / 10 位置的数，即至少有 N / 10 个数比M小。 而在原来的每5个位一组的小数组中。某个小数组的中位数比第 N / 10位置上的数小，这个小数组的中位数下，还有2个数也比第 N / 10 位置上的数小。即最少有 3N / 10 个数比M要小。即最多有 7N/10 个数比M大。 对于M来说，最多有 7N/10 个数比它大。 M又是作为partion过程的划分值的，即我们&gt;P过程的递归规模是可以确定的。 即我们可以确定的淘汰掉一定规模的数，因此我们的递归规模收敛到O(N)。 第一步：分组，每5个位一组，O(1)。第二步：组内排序，O（N）。第三步：自己调用自己。原过程递归是T(N)规模，自己调用自己是T（N / 5）的规模，因为新数组的规模是原来数组的1 / 5。第四步：partion，O（N）。第五步：只走一侧递归，最大递归规模是T（7N / 10）。所以整个复杂度是：O(1) + O（N）+ T（N / 5）+ O（N）+ T（7N / 10），这个式子可以收敛到O(N)。 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142function getMinKthByBFPRT (arr, K) &#123; let copyArr = copyArray(arr) // 主流程 return select(copyArr, 0, copyArr.length - 1, K - 1)&#125;// 给定一个数组，给定一个范围[begin, end]，求第i小的数function select (arr, begin, end, i) &#123; if (begin === end) &#123; return arr[begin] &#125; // 求划分值M int pivot = medianOfMedians(arr, begin, end) // 利用求出的划分值去Partition，返回 =M 的区域。 let pivotRange = partition(arr, begin, end, pivot) // 看我们第i小的数是否命中了pivotRange这个区域 if (i &gt;= pivotRange[0] &amp;&amp; i&lt;= pivotRange[1]) &#123; return arr[i] // 如果没命中 = M 区域，那么或者走左边，或者走右边 &#125; else if (i &lt; pivotRange[0]) &#123; return select(arr, beigin, pivotRange[0] - 1, i) &#125; else &#123; return select(arr, pivotRange[1] + 1, end, i) &#125;&#125;// 在一个数组中求划分值Mfunction medianOfMedians (arr, begin, end) &#123; // 在[begin, end]的范围内，有多少个数 let num = end - begin + 1 // 是否有剩余数构成一组 let offset = num % 5 === 0 ? 0 : 1 // 数组mArr是各个组的中位数组成的新数组 let mArr = new Array(num/5 + offset) // for循环每5个数为一组，并排序。从每组中取中位数放入新数组中。 for (int i = 0; i &lt; mArr.length; i++) &#123; let beginI = begin + i * 5 let endI = beginI + 4 mArr[i] = getMedian(arr, beginI, Math.min(end, endI)) &#125; // 新数组递归的调用select求数组自己的上中位数 return select(mArr, 0, mArr.length - 1, mArr.length / 2)&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--Manacher]]></title>
    <url>%2F2017%2F12%2F27%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-Manacher%2F</url>
    <content type="text"><![CDATA[Manacher在一个字符串里，怎么找到最长的回文子串，求它的长度？ 易混淆概念 回文：字符串的正序和逆序是一样的。 子串和子数组是连续的，子序列可不连续。例如abc的子串是ab，ac。子序列是ac。 最长的回文子串，例如abc12321de的最长回文子串是12321。 笨办法简述 从某一个位置，依次向两边扩。这样只能找到奇回文。即长度为奇数的回文。例如：abc12321de，你从3开始向两边扩，可以找到12321这样的奇回文。但是abc1221de，你是找不到1221这样的偶回文的。 笨办法（特殊字符处理） a12321b，处理为-a-1-2-3-2-1-b-。 a1221b，处理为-a-1-2-2-1-b-。 这样，我们以某一位置向两边扩，都可以找到回文。且不影响结果。 相当于对于偶回文，我们为它加了一个轴，让它有一个向两边扩的出发点。 我们增加的特殊字符，永远是和特殊字符比，不会和原字符串中的有效字符去比较。 笨办法时间复杂度 时间复杂度是O(n^2) 例如某个处理过的字符串长n，第一个位置扩0次，第二个扩2次。。。 扩的总次数 1 + 2 + 3 + … + n/2 + (n/2 - 1) + … + 1 。 所以总的时间复杂度是O(n^2) 回文半径从某个位置出发，它能够扩多远。 最右回文边界R “)”假设为最右回文边界， )-1-2-1-。一开始没扩，停留在最右边。 在0位置向两边扩，扩不动了。因为左边没东西。那么最右回文半径就来到了0位置。 在1位置向两边扩，扩了一个位置。即-1-。此时，最右回文边界来到了位置2。 在3位置向两边扩，即-1-2-1-。此时，最右回文边界来到了位置5，即字符串的最右边。 即最右回文边界表示，当前我扩到了哪个位置，忽略是哪个位置扩的，只管扩到的最右的位置。 C当我取得最右回文边界时，中心在哪，就是C。只有当R变化时，C才会变化。C和R一样，只记录最早的。当R更新时，即向右前进了，我们的C才会相应的更新。 arr字符串从首位置，从左往右依次扩。每个位置的回文半径我们都记在数组arr里。 ###做法 指针在字符串的某个字符上时，回文右边界未包括该字符，继续扩。例如：在一次扩的过程中，）8，回文右边界在8的左边，不包括8。 指针在字符串上的 I 位置，回文右边界 R 在 I 的右边，即包括 I 。那么 C 在 I 的左边是一定的。此时，我们也可以求得，以 C 为中心，R为右边界的对称的左边界L。I 作以C为参照物的对称点I’。 此时我们的拓扑结构是L I’ C I R。L和R之间是回文，且此时我们的I’点的回文半径，我们之前是求出来过的。 情况一：i’的回文半径在[L, R]内，此时I的回文半径与i’的回文半径相同。 情况二：i’的回文半径有部分在[L,R]之外，此时I的回文半径是I到R这一部分[I, R]，长度等于[L, I’]。 情况三：i’的回文半径正好在L上，此时无法确定I的回文半径是否能超过R。只能去扩，去试。 情况总结 情况一：I在R的右边（[L,R]范围外），无法加速，扩。 情况二：I在R的内部，I’的回文半径在L内，不需要扩，I的回文半径与I‘的回文半径相等。 情况三：I在R的内部，I’的回文半径有一部分在[L，R]内，不需要扩，I的回文半径是I到R。 情况四：I在R的内部，I’的回文半径在L上（压线），扩，但是I到R的部分一定是回文，这一部分就不需要扩了。从R位置扩就好。 时间复杂度估计 情况二和情况三，因为I的回文半径是确定的，所以时间复杂度是O(1)。 情况一和情况四，如果能扩，R一定会向右走。R只增大不减小，R最多向右边移动多少呢？N。所以时间复杂度是O(N) 所以整个算法的时间复杂度是O(N)。 代码1234567891011121314151617181920212223242526272829303132333435363738function maxLcpsLength (str) &#123; if (!str || str.length === 0) &#123; return 0 &#125; // 处理成manacher字符串 let charArr = manacherString(str) let C = -1 // 最右回文边界 let R = -1 let max = Number.MIN_SAFE_INTEGER for (let i = 0; i != charArr.length ; i++) &#123; // 情况二和情况三 I 的回文半径已知，实际上是不需要扩的，但是code中，我们给出 I 的回文半径，让I在这个基础上扩一扩试试。 // 即我们求出 I 位置的回文半径起码是多远.然后用while循环在这个基础上扩 // pArr[2 * C - i]，对称点的回文半径 // Math.min(pArr[2 * C - i], R - i)，整合了i&apos;在R内的情况，谁短谁是最起码的回文半径 pArr[i] = R &gt; i ? Math.min(pArr[2 * C - i], R - i) ： 1 // 条件 ：i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1 判断在 I 位置扩的时候，新的回文左边界和右边界是否数组越界 while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; // while循环，针对情况二和情况三是不需要扩的。在第一次循环就会不满足条件，以至于break // 针对情况一，情况四，都在最起码的回文范围上，继续暴力扩 // 因此，针对情况一二三四统一写成一下代码 // 条件：charArr[i + pArr[i]] === charArr[i - pArr[i]，左边界等于右边界，回文半径增加。不等 break if (charArr[i + pArr[i]] === charArr[i - pArr[i]]) &#123; pArr[i]++ &#125; else &#123; break &#125; &#125; // 如果最右回文边界被我推得更远了，记录一个新的R和C if (i + pArr[i] &gt; R) &#123; R = i + pArr[i] C = i &#125; // 每次记录最大回文半径 max = Math.max(max, pArr[i]) &#125; return max - 1&#125; 扩展一个字符串，只能在后面增加字符，让它变成回文串。还要让增加的字符最少。如何做？ 这道题变为，必须包含最后一个字符的情况下，最长回文子串的长度是多少？ 举个例子：原字符串abc12321，必须包含最后一个字符的情况下，最长回文子串是12321，前面不是的部分，逆序添加到末尾。即abc12321cba。添加的cba是最短的。 manacher算法逐渐向右扩展的时候，第一次R到达结尾的时候，停止。我们知道R在哪，C在哪，因此我们就知道L在哪。我们把L之前的子串，逆序放到末尾。得出结果。即改写了manacher算法。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（二）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（二）如何判断一棵树，它子树的某一个结构，是另外一个树的结构。例如。树1：1234567 与树2：367。树1的子树367与树2一样。 常规做法暴力尝试每一个开头，并以第二棵树的方式去遍历。如果一个开头能以第二棵树的方式遍历出来，即每个支点的值一样。 二叉树序列化（作为字符串）每个值后跟-，空值视作#并也跟-。例如123，序列化后就是1-2-#-#-3-#-#-。 二叉树反序列化 1-2-#-#-3-#-#-。很容易可以看出来树是123。 内存中的树，序列化后持久化存在硬盘中。再从硬盘中反序列化到内存中。 不用特殊符号表示空和一个数的结尾，反序列化就会乱。比如111，你根本不知道是啥结构。 序列化的信息既代表了这个树的值信息，也代表了这个树种的结构信息。 本题解法将A树序列化为strA，B树序列化为strB。用KMP，strA中包含strB，那么A这棵树一定包含B这棵树。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（一）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（一）有一个字符串，经过处理，包含两个自己，且开始的位置不一样。怎么添加字符最短？例如：原字符串是aaa，处理过后是aaaa，包含两个aaa。 实质元字符串处理完成后，最大前缀和最大后缀是贴在一起的，例如aaaaa的最大前缀是aaaa不包含最后一个a，最大后缀是aaaa不包含首位置的a。即：这个题目就变成了，原字符串的最大前缀和最大后缀重合多少，不重合的部分添在原字符串的后面即可。例如：abcabc-，-位置的最大前缀和最大后缀的部分匹配值是3。只需要在原字符串后添加2位置后的字符串即可。即在abcabc后再添加一个abc，]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--KMP]]></title>
    <url>%2F2017%2F12%2F13%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%2F</url>
    <content type="text"><![CDATA[KMP 复杂度是O(N) 有str1，str2两个字符串，求st1里面是否包含str2?且返回str2的位置。例如：str1是abc123def，str2是123，如果包含 f1(str1, str2 ) = 3。如果str1 不包含 str2，那么 f1(str1, str2) = -1 笨办法 str1 长度为N，str2 长度为M 从 str1 的0位置开头，配str2 从 str2 的1位置开头，配str2 最差的情况尝试str1每一个位置为开头，且每一轮都配M次，这个时间复杂度为O(N * M) 前缀与后缀 我要建立基于 str2 字符串的一组信息。叫做：最大前缀和最大后缀的部分匹配值。 前缀不能到最后一个字符，后缀也不能到第一个字符。 例如：str2是abcabcd。我们生产一个next数组，数组长度和str2的长度一样。next数组的值是什么？ 对于str2的 a，a的前面没有字符串，那么对应的next数组上的值是 - 1。 对于str2的 b，b的前缀不能到第一个字符，那么对应的next数组上的值是 0。 即对于str2 的 0位置，1位置。next数组上的值时-1 和 0。 以上是 0，1位置在next数组中的对应值，对于普遍位置来说，引入最大前缀和最大后缀的部分匹配值。 “最大前缀与最大后缀部分匹配值”的概念str2 是 abcabc | d 对于d，以1为单位。前缀是a，后缀是c。不匹配。 对于d，以2为单位。前缀是ab，后缀是bc。不匹配。 对于d，以3为单位。前缀是abc，后缀是abc。匹配。 对于d，以4为单位。前缀是abca，后缀是cabc。不匹配。 对于d，以5为单位。前缀是abcab，后缀是bcabc。不匹配。那么最大前缀和最大后缀是5时，部分匹配值是3，d对应的next数组中的值为 3。这是next数组中数的意义，是最大前缀与最大后缀部分匹配值。 next数组匹配方法 对于str2上的每一个字符，我们根据next数组，有了其最大前缀和最大后缀部分匹配值。 即最大前缀和最大后缀中存在长度为k的相同前缀和后缀,这个值就存在next数组中，表示Str2每个位置的k值。 对于字符串转化的数组P的q位置的匹配值：next[q] = k 。表示P[q]之前的子串中，存在长度为k的相同前缀和后缀 举例：对于str1：1234abc1234k 与 str2：1234abc1234a。根据next数组，其最大前缀与最大后缀匹配。第一次配型时，从1开始配，str1与str2比较到a这个位置时，配型失败。那么第二次配型就没必要从2开始配了。从第二个1234开始配，看k和a是否相等即可。 这样就加速了 笨方法配型。 next数组加速配型的实质对于str1：1234abc1234k 与 str2：1234abc1234a。我们抛弃了k之前的字符串，将str2往后推，让1234k与1234a比较。因为1234相等，所以看k和a即可。 next数组加速配型的原因反证法：对于str1：1234abc1234k 与 str2：1234abc1234a。如果k之前的字符串中，一个随机的位置开始，能和str2匹配上。那么，我们之前求得的next数组的最大前缀和最大后缀匹配就不成立了。因为会有一个更大的最大前缀和最大后缀匹配。 next数组加速配型的时间复杂度对于str1：…M 与 str2：…。有两个相斥的行为，以str1是否移动为分界。一是：str1是一个一个往后滑，最多滑str1的长度，是O(N)。二是：str2在str1不滑动时，滑到最大前缀和最大后缀匹配位置，最多滑str1的长度，是O(N)。整体2O(N)，即O(N)。 next数组加速配型代码过程12345678910111213141516171819202122232425262728293031function getIndexOf (s, m) &#123; if (s === null || m === null || m.length &lt; 1 || s.length &lt; m.length) &#123; return -1 &#125; // 构造字符串数组 let str1 = s.split(&apos;&apos;) let str2 = m.split(&apos;&apos;) // 两个指针分别用于str1和str2的字符串比较 let i1 = 0 let i2 = 0 // 得到str2的next数组 let next = getNextArray(str2) // 利用next数组加速比较过程 while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123; // 比较 if (str1[i1] === str2[i2]) &#123; // 该位置上字符相等，两个指针均向后移动 i1++ i2++ &#125; else if (next[i2] === -1) &#123; // next数组中 -1 表示 i2指针指向了字符串的首位，且此时i1指向的字符和i2指向的字符不等，i1指针向后推 i1++ &#125; else &#123; //此时i1指向的字符和i2指向的字符不等。再次比较时，i2指到next数组中的最大前缀与最大后缀匹配的位置，再与i1比较。 //即next数组帮助指针忽略了最大前缀个位置，直接比较最大前缀的下一位。这样就不需要再从str2的零位置与str1的i1位置一个一个苦苦比较了。 i2 = next[i2] &#125; &#125; // 当i2指向str2的末尾时，即i2到了边界，我们已经在str1上配出来一个str2了，比较完成。如果循环结束还没指向末尾，则str1里找不到str2的匹配，返回一个-1。 return i2 === str2.length ? i1 - i2 : -1&#125; next数组求解代码过程 我们要知道，next数组上存的值，最大前缀和最大后缀的部分匹配值。 我想求str2上i位置的next数组值，那么我们i - 1位置上的next数组的值一定是已经求出来的。 设 i - 1 为 b ，设 i 为a。 b 的indexPreB（最大前缀部分匹配值的位置） + 1 和 b的 indexSuffixB（最大后缀部分匹配值的位置） + 1 就是 a 的最大前缀部分匹配值的位置和 a 的最大后缀部分匹配值的位置。不过，需要判断一下，也有可能不是。 如果是，那么indexB + 1 位置的值与 b 位置的值相等。 如果不是，则不相等。设 b 的indexPreB（最大前缀位置） + 1位置是 c 。 求 c 的next数组值，即想要知道他的最大前缀和最大后缀匹配值(长度为k的相同前缀与后缀)。看 c 的最大前缀部分匹配值的位置的下一个位置与 c 本身是否相等。相等，则就求出了 a 的next数组值。 不相等，重复上过程。 跳到 - 1了，那么next数组的值便是0了。123456789101112131415161718192021222324252627function getNextArray (str2) &#123; if (str2.length === 1) &#123; return [-1] &#125; let next = [] next[0] = -1 next[1] = 0 let i = 2 // cn是上述过程中用于比较的值的指针，指针指向最大前缀位置的下一个位置。 // 第一次比较时，cn表示next数组中的值是0，即1位置不存在长度为k的前后缀。 let cn = 0 while (i &lt; str2.length) &#123; // 如果我 i - 1 位置的字符，与你跳到的位置相等，那么next数组的值便是 i - 1 位置next数组的值 + 1。（） if (str2[i - 1] === str2[cn]) &#123; next[i++] = ++cn &#125;else if(cn &gt; 0) &#123; //没配上，cn向前跳 cn = next[cn] &#125;else &#123; //cn跳到0位置了，还没配出最大前缀和最大后缀 next[i++] = 0 &#125; &#125; return next&#125; next数组求解过程的时间复杂度 假设str2的长度是m 设一个指针为i，一个是i - cn i 最大范围是m，i - cn 最大值也是m（cn可以跳到0，表示无最大前后缀） next[i++] = ++cn，i会上升，i - cn 不变 cn = next[cn]，i不变, i - cn 上升 next[i++] = 0, i上升， i - cn 上升 while过程中，要么i上升，要么i -cn上升，要么都上升，所以while过程执行的次数不会大于 2*M 所以时间复杂度为O(M) 时间复杂度 主过程： i 动，i 最多到N i不动，str2右移动，也最多str1长度N这个范围 即，我们常数操作绑定在了N这个变量上。 next数组过程：i 和 i - cn 去衡量这个常数操作过程的时间复杂度 所以总的时间复杂度是O(N)]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--桶排序扩展题目]]></title>
    <url>%2F2017%2F12%2F08%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[桶排序扩展题目一个无序数组，如果有序之后，求相邻数组之间的最大差值？要求：不能使用O(n^2)的排序。 方法概述 有 N 个数，就准备 N + 1 个桶。 求出最大值和最小值的差值：max - min 。 将这个差值在N+1个桶上均分，每个桶放自己范围的数。这个范围记为range。例如有1，2，3。差值是 2/3，则第一个桶放 [1, 1+ 2/3] 大小的数。 最小值放在最左边的桶，最大值放在最右边的桶里。因此一定有一个桶是空桶。 空桶的左边找一个最近的非空桶，右边也找一个。 空桶左边的非空桶中最大的数，和空桶右边的非空桶中最小的数，是相邻的。 空桶左边的非空桶中最大的数 - 空桶右边的非空桶中最小的数 一定大于我们上面记下的 range ，因为空桶本身也有一个range。 我们这么做的目的：相邻数可能来自桶内部，也可能来自桶与桶之间。但，因为有这么一个空桶，所以我们可以证明：我们可以忽略一个桶内的相邻数，因为桶内部的相邻数的差是 &lt;= range 的。我只用关心两个桶之间的差值。 因此，我们的桶没必要搜集所有的数。桶只需要搜集，进入这个桶的最大值和最小值。 问题就变成了：这个数组中的数进桶，更新桶的最大值和最小值。桶进过数是true,没进过是false. 我们的答案一定来自于两个桶之间的差值，非空桶只是为了证明，答案一定不来自于桶的内部。相邻的非空，所有的max - min，算一遍。求最大差值。 整个过程严格 O(N)。 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function maxGap (nums) &#123; let len = nums.length let min = Number.MAX_SAFE_INTEGER let max = Number.MIN_SAFE_INTEGER // 找数组中的最大值和最小值 for (let i = 0; i &lt; len; i++) &#123; min = Math.min(min, nums[i]) max = Math.max(max, nums[i]) &#125; // 如果min和max相等，相当于数组中都是一个数 if (min === max) &#123; return 0 &#125; // 做三个数组。一个是统计每个桶是否为空，一个是统计每个桶的最大值，一个是统计每个桶的最小值 // 即三个数组，表示3个维度的事情。 let hasNum = [] let maxx = [] let mins = [] // 几号桶？ let bid = 0 // 这个for循环用于建立所有的桶信息 for (int i = 0; i &lt; len; i++) &#123; // 确定num[i]进的是几号桶 bid = bucket(nums[i], len, min, max); // 确定bid号桶的最小值 mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i]； // 确定bid号桶的最大值 maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i]); // 确定桶是有值的 hasNum[bid] = true; &#125; let res = 0 let lastMax = maxs[0] let i = 1 for (; i &lt;= len; i++) &#123; if (hasNum[i]) &#123; // 每一个桶的最小值都去找上一个桶的最大值 res = Math.max(res, mins[i] - lastMax); lastMax = maxs[i] &#125; &#125; // 这就是相邻最大差值 return res&#125;// 计算数字num进几号桶function bucket (num, len, min, max) &#123; return ( ((num - min) * len / (max - min)) | 0 )&#125; 小贴士基础类型对稳定性不看重，所以用不稳定但是快的。而自己定义的类，是看重稳定的(mergesort)。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--堆排序]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆 时间复杂度是O(N * logN)，额外空间复杂度O(1)，实现不能做到稳定性 关键步骤：heapInsert，heapify，堆的扩大和缩小操作 注意：1. 堆排序中，建立堆的操作O(N)。2. 堆排序的核心数据结构：堆，也可以说是优先级队列。 描述 堆是一棵完全二叉树结构。什么是完全二叉树？即结构是永远是在成为满二叉树的路上或已经成为完全二叉树了。 数组下标与完全二叉树是有逻辑对应的： 在数组上，i 的左孩子的下标：2 * i + 1 i 的右孩子的下标是：2*i + 2 i 的父节点下标是：( i - 1) / 2 即在数组上我们可以找到一个节点的父节点 以及 左右孩子。 大根堆 概念：1. 大根堆一定是完全二叉树结构。2. 在大根堆中，任何一个节点，都是它下面的整棵树中（包括它自己的那颗树，即以它为头的树），最大的节点。 堆排首先要将一个数组变成大根堆做法是：1. 对每一个数，看它是否比它的父节点大。大就与父节点交换位置。2. 交换位置后，再看它是否比它的父节点大，大就再交换位置。3. 直到它不再比它的父节点大。 这样一个大的数再加入二叉树时，会把比它小的父干掉。如此调出来的，一定是一个大根堆。 关键代码 – heapInsert（调大根堆的过程）这里解释我们排序思想的关键部分，详细代码请见我的GitHub12345678910111213// 数组一上来，我们考察它的每一个位置，将这个数组调成一个大根堆，这个方式简称为heapInsert// 数组上的一个元素，往上看，它比它的父大，就换。换完再往上看，重复上过程。// 如此heapInsert，调成大根堆function heapInsert(arr, index) &#123; // 这里 “arr[index] &gt; arr[(index - 1) / 2”考虑到了两个关系 // 1.我是否比我的父要大 // 2.我到了二叉树的定点，即数组的 0 位置。 （负数 / 2 = 0），我也不满足循环，停止。 while ( arr[index] &gt; arr[(index - 1) / 2] ) &#123; swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 &#125;&#125; 关键代码 – heapInsert 的时间复杂度 完全二叉树如果有 i 个节点，它的高度是 log(2， i)。例如 7 个节点， 3层。 1.当1个节点时，heapInsert的代价是log1。2.当2个节点时，heapInsert的代价是log1 + log23.当n个节点时，heapInsert的代价是 log1 + log2 + log3 + … + logN ，收敛在O(N)4.即建大根堆的过程时间复杂度是 O(N) 在已知大根堆的基础上排序 1.在大根堆上，已知堆顶元素是最大值。将这个值放在最后的位置上。2.将最后位置上的值放在头部。3.此时，最后一个位置上的数就排好了。4.拿掉此时，最后一个位置上的数。 如何 拿掉此时，最后一个位置上的数？用size表示堆的边界，左孩子或者右孩子大于size，即它的左孩子和右孩子不在堆上。因为 我们将 size - 1 ，表示拿掉了此时，最后一个位置上的数。但是，此时 size - 1 大小的堆，不能保证它是大根堆了！ 因为我们上述1，2，3过程破坏了大根堆。所以我们的堆顶要下沉！它与它的左孩子和右孩子比较，它与最大的孩子比较，小于最大的孩子，就下沉。然后，它与此时它的左孩子和右孩子比较，重复上过程。成为大根堆。 再次进行1，2，3过程。每一轮成为大根堆后，都将堆顶和堆的最后一个元素交换位置。然后将堆的大小减少 1。调整头部，看它沉在哪。 反复过程，直到整个堆的size 减完，整个数组有序了。 在大根堆的基础上排序–heapify 代码12345678910111213141516171819202122232425// 从index位置开始往下沉，堆的大小是size// heapify可以调节任何位置，从任何位置往下沉function heapify (arr, index, size) &#123; // 先求左孩子下标 let left = index * 2 + 1 // 循环条件：左孩子的下标是否越界(左孩子越界则右孩子一定越界) while (left &lt; size) &#123; // 如果我的左右两个孩子都有，那么我选择两个孩子中，大的一个作为我lagest变量的值。 let lagest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left // 较大的index 孩子的值，是否比我的值要大，大则lagest的值是较大孩子的Index；否则，lagest的值是我自己的Index lagest = arr[lagest] &gt; arr[index] ? lagest : index // 如果这个最大值的 lagest 就是我，又因为我在大根堆中，所以我比以我为头的树中的所有的值都大，所以过程停止，不动。 if (largest === index) &#123; break &#125; // 下沉，与较大的那个孩子交换 swap(arr, largest, index) // 我来到了孩子的位置 index = largest // 此时，我的左孩子又向下的一层 left = index * 2 + 1 &#125;&#125; 往返以上代码描述的过程！ 总的代码流程1234567891011121314// for循环将每个节点去建大根堆for (let i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i)&#125;// 将0位置（堆顶位置）换到我的最后一个位置let size = arr.lengthswap(arr, 0, --size)// 此时不是大根堆了，我们就去heapifywhile(size &gt; 0) &#123; heapify(arr, 0, size) // heapify后又是大根堆了，我们再将堆顶和末位交换位置 swap(arr, o, --size)&#125;// 一直往复直到整个堆减完（size = 0），堆排序结束 关键点 堆排序引入了堆这种结构 堆排序的两个过程：建立堆和任何一个位置下沉调整的过程 size– ，保证不越界 时间复杂度因为heapInsert的时间复杂度是O(N)；而heapify是一个下沉的过程，其下沉的高度最多是logN级别的；所以说时间复杂度是O(N * logN) 额外空间复杂度–O(1) 一个数 i 是用公式找到左孩子和右孩子 快排中，断点的位置每一次都是用一个变量记录的，这样我们才能知道左右递归的范围。这样也导致，快排的额外空间省不掉的。 可以看出来，堆排所有需要排列的位置都是公式告诉我们的。 但是，堆排的常数项大，我们的指标是O(N * logN)，但是实际运行中，快排的常数项十分小。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序的扩展]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E5%B0%8F%E7%9B%92%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[归并排序的扩展（小盒问题）什么是小盒问题？[3, 5, 1, 4, 6]。3的左边比3小的是0；5的左边比5小的是3；1的左边比1小的是0；4的左边比4小的是3；6的左边比6小的是3、5、1、4。那么小盒为0 + 3 + 0 + 3 + （3 + 5 + 1 + 4） = 20。即每个数的左边比它本身小的数的值累加起来。 笨方法看每个数左边有哪些比它小的数，累加起来。是一个时间复杂度为O(n ^ 2) 的问题。 改写归并排序解小盒问题 – 举个例子： 例子1：[3,4,5,2,6,7] =&gt; 3 | 4 | 5 | 2 | 6 | 73 | 4 merge =&gt; 产生小盒 334 | 5 merge =&gt; 产生小盒 4 5 由例子1 引出 例子2：3 4 5 6 | 7 8 9 10 ，两组数 merge 两组数merge，因为3 比 7 小，所以3 一定比4个数小！因此有一个小盒是 4 * 3 此时放入help[]数组中一个3 即整个问题变成了看看在merge的过程中，看左边与右边比较时，右边有多少个比左边的这个数大。就有多少个小盒，就可求值。 上述做法正确的原因？在每一次merge的时候，两个数字比较之后会放在同一区域内，下一次不会再相遇。 关键代码123456789101112131415161718192021222324252627282930function mergeSort (arr, l, r) &#123; if (l === r) &#123; return 0 &#125; let mid = l + (r - l) &gt;&gt; 1 //左边的小盒 + 右边的小盒 + 整个的小盒 return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r)&#125;function merge(arr, l, mid ,r) &#123; let help = [] let l = 0 let p1 = l let p2 = m + 1 let res = 0 while(p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //如果右边的比左边的大，那有右边有多少个比左边的大，就有多少个小盒 res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] &#125; while(p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; while(p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125;&#125; 扩展2：逆序对问题 什么是逆序对问题？在一个数组中，存在多少对，前面的数比后面的数大？例如：[4, 3, 5, 7, 0]，4和3，4和0，3和0，5和0，7和0是一对。 所以逆序对问题是：右边有多少个数比自己小？本质和小盒问题是一样的。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序时间复杂度O(N * logN)，额外空间复杂度O(N)，实现可以做到稳定性。 ###例子简而言之，是将有序小数组，merge成大的有序数组的过程。举个例子，数组[1,3,2,4] 第一步分为[1, 3]和[2, 4] 第二步分为1，3，4，2 第三步有序合并 [1, 3] 和 [2, 4] 第四步再次有序合并[1, 2, 3, 4] 最终数组有序 归并排序过程及代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function mergeSort (arr, l, r) &#123; //递归跳出条件，只剩下一个数，即l = r if (l === r) &#123; return &#125; //找中间位置做划分点 let mid = l + ((r - l ) &gt;&gt; 1) //递归在不满足条件时，会中断跳出 //对左半边部分做递归，即递归的左子过程 mergeSort(arr, l, mid) //对右半边部分做递归，即递归的又子过程 mergeSort(arr, mid + 1, r) //merge过程 //merge过程同上述例子，左半边和右半边进行有序合并 merge(arr, l, mid, r)&#125;function merge(arr, l, m, r) &#123; //辅助数组 let help = [] //辅助指针 let i = 0 //左半部分指针 let p1 = l //右半部分指针 let p2 = m + 1 //当左半部分数组和右半部分数组都有元素时 while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //arr[p1]与arr[p2]哪个小，就先填写在辅助数组上,同时指针向后移一位 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] //当只有左半部分数组有值时 while (p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; //当只有右半部分数组有值时 while (p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; //复制回原数组 for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125; &#125;&#125; 时间复杂度T(n) = 左右两部分递归 2T(n/2) + merge的过程 O(n)，所以时间复杂度为O(n * logn) 系统递归压栈的过程 f1( )调用 f2( ) f2( )调用 f3 () f3( ) 退出 , 接着调用 f4( ) f4( )退出， 调用 f5 ( ) f5( ) 退出，，f3( )退出，f2( ) 退出， f1 ( ) 退出 系统怎么做这个过程呢？ 压栈:指的是系统将函数的所有现场信息，记录在一个栈里. 系统将f1压栈 =&gt; 将f2压栈 =&gt; 将f3压栈 =&gt; f3弹出 =&gt; f4压栈 =&gt; f4弹出 =&gt; f5压栈=&gt;f5弹出 =&gt; f3弹出=&gt; f2弹出 因此递归是可以改成非递归的，你不使用系统帮你压栈即可。 为什么说工程上尽量不使用递归排序呢？1.准备一个函数并运行它是十分消耗资源的2.在递归压栈的过程中，系统会帮你把函数的所有信息都保存。而我们在业务中，不一定需要那么多的信息。3.系统的栈是有限制的。 额外空间复杂度 因为在merge的过程中，需要一个额外的数组，所以额外空间复杂度是O(n) 是否存在额外空间复杂度为O(1)的？网上的为原地归并排序，但时间复杂度从O(N * logN) 变成了 O(N ^ 2)，不对。 内部缓存法可以正确降低额外空间复杂度。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序随机快排的流程 在一个数组中，随机确定一个数num。 &lt; num 的放左边， = num 的放中间，&gt; num的放右边 递归的重复上过程，将左边的部分排好。 递归的重复上过程，将右边的部分排好。 如此这般，重复，直到整个数组排好。 快速排序过程 随机选择一个数 randomNum 将array[array.length - 1] 与 array[randomNum] 交换位置。即，随机选择的数与原数组中最后一个数交换位置 然后 &lt; array[array.length - 1] 的放右边， &gt; 的放左边， = 的放中间，那么这个过程怎么做？ 将随机选择的数设为p，p放到数组末尾。 数组分为3个部分： 1&lt;p 区域+ 原数组 + &gt; p 区域 m作为一个指针，扫描原数组 m = 0，array[0] = p , 此时m继续向下走，m++ m = 1，array[1] &lt; p，那么array[m] 与 &lt; p 区域的下一个数交换位置。然后m++，即 &lt; p 的区域增加了一个位置。 即一个数，它 =p , m++；它 &lt;p，就与&lt;p的区域的下一数交换位置，m++。这样 = p的在一个区域, &lt;p的在一个区域。 m = 2, array[2] &gt; p, 那么array[m] 与 &gt; p 区域的前一个数交换位置, m 原地不动，不加不减， &gt; p 的区域增加了一个位置。 继续看此时，array[m] 是 = p的，还是 &lt; p的，还是 &gt; p 的。重复上述过程。 一旦m与 &gt; p 的区域碰上，整个过程停止。 该过程也叫荷兰国旗问题， partition的过程 我们递归调用partition的过程，多个 = p 区域的部分合起来，就是排好序的数组了 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这里解释partition部分，同时也是荷兰国旗问题// 要partition的数组是arr，左边界是l，右边界是rfunction partition (arr, l, r) &#123; //小于区域为less，大于区域为more let less = l - 1 let more = r //l作为扫描数组的指针，是不能碰到 大于区域 的边界的。当l = more 的时候整个区域都调完了 while (l &lt; more) &#123; //如果arr[l]的值 小于 我们选择的划分值 arr[r] (此时我们选择的值已经放在了数组的最末位了)，less 区域扩大一位，将此时less指向的数值与我们的arr[l]交换。保证less 代表的小于区域是小于我们选择的 划分值 arr[r]的。l要继续向前进一位。 //只有arr[l]和arr[r]相等时，l和less的才会错开，即less区域的下一位上的数值不管怎样，一定是等于arr[r]的。即交换后的arr[l]知道了自己所在的范围。所以l++，指向下一个数去确定它在哪个区域。 if (arr[l] &lt; arr[r]) &#123; swap(arr, ++less, l++) &#125; //如果arr[l]的值 大于 我们选择的划分值arr[r]，more区域就要扩一位，此时more代表的数值要与我们arr[l]交换。因为我们想要中间的区域是等于 划分值arr[r]的，又因为我们根本不确定此时的arr[l]即之前的减过一位的arr[more]是否等于arr[r]，所以我们的 l 不动。 //即我们将more的前一位与已知自己所在范围的arr[l]交换过来了，此时的arr[l]是不知道自己所在范围的，所以我们的l不动。 if (arr[l] &gt; arr[r]) &#123; swap(arr, --more; l) &#125; //相等，没什么好说的，l指向下一位 if (arr[l] = arr[r]) &#123; l++ &#125; //最后还剩下一个等于划分值arr[r]很早被我们安排在了末尾，我们让它和 大于区 的边界上的第一个数交换, 此时原more位置上的数是arr[r]，原r位置上的数是arr[more]。 swap(arr, more, r) //这样做到了 小于划分值的在左边，大于划分值的在右边，等于划分值的在中间。 //返回等于区的左边界和右边界 return [less + 1, more] &#125;&#125;&#125; 时间复杂度 第1步 选一个随机的划分值。 O(1) 第2步 partition的过程有3个分支， p分支。在partition的过程的几个分支中，l要么向右走（l++），要么more向左走(more–)，l和more碰上整个过程就会停止(l &lt; more)。所以partition的规模是数组的长度的。O(n) 第3步 左侧和右侧剩下的 &gt;p 和 p 或者 &lt;p 的部分特别大，那么我们递归的复杂度就很大。 如果划分值每次都在第一个或者最后一个，那么复杂度就会很差。是O(n^2) 我们选择划分值选随机值，可以避免上面说的情况。并且我们希望我们的算法不与输入数的规律有关。 随机选，我们不会轻易给出一个最差情况的例子。我们的时间复杂度是一个概率表达，与数据的规律无关。 随机选，我们运气好，划分值选在中间位置。 p的区域是N/2的数量级。那么我们时间频度的公式 T(N) = O(1) + O(N) + 2T(N/2)（2T(N/2)是左右区域递归），即T(N) = 2T(N/2) + O(N) mater公式 T(n) = aT(N/b) + O(N^d) aT(N/b)是递归子过程的规模，O(N^d)是递归行为之外的复杂度 如果 log(b，a) = d ，那么复杂度O(n^d * logN ) 如果 log(b，a) &gt; d ，那么复杂度O( n^(log(b, a) ) ),即以b为底 如果 log(b，a) &lt; d ，那么复杂度O(n^d ) 由于master公式，我们可以得到最佳情况下时间复杂度是O(n*logn)，因为是随机取划分值，所以不会出现最差情况O(n^2)。 空间复杂度 快速排序中，额外空间复杂度最低为O(logN)。为什么？1.要记录中间断点的位置，做左侧递归，再做右侧递归。2.为什么要记录中间断点的位置？先做完左侧递归，才去做右侧递归，做完左侧递归，一定要知道中间断点的位置，你才能去进行右侧递归。3.你每一次的递归都需要打断点。第一次打一个断点，第二次打2个断点，第三次打4个断点，这样就形成了一个树。4.因为断点使用完是会释放的，所以这棵树有多高，我们就打几个断点。5.这棵树有多高？数组的长度决定了树的高度，即log(2)N就是树的高度。6.所以记录 logN 个的断点位置 的 这些个变量你是省不下来的。 稳定性 快速排序可以做到稳定性，是论文级别的！ 我们在partition的过程中，不能保证相对次序。所以不能保证稳定性。 稳定做法：找一个辅助数组，对数组遍历3遍，p 放好。但是这就不符合快排的优点了：常数项少，空间复杂度小。 扩展要求奇数放在左边，偶数放在右边，要求奇数和偶数在排序的过程中，相对次序保持不变，且不给额外空间，不用额外数组。能做到吗？ 回答：不能1.我们将奇数和偶数作为一个标准，奇数是1，看作大于某一个数 ， &gt;=p；偶数是0，看作小于等于某一个数 &lt;=p。奇数2.如果我们能完成这道题，相当于完成了partition，这是做不到的。如果你做到了，快排就稳定了。 系统中的排序 数据量大时，是一个快排。 当快排的规模慢慢变小时，排序方法自动变为插排了 原因：数据量小的时候，插排的常数项少，常数操作少，排序快。虽然时间复杂度高，但是O(n^2)，n^2的特性表达的不明显。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序的引子]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BC%95%E5%AD%90%2F</url>
    <content type="text"><![CDATA[快速排序的引子A和B两数组，想找在B中存在但是在A中不存在的数？ 二分如果数组的长度为N，每一次分一半，一共能分几次？是 log2(N)简称为logN 思路及时间复杂度分析 A和B两数组，想找在B中存在但是在A中不存的数。A的长度为N，B的长度为M 笨办法从B中拿出一个，在A中遍历。这样时间复杂度O(m * n) 好办法1.将A排序 O(N)2.因为A是有序的，所以B中的每一个数可以通过2分的方式确定在A中有没有。O((logN)M)3.复杂度为 O(N) + O((logN)M)4.看 加号 两边 谁大， 复杂度就是谁（只要高阶项）5.所以看对A排序，怎么做比较好，时间复杂度低 在数组[L, R]中找中位数L + (R - L) &gt;&gt; 1，正确。(L + R) / 2 是可能溢出的 。 代码这里解释我们算法思想的关键部分12345678910111213141516171819202122232425262728293031// 两数组 A 和 B，其中数组A是有序的for (let i = 0; i &lt; B.length; i++) &#123;// l 是数组A的左边界， r 是数组A的右边界 let l = 0 let r = A.length - 1 let contains = false // 循环以下过程确定，B[i]是否在A数组中// A的中位数是A[mid]// 遍历B，B[i]比A[mid]大，则在左边部分 r = mid - 1// B[i]比A[mid]小，则在右边部分 l = mid + 1// b[i] 等于 A[mid]，则正好在中点 while (l &lt;= r) &#123; let mid = l + ((r - l) &gt;&gt; 1) if (A[mid] === B[i]) &#123; contains = true &#125; if (A[mid] &gt; B[i]) &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; if (!contains) &#123; result.push(B[i]) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--选择排序]]></title>
    <url>%2F2017%2F11%2F29%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现不可以做到稳定性 选择排序过程 第一轮排序在 0 到 n - 1 的范围内，找一个最小的放在 0 这个位置。 第二轮排序在 1 到 n - 1 的范围内，找一个最小的放在 1 这个位置。 第三轮排序在 2 到 n - 1 的范围内，找一个最小的放在 2 这个位置。 省略 第 n - 1 排序最后一个不用动了，数组已经排好了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub123456789101112131415// 因为第 i 轮排序，会确定 第 i 个位置为本轮未排序数组范围内的最小值, 从 0 位置开始第一轮// 所以 let i = 0// 因为最后一个数不需要动了，1个数确定是该范围内最小的毫无意义// 所以 i &lt; arr.length - 1for (let i = 0; i&lt; arr.length - 1; i++) &#123;// 从该轮未排序的数组范围内，找最小的数，并放到未排序的数组范围内的第一个位置 let minIndex = i for (let j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex &#125; swap(arr, i, minIndex)&#125; 时间复杂度时间频度公式是一个等差数列，去掉低阶项，却掉常数项，时间复杂度为O(n ^ 2) 空间复杂度只用了常数级别的辅助项，所以空间复杂度为O(1) 稳定性因为每次选择最小的和未排序的部分的第一个位置交换，所以可能存在相对次序的改变，所以是不稳定的 思想总结每一次都选择最小的放在未排序的第一个位置]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--插入排序]]></title>
    <url>%2F2017%2F11%2F28%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现可以做到稳定性 插入排序过程 第一轮比较位置0上的数前无比较数组，不动。 第二轮比较位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]，则交换两者的位置 第三轮比较位置2上的数与位置1上的数比较，如果array[2] &lt; array[1]，则交换两者的位置。此时，位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]。则交换两者的位置。 如果在比较的过程中发现，后一个数 &gt;= 前一个数，停止本轮比较 省略过程 第 n - 1 轮比较所有数都经过上述的插入过程，整个数组就有序了。 和冒泡排序的区别冒泡排序是将数组中的元素向外冒，每一轮都会确定本次比较范围最大的数。而插入排序的每一轮是将数组中的元素向前面有序的数组中插。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526// 0位置上的数是不需要插入的，我们从1位置开始插。// 所以 let i = 1// 因为最后一次的需要向前面有序数组插排的是 n - 1 位置上的数// 所以 i &lt; arr.length// 因为每一轮插排，需要往前插的数的位置，都会往后移一位。 // 所以i++for (let i = 1; i &lt; arr.length; i++) &#123;// i是与其前面的有序数组中的元素进行比较的// 所以 j 从 i - 1开始， j = i - 1// 比较到 有序数组的 0 位置// 所以 j &gt; = 0// 什么时候交换一次位置？// 当前一个比后一个 &gt; 时，交换一次位置// 然后再往前推一位(j--),再次比较交换位置，直到前一个 &lt;= 后一个(不满足 arr[j] &gt; arr[j+1])// 上述是交换位置应该满足的条件 即 arr[j] &gt; arr[j+1] for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j+1]; j--) &#123; swap(arr, j, j+1) &#125;&#125;function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125; 时间复杂度这里，数组中每个元素都要和前面的有序数组一个一个比较，所以其时间频度是个等差数列，时间复杂度是O(n^2) 空间复杂度这里我们用有限的空间去做排序，所以是O(1) 稳定性数组中元素再向前比较时，因为 &lt;= 有序数组中的某一个元素时就停止了，所以相同的元素之间的相对顺序不变，是稳定的。 思想总结类似于插扑克，每一个数和它前面的一组有序的数比较，将其正确的插入有序区。最后，整个数组就有序了。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--冒泡排序]]></title>
    <url>%2F2017%2F11%2F26%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序的过程 第一轮比较：范围是 0 ~ n - 1。过程是：对于给定的一个数组，第一个数和第二个数比较，哪个大就将该数放在后面。紧接着第二个数和第三个数比较，哪个大就将该数放在后面。依次类推，最大的数就会放在数组最后的位置。 第二轮比较：范围是 0 ~ n - 2过程是：同上，第二大的数就放在了数组倒数第二个位置 省略 第 n - 1 轮比较：重复以上的过程，直到最后一次排序时只剩下一个数，我们就可以得到一个有序的数组了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub 1234567891011121314151617181920// 外循环确定我们要排的位置, let e = arr.length - 1// 我们排到只剩下0位置的数时，e &gt; 0 ,结束外循环// 每次排的数组范围都减少1，因为每次排完最后一个位置一定是本次所排序范围的最大值，e--for (let e = arr.length - 1; e &gt; 0; e --) &#123;// 从本次要排的范围的第一个位置开始排 let i = 0// 确定排序范围 i &lt; e// 排序的基本工程，依次向后比 i ++ for (let i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; swap(arr, i, i+1) &#125; &#125;&#125;// 交换function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程是奇淫巧技吗？]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[函数式编程是奇淫巧技吗？JavaScript本身的语法特性以及各种各样函数式库的流行，让函数式编程这个话题越来越热。本文秉承存在即合理的概念，探究函数式编程给我们的代码带来的优点。 一等公民在Javascript的世界里，函数是一等公民。那么，一等公民是什么意思呢？一言蔽之，函数在JavaScript中并不是一个特殊的存在，它可以作为参数传递，也可以作为返回值，它的地位是和一个普通对象一样的。下面做个对比来提现一等公民的优势：12345// 滥用一等公民特性的做法// 不必要的对函数做封装const getServerData = (url) =&gt; &#123; return ajaxCall(url)&#125; 如果哪天我们的回调要增加错误处理，我们便需要修改两个部分：ajaxCall和getServerData。1234// 同时我们的ajaxCall函数本身也有添加errconst getServerData = (url) =&gt; &#123; return ajaxCall(url, err)&#125; 正确的做法应该如此直接：1getServerData(url, ajaxCall) 当我们使用高阶函数特性时，一定要小心命名，小心定义参数，这可以帮助我们少做修改，毕竟修改导致变化，而变化会导致bug。而命名的科学可以帮我们少造轮子。 纯函数什么是纯函数，纯函数的意义在哪？在数学上，我们是这么定义一个函数的：对于每一个输入只返回一个特定的输出值。在我们编写程序时，当我们封装的函数内部状态不纯时，我们的输出就会出乎我们的意料。出乎意料就意味着bug，且是难以排查的bug。 我们举一些可能使函数不纯的操作： http请求 可变的数据 用户输入 Dom查询 例如：当你的函数改变了某个data，而结果不是你想要的。这时你发现另外的一个函数监听这个data做了另一份操作。对，我就是在说Vue的watch，vue的灵活性真是让我又爱又恨。 一等公民和纯函数的意义Javascript中函数的一等公民的特性给与了我们一种思想：将业务分解为一个又一个耦合度小的颗粒，行为，让我们以函数作为载体进行编程。这使得： 函数命名清晰使得语义化 函数颗粒度小使得可复用性高 纯函数行为单一，副作用少 可维护性更好 为了引出柯里化和组合下面让我们来看一个例子：需求是给定一个数，先加2再扩2倍，等到一个新数组。123// 很简单哦!let num = arry.map(x =&gt; x + 2)let newArray = arrayAdd2.map(x =&gt; x * 2) 这个时候，需求变了：先扩2倍再扩加212let arrayDoubles = array.map(x =&gt; x * 2)let newArray = arrayDoubles.map(x =&gt; x + 2) 累吗？当然我们的需求不会这么简单 柯里化（curry）和组合（compose）让我们创造一个curry来享受一下函数式编程给我们带来的愉悦享受：12345const add = (x) =&gt; (y) =&gt; x + yconst add2 = add(2)add2(3) //5const add3 = add(3)add3(3) //6 从上面这个简单的例子我们可以看出，柯里化的概念：只传给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 下面让我们来看看组合（compose）,也是一段贴心小代码12345const compose = (f, g) =&gt; x =&gt; f(g(x))const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = compose(f1, f2)nice(3) // 10 这个简单例子向我们阐述了组合的概念：f和g是两个功能单一的函数，它们彼此结合产生了一个解决你需求的新函数，而这个x便是数据流通的管道。想象一下没有组合的世界，好像少那么一点美感（可读性）：12345const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = (x) =&gt; &#123; return f1(f2(x))&#125; 在这里我们强调一点：我们的数据流动方向是从右至左。记得webpack的loader的处理方向么？从右至左。没错，compose的概念。 使用柯里化和组合优化我们的代码还记得我们的需求么？给定一个数，先加2再扩2倍，等到一个新数组。变为了：先扩2倍再加2123456789const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const perfectFn = (...fns) =&gt; x =&gt; fns.reduceRight((val, fn) =&gt; fn(val))// 先加2再扩2倍const resultFn = perfectFn(f1, f2)resultFn(3) // 10// 先扩2倍再加2const resultFn1 = perfectFn(f2, f1)resultFn1(3) // 8 其实只改动传入函数的位置而已。这里牵扯到了闭包保存了fns所在的环境，这里不再做解释了。有兴趣的同学可以查一下资料。 小结可以看出来函数式编程并不是一个宗教，而是我们应对工程的一种手段。它和面向对象等编程思想并不冲突，都是为了我们能够更好为业务服务。]]></content>
      <categories>
        <category>JavaScript之美</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--基数排序（待续）]]></title>
    <url>%2F2017%2F01%2F04%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序 假设有 5，23，31， 15， 100。 按照最高位补0，005，023，031，015，100。 准备9个桶。0，1，2，3，4，5，6，7，8，9。 按照个位，放入桶。 0桶：100。 1桶：031。 3桶：023。 5桶：015，005。（先进先出） 从0号桶依次倒出：100，031，023，005，015。 按十位进桶，再倒出。 按百位进桶，再倒出。 排序完成。 先排低位再排高位，入桶出桶就排完了。流程改进例如：以374十位上的7为参照，小于等于它的有17个。那么它在十位上的排序为第17位。关键代码]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
</search>
